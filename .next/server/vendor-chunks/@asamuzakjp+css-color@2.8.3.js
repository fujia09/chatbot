"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@asamuzakjp+css-color@2.8.3";
exports.ids = ["vendor-chunks/@asamuzakjp+css-color@2.8.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/index.cjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/index.cjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst convert = __webpack_require__(/*! ./js/convert.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/convert.cjs\");\nconst cssCalc = __webpack_require__(/*! ./js/css-calc.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\");\nconst resolve = __webpack_require__(/*! ./js/resolve.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs\");\nconst util = __webpack_require__(/*! ./js/util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nexports.convert = convert.convert;\nexports.cssCalc = cssCalc.cssCalc;\nexports.resolve = resolve.resolve;\nexports.isColor = util.isColor;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscURBQXFELGlCQUFpQjtBQUN0RSxnQkFBZ0IsbUJBQU8sQ0FBQywySUFBa0I7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsNklBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLDJJQUFrQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUlBQWU7QUFDcEMsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvZnVqaWF3YW5nL0Rlc2t0b3AvY2hhdGJvdC9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KTtcbmNvbnN0IGNvbnZlcnQgPSByZXF1aXJlKFwiLi9qcy9jb252ZXJ0LmNqc1wiKTtcbmNvbnN0IGNzc0NhbGMgPSByZXF1aXJlKFwiLi9qcy9jc3MtY2FsYy5janNcIik7XG5jb25zdCByZXNvbHZlID0gcmVxdWlyZShcIi4vanMvcmVzb2x2ZS5janNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vanMvdXRpbC5janNcIik7XG5leHBvcnRzLmNvbnZlcnQgPSBjb252ZXJ0LmNvbnZlcnQ7XG5leHBvcnRzLmNzc0NhbGMgPSBjc3NDYWxjLmNzc0NhbGM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlLnJlc29sdmU7XG5leHBvcnRzLmlzQ29sb3IgPSB1dGlsLmlzQ29sb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst VAL_MIX = \"mixValue\";\nconst PPTH = 1e-3;\nconst HALF = 0.5;\nconst DUO = 2;\nconst TRIA = 3;\nconst QUAT = 4;\nconst OCT = 8;\nconst DEC = 10;\nconst DOZ = 12;\nconst HEX = 16;\nconst SEXA = 60;\nconst DEG = 360;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\nconst POW_SQR = 2;\nconst POW_CUBE = 3;\nconst POW_LINEAR = 2.4;\nconst LINEAR_COEF = 12.92;\nconst LINEAR_OFFSET = 0.055;\nconst LAB_L = 116;\nconst LAB_A = 500;\nconst LAB_B = 200;\nconst LAB_EPSILON = 216 / 24389;\nconst LAB_KAPPA = 24389 / 27;\nconst D50 = [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585];\nconst MATRIX_D50_TO_D65 = [\n  [0.955473421488075, -0.02309845494876471, 0.06325924320057072],\n  [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],\n  [0.012314014864481998, -0.020507649298898964, 1.330365926242124]\n];\nconst MATRIX_D65_TO_D50 = [\n  [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],\n  [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],\n  [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]\n];\nconst MATRIX_L_RGB_TO_XYZ = [\n  [506752 / 1228815, 87881 / 245763, 12673 / 70218],\n  [87098 / 409605, 175762 / 245763, 12673 / 175545],\n  [7918 / 409605, 87881 / 737289, 1001167 / 1053270]\n];\nconst MATRIX_XYZ_TO_L_RGB = [\n  [12831 / 3959, -329 / 214, -1974 / 3959],\n  [-851781 / 878810, 1648619 / 878810, 36519 / 878810],\n  [705 / 12673, -2585 / 12673, 705 / 667]\n];\nconst MATRIX_XYZ_TO_LMS = [\n  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],\n  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],\n  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]\n];\nconst MATRIX_LMS_TO_XYZ = [\n  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],\n  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],\n  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]\n];\nconst MATRIX_OKLAB_TO_LMS = [\n  [1, 0.3963377773761749, 0.2158037573099136],\n  [1, -0.1055613458156586, -0.0638541728258133],\n  [1, -0.0894841775298119, -1.2914855480194092]\n];\nconst MATRIX_LMS_TO_OKLAB = [\n  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],\n  [1.9779985324311684, -2.42859224204858, 0.450593709617411],\n  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]\n];\nconst MATRIX_P3_TO_XYZ = [\n  [608311 / 1250200, 189793 / 714400, 198249 / 1000160],\n  [35783 / 156275, 247089 / 357200, 198249 / 2500400],\n  [0 / 1, 32229 / 714400, 5220557 / 5000800]\n];\nconst MATRIX_REC2020_TO_XYZ = [\n  [63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314],\n  [26158966 / 99577255, 472592308 / 697040785, 8267143 / 139408157],\n  [0 / 1, 19567812 / 697040785, 295819943 / 278816314]\n];\nconst MATRIX_A98_TO_XYZ = [\n  [573536 / 994567, 263643 / 1420810, 187206 / 994567],\n  [591459 / 1989134, 6239551 / 9945670, 374412 / 4972835],\n  [53769 / 1989134, 351524 / 4972835, 4929758 / 4972835]\n];\nconst MATRIX_PROPHOTO_TO_XYZ_D50 = [\n  [0.7977666449006423, 0.13518129740053308, 0.0313477341283922],\n  [0.2880748288194013, 0.711835234241873, 8993693872564e-17],\n  [0, 0, 0.8251046025104602]\n];\nconst REG_COLOR = new RegExp(`^(?:${constant.SYN_COLOR_TYPE})$`);\nconst REG_CS_HUE = new RegExp(`^${constant.CS_HUE_CAPT}$`);\nconst REG_CS_XYZ = /^xyz(?:-d(?:50|65))?$/;\nconst REG_CURRENT = /^currentColor$/i;\nconst REG_FN_COLOR = new RegExp(`^color\\\\(\\\\s*(${constant.SYN_FN_COLOR})\\\\s*\\\\)$`);\nconst REG_HSL = new RegExp(`^hsla?\\\\(\\\\s*(${constant.SYN_HSL}|${constant.SYN_HSL_LV3})\\\\s*\\\\)$`);\nconst REG_HWB = new RegExp(`^hwb\\\\(\\\\s*(${constant.SYN_HSL})\\\\s*\\\\)$`);\nconst REG_LAB = new RegExp(`^lab\\\\(\\\\s*(${constant.SYN_MOD})\\\\s*\\\\)$`);\nconst REG_LCH = new RegExp(`^lch\\\\(\\\\s*(${constant.SYN_LCH})\\\\s*\\\\)$`);\nconst REG_MIX = new RegExp(`^${constant.SYN_MIX}$`);\nconst REG_MIX_CAPT = new RegExp(`^${constant.SYN_MIX_CAPT}$`);\nconst REG_MIX_NEST = new RegExp(`${constant.SYN_MIX}`, \"g\");\nconst REG_OKLAB = new RegExp(`^oklab\\\\(\\\\s*(${constant.SYN_MOD})\\\\s*\\\\)$`);\nconst REG_OKLCH = new RegExp(`^oklch\\\\(\\\\s*(${constant.SYN_LCH})\\\\s*\\\\)$`);\nconst REG_SPEC = /^(?:specifi|comput)edValue$/;\nconst NAMED_COLORS = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  grey: [128, 128, 128],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  rebeccapurple: [102, 51, 153],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nconst validateColorComponents = (arr, opt = {}) => {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(`${arr} is not an array.`);\n  }\n  const {\n    alpha = false,\n    minLength = TRIA,\n    maxLength = QUAT,\n    minRange = 0,\n    maxRange = 1,\n    validateRange = true\n  } = opt;\n  if (!Number.isFinite(minLength)) {\n    throw new TypeError(`${minLength} is not a number.`);\n  }\n  if (!Number.isFinite(maxLength)) {\n    throw new TypeError(`${maxLength} is not a number.`);\n  }\n  if (!Number.isFinite(minRange)) {\n    throw new TypeError(`${minRange} is not a number.`);\n  }\n  if (!Number.isFinite(maxRange)) {\n    throw new TypeError(`${maxRange} is not a number.`);\n  }\n  const l = arr.length;\n  if (l < minLength || l > maxLength) {\n    throw new Error(`Unexpected array length ${l}.`);\n  }\n  let i = 0;\n  while (i < l) {\n    const v = arr[i];\n    if (!Number.isFinite(v)) {\n      throw new TypeError(`${v} is not a number.`);\n    } else if (i < TRIA && validateRange && (v < minRange || v > maxRange)) {\n      throw new RangeError(`${v} is not between ${minRange} and ${maxRange}.`);\n    } else if (i === TRIA && (v < 0 || v > 1)) {\n      throw new RangeError(`${v} is not between 0 and 1.`);\n    }\n    i++;\n  }\n  if (alpha && l === TRIA) {\n    arr.push(1);\n  }\n  return arr;\n};\nconst transformMatrix = (mtx, vct, skip = false) => {\n  if (!Array.isArray(mtx)) {\n    throw new TypeError(`${mtx} is not an array.`);\n  } else if (mtx.length !== TRIA) {\n    throw new Error(`Unexpected array length ${mtx.length}.`);\n  } else if (!skip) {\n    for (let i of mtx) {\n      i = validateColorComponents(i, {\n        maxLength: TRIA,\n        validateRange: false\n      });\n    }\n  }\n  const [[r1c1, r1c2, r1c3], [r2c1, r2c2, r2c3], [r3c1, r3c2, r3c3]] = mtx;\n  let v1, v2, v3;\n  if (skip) {\n    [v1, v2, v3] = vct;\n  } else {\n    [v1, v2, v3] = validateColorComponents(vct, {\n      maxLength: TRIA,\n      validateRange: false\n    });\n  }\n  const p1 = r1c1 * v1 + r1c2 * v2 + r1c3 * v3;\n  const p2 = r2c1 * v1 + r2c2 * v2 + r2c3 * v3;\n  const p3 = r3c1 * v1 + r3c2 * v2 + r3c3 * v3;\n  return [p1, p2, p3];\n};\nconst normalizeColorComponents = (colorA, colorB, skip = false) => {\n  if (!Array.isArray(colorA)) {\n    throw new TypeError(`${colorA} is not an array.`);\n  } else if (colorA.length !== QUAT) {\n    throw new Error(`Unexpected array length ${colorA.length}.`);\n  }\n  if (!Array.isArray(colorB)) {\n    throw new TypeError(`${colorB} is not an array.`);\n  } else if (colorB.length !== QUAT) {\n    throw new Error(`Unexpected array length ${colorB.length}.`);\n  }\n  let i = 0;\n  while (i < QUAT) {\n    if (colorA[i] === constant.NONE && colorB[i] === constant.NONE) {\n      colorA[i] = 0;\n      colorB[i] = 0;\n    } else if (colorA[i] === constant.NONE) {\n      colorA[i] = colorB[i];\n    } else if (colorB[i] === constant.NONE) {\n      colorB[i] = colorA[i];\n    }\n    i++;\n  }\n  if (!skip) {\n    colorA = validateColorComponents(colorA, {\n      minLength: QUAT,\n      validateRange: false\n    });\n    colorB = validateColorComponents(colorB, {\n      minLength: QUAT,\n      validateRange: false\n    });\n  }\n  return [colorA, colorB];\n};\nconst numberToHexString = (value) => {\n  if (!Number.isFinite(value)) {\n    throw new TypeError(`${value} is not a number.`);\n  } else {\n    value = Math.round(value);\n    if (value < 0 || value > MAX_RGB) {\n      throw new RangeError(`${value} is not between 0 and ${MAX_RGB}.`);\n    }\n  }\n  let hex = value.toString(HEX);\n  if (hex.length === 1) {\n    hex = `0${hex}`;\n  }\n  return hex;\n};\nconst angleToDeg = (angle) => {\n  if (common.isString(angle)) {\n    angle = angle.trim();\n  } else {\n    throw new TypeError(`${angle} is not a string.`);\n  }\n  const GRAD = DEG / 400;\n  const RAD = DEG / (Math.PI * DUO);\n  const reg = new RegExp(`^(${constant.NUM})(${constant.ANGLE})?$`);\n  if (!reg.test(angle)) {\n    throw new SyntaxError(`Invalid property value: ${angle}`);\n  }\n  const [, val, unit] = angle.match(reg);\n  const value = val[0] === \".\" ? `0${val}` : val;\n  let deg;\n  switch (unit) {\n    case \"grad\":\n      deg = parseFloat(value) * GRAD;\n      break;\n    case \"rad\":\n      deg = parseFloat(value) * RAD;\n      break;\n    case \"turn\":\n      deg = parseFloat(value) * DEG;\n      break;\n    default:\n      deg = parseFloat(value);\n  }\n  deg %= DEG;\n  if (deg < 0) {\n    deg += DEG;\n  } else if (Object.is(deg, -0)) {\n    deg = 0;\n  }\n  return deg;\n};\nconst parseAlpha = (_alpha) => {\n  let alpha = _alpha;\n  if (common.isString(alpha)) {\n    alpha = alpha.trim();\n    if (!alpha) {\n      alpha = 1;\n    } else if (alpha === constant.NONE) {\n      alpha = 0;\n    } else {\n      if (alpha[0] === \".\") {\n        alpha = `0${alpha}`;\n      }\n      if (alpha.endsWith(\"%\")) {\n        alpha = parseFloat(alpha) / MAX_PCT;\n      } else {\n        alpha = parseFloat(alpha);\n      }\n      if (!Number.isFinite(alpha)) {\n        throw new TypeError(`${alpha} is not a number.`);\n      }\n      if (alpha < PPTH) {\n        alpha = 0;\n      } else if (alpha > 1) {\n        alpha = 1;\n      } else {\n        alpha = parseFloat(alpha.toFixed(3));\n      }\n    }\n  } else {\n    alpha = 1;\n  }\n  return alpha;\n};\nconst parseHexAlpha = (value) => {\n  if (common.isString(value)) {\n    if (value === \"\") {\n      throw new SyntaxError(\"Invalid property value: (empty string)\");\n    }\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  let alpha = parseInt(value, HEX);\n  if (alpha <= 0) {\n    return 0;\n  }\n  if (alpha >= MAX_RGB) {\n    return 1;\n  }\n  const alphaMap = /* @__PURE__ */ new Map();\n  for (let i = 1; i < MAX_PCT; i++) {\n    alphaMap.set(Math.round(i * MAX_RGB / MAX_PCT), i);\n  }\n  if (alphaMap.has(alpha)) {\n    alpha = alphaMap.get(alpha) / MAX_PCT;\n  } else {\n    alpha = Math.round(alpha / MAX_RGB / PPTH) * PPTH;\n  }\n  return parseFloat(alpha.toFixed(3));\n};\nconst convertRgbToLinearRgb = (rgb, skip = false) => {\n  let rr, gg, bb;\n  if (skip) {\n    [rr, gg, bb] = rgb;\n  } else {\n    [rr, gg, bb] = validateColorComponents(rgb, {\n      maxLength: TRIA,\n      maxRange: MAX_RGB\n    });\n  }\n  let r = rr / MAX_RGB;\n  let g = gg / MAX_RGB;\n  let b = bb / MAX_RGB;\n  const COND_POW = 0.04045;\n  if (r > COND_POW) {\n    r = Math.pow((r + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    r /= LINEAR_COEF;\n  }\n  if (g > COND_POW) {\n    g = Math.pow((g + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    g /= LINEAR_COEF;\n  }\n  if (b > COND_POW) {\n    b = Math.pow((b + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    b /= LINEAR_COEF;\n  }\n  return [r, g, b];\n};\nconst convertRgbToXyz = (rgb, skip = false) => {\n  let r, g, b, alpha;\n  if (skip) {\n    [r, g, b, alpha] = rgb;\n  } else {\n    [r, g, b, alpha] = validateColorComponents(rgb, {\n      alpha: true,\n      maxRange: MAX_RGB\n    });\n  }\n  const [rr, gg, bb] = convertRgbToLinearRgb([r, g, b], true);\n  const [x, y, z] = transformMatrix(MATRIX_L_RGB_TO_XYZ, [rr, gg, bb], true);\n  return [x, y, z, alpha];\n};\nconst convertRgbToHex = (rgb) => {\n  const [r, g, b, alpha] = validateColorComponents(rgb, {\n    alpha: true,\n    maxRange: MAX_RGB\n  });\n  const rr = numberToHexString(r);\n  const gg = numberToHexString(g);\n  const bb = numberToHexString(b);\n  const aa = numberToHexString(alpha * MAX_RGB);\n  let hex;\n  if (aa === \"ff\") {\n    hex = `#${rr}${gg}${bb}`;\n  } else {\n    hex = `#${rr}${gg}${bb}${aa}`;\n  }\n  return hex;\n};\nconst convertLinearRgbToRgb = (rgb, round = false) => {\n  let [r, g, b] = validateColorComponents(rgb, {\n    maxLength: TRIA\n  });\n  const COND_POW = 809 / 258400;\n  if (r > COND_POW) {\n    r = Math.pow(r, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    r *= LINEAR_COEF;\n  }\n  r *= MAX_RGB;\n  if (g > COND_POW) {\n    g = Math.pow(g, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    g *= LINEAR_COEF;\n  }\n  g *= MAX_RGB;\n  if (b > COND_POW) {\n    b = Math.pow(b, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    b *= LINEAR_COEF;\n  }\n  b *= MAX_RGB;\n  return [\n    round ? Math.round(r) : r,\n    round ? Math.round(g) : g,\n    round ? Math.round(b) : b\n  ];\n};\nconst convertXyzToRgb = (xyz, skip = false) => {\n  let x, y, z, alpha;\n  if (skip) {\n    [x, y, z, alpha] = xyz;\n  } else {\n    [x, y, z, alpha] = validateColorComponents(xyz, {\n      validateRange: false\n    });\n  }\n  let [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  [r, g, b] = convertLinearRgbToRgb(\n    [\n      Math.min(Math.max(r, 0), 1),\n      Math.min(Math.max(g, 0), 1),\n      Math.min(Math.max(b, 0), 1)\n    ],\n    true\n  );\n  return [r, g, b, alpha];\n};\nconst convertXyzToHsl = (xyz, skip = false) => {\n  const [rr, gg, bb, alpha] = convertXyzToRgb(xyz, skip);\n  const r = rr / MAX_RGB;\n  const g = gg / MAX_RGB;\n  const b = bb / MAX_RGB;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const d = max - min;\n  const l = (max + min) * HALF * MAX_PCT;\n  let h, s;\n  if (Math.round(l) === 0 || Math.round(l) === MAX_PCT) {\n    h = constant.NONE;\n    s = constant.NONE;\n  } else {\n    s = d / (1 - Math.abs(max + min - 1)) * MAX_PCT;\n    if (s === 0) {\n      h = constant.NONE;\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d;\n          break;\n        case g:\n          h = (b - r) / d + DUO;\n          break;\n        case b:\n        default:\n          h = (r - g) / d + QUAT;\n          break;\n      }\n      h = h * SEXA % DEG;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [h, s, l, alpha];\n};\nconst convertXyzToHwb = (xyz, skip = false) => {\n  const [r, g, b, alpha] = convertXyzToRgb(xyz, skip);\n  const w = Math.min(r, g, b) / MAX_RGB;\n  const bk = 1 - Math.max(r, g, b) / MAX_RGB;\n  let h;\n  if (w + bk === 1) {\n    h = constant.NONE;\n  } else {\n    [h] = convertXyzToHsl(xyz);\n  }\n  return [h, w * MAX_PCT, bk * MAX_PCT, alpha];\n};\nconst convertXyzToOklab = (xyz, skip = false) => {\n  let x, y, z, alpha;\n  if (skip) {\n    [x, y, z, alpha] = xyz;\n  } else {\n    [x, y, z, alpha] = validateColorComponents(xyz, {\n      validateRange: false\n    });\n  }\n  const lms = transformMatrix(MATRIX_XYZ_TO_LMS, [x, y, z], true);\n  const xyzLms = lms.map((c) => Math.cbrt(c));\n  let [l, a, b] = transformMatrix(MATRIX_LMS_TO_OKLAB, xyzLms, true);\n  l = Math.min(Math.max(l, 0), 1);\n  const lPct = Math.round(parseFloat(l.toFixed(QUAT)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    a = constant.NONE;\n    b = constant.NONE;\n  }\n  return [l, a, b, alpha];\n};\nconst convertXyzToOklch = (xyz, skip = false) => {\n  const [l, a, b, aa] = convertXyzToOklab(xyz, skip);\n  let c, h;\n  const lPct = Math.round(parseFloat(l.toFixed(QUAT)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    c = constant.NONE;\n    h = constant.NONE;\n  } else {\n    c = Math.max(Math.sqrt(Math.pow(a, POW_SQR) + Math.pow(b, POW_SQR)), 0);\n    if (parseFloat(c.toFixed(QUAT)) === 0) {\n      h = constant.NONE;\n    } else {\n      h = Math.atan2(b, a) * DEG * HALF / Math.PI;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [l, c, h, aa];\n};\nconst convertXyzD50ToRgb = (xyz, skip = false) => {\n  let x, y, z, alpha;\n  if (skip) {\n    [x, y, z, alpha] = xyz;\n  } else {\n    [x, y, z, alpha] = validateColorComponents(xyz, {\n      minLength: QUAT,\n      validateRange: false\n    });\n  }\n  const xyzD65 = transformMatrix(MATRIX_D50_TO_D65, [x, y, z], true);\n  const [r, g, b] = convertXyzToRgb(xyzD65, true);\n  return [r, g, b, alpha];\n};\nconst convertXyzD50ToLab = (xyz, skip = false) => {\n  let x, y, z, alpha;\n  if (skip) {\n    [x, y, z, alpha] = xyz;\n  } else {\n    [x, y, z, alpha] = validateColorComponents(xyz, {\n      validateRange: false\n    });\n  }\n  const xyzD50 = [x, y, z].map((val, i) => val / D50[i]);\n  const [f0, f1, f2] = xyzD50.map(\n    (val) => val > LAB_EPSILON ? Math.cbrt(val) : (val * LAB_KAPPA + HEX) / LAB_L\n  );\n  const l = Math.min(Math.max(LAB_L * f1 - HEX, 0), MAX_PCT);\n  let a, b;\n  if (l === 0 || l === MAX_PCT) {\n    a = constant.NONE;\n    b = constant.NONE;\n  } else {\n    a = (f0 - f1) * LAB_A;\n    b = (f1 - f2) * LAB_B;\n  }\n  return [l, a, b, alpha];\n};\nconst convertXyzD50ToLch = (xyz, skip = false) => {\n  const [l, a, b, alpha] = convertXyzD50ToLab(xyz, skip);\n  let c, h;\n  if (l === 0 || l === MAX_PCT) {\n    c = constant.NONE;\n    h = constant.NONE;\n  } else {\n    c = Math.max(Math.sqrt(Math.pow(a, POW_SQR) + Math.pow(b, POW_SQR)), 0);\n    h = Math.atan2(b, a) * DEG * HALF / Math.PI;\n    if (h < 0) {\n      h += DEG;\n    }\n  }\n  return [l, c, h, alpha];\n};\nconst convertHexToRgb = (value) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  if (!(/^#[\\da-f]{6}$/.test(value) || /^#[\\da-f]{3}$/.test(value) || /^#[\\da-f]{8}$/.test(value) || /^#[\\da-f]{4}$/.test(value))) {\n    throw new SyntaxError(`Invalid property value: ${value}`);\n  }\n  const arr = [];\n  if (/^#[\\da-f]{6}$/.test(value)) {\n    const [, r, g, b] = value.match(\n      /^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/\n    );\n    arr.push(parseInt(r, HEX), parseInt(g, HEX), parseInt(b, HEX), 1);\n  } else if (/^#[\\da-f]{3}$/.test(value)) {\n    const [, r, g, b] = value.match(/^#([\\da-f])([\\da-f])([\\da-f])$/);\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      1\n    );\n  } else if (/^#[\\da-f]{8}$/.test(value)) {\n    const [, r, g, b, alpha] = value.match(\n      /^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/\n    );\n    arr.push(\n      parseInt(r, HEX),\n      parseInt(g, HEX),\n      parseInt(b, HEX),\n      parseHexAlpha(alpha)\n    );\n  } else if (/^#[\\da-f]{4}$/.test(value)) {\n    const [, r, g, b, alpha] = value.match(\n      /^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])$/\n    );\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      parseHexAlpha(`${alpha}${alpha}`)\n    );\n  }\n  return arr;\n};\nconst convertHexToLinearRgb = (value) => {\n  const [rr, gg, bb, alpha] = convertHexToRgb(value);\n  const [r, g, b] = convertRgbToLinearRgb([rr, gg, bb], true);\n  return [r, g, b, alpha];\n};\nconst convertHexToXyz = (value) => {\n  const [r, g, b, alpha] = convertHexToLinearRgb(value);\n  const [x, y, z] = transformMatrix(MATRIX_L_RGB_TO_XYZ, [r, g, b], true);\n  return [x, y, z, alpha];\n};\nconst parseRgb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  const reg = new RegExp(`^rgba?\\\\(\\\\s*(${constant.SYN_MOD}|${constant.SYN_RGB_LV3})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const [, val] = value.match(reg);\n  let [v1, v2, v3, v4] = val.replace(/[,/]/g, \" \").split(/\\s+/);\n  let r, g, b;\n  if (v1 === constant.NONE) {\n    r = 0;\n  } else {\n    if (v1[0] === \".\") {\n      v1 = `0${v1}`;\n    }\n    if (v1.endsWith(\"%\")) {\n      r = parseFloat(v1) * MAX_RGB / MAX_PCT;\n    } else {\n      r = parseFloat(v1);\n    }\n    r = Math.min(Math.max(util.roundToPrecision(r, OCT), 0), MAX_RGB);\n  }\n  if (v2 === constant.NONE) {\n    g = 0;\n  } else {\n    if (v2[0] === \".\") {\n      v2 = `0${v2}`;\n    }\n    if (v2.endsWith(\"%\")) {\n      g = parseFloat(v2) * MAX_RGB / MAX_PCT;\n    } else {\n      g = parseFloat(v2);\n    }\n    g = Math.min(Math.max(util.roundToPrecision(g, OCT), 0), MAX_RGB);\n  }\n  if (v3 === constant.NONE) {\n    b = 0;\n  } else {\n    if (v3[0] === \".\") {\n      v3 = `0${v3}`;\n    }\n    if (v3.endsWith(\"%\")) {\n      b = parseFloat(v3) * MAX_RGB / MAX_PCT;\n    } else {\n      b = parseFloat(v3);\n    }\n    b = Math.min(Math.max(util.roundToPrecision(b, OCT), 0), MAX_RGB);\n  }\n  const alpha = parseAlpha(v4);\n  return [\"rgb\", r, g, b, format === VAL_MIX && v4 === constant.NONE ? constant.NONE : alpha];\n};\nconst parseHsl = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_HSL.test(value)) {\n    switch (format) {\n      case \"hsl\":\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const [, val] = value.match(REG_HSL);\n  let [h, s, l, alpha] = val.replace(/[,/]/g, \" \").split(/\\s+/);\n  if (h === constant.NONE) {\n    if (format !== \"hsl\") {\n      h = 0;\n    }\n  } else {\n    h = angleToDeg(h);\n  }\n  if (s === constant.NONE) {\n    if (format !== \"hsl\") {\n      s = 0;\n    }\n  } else {\n    if (s[0] === \".\") {\n      s = `0${s}`;\n    }\n    s = Math.min(Math.max(parseFloat(s), 0), MAX_PCT);\n  }\n  if (l === constant.NONE) {\n    if (format !== \"hsl\") {\n      l = 0;\n    }\n  } else {\n    if (l[0] === \".\") {\n      l = `0${l}`;\n    }\n    l = Math.min(Math.max(parseFloat(l), 0), MAX_PCT);\n  }\n  if (alpha !== constant.NONE || format !== \"hsl\") {\n    alpha = parseAlpha(alpha);\n  }\n  if (format === \"hsl\") {\n    return [format, h, s, l, alpha];\n  }\n  const ll = l / MAX_PCT;\n  const sa = s / MAX_PCT * Math.min(ll, 1 - ll);\n  const rk = h / DEG * DOZ % DOZ;\n  const gk = (8 + h / DEG * DOZ) % DOZ;\n  const bk = (4 + h / DEG * DOZ) % DOZ;\n  const r = ll - sa * Math.max(-1, Math.min(rk - TRIA, TRIA ** POW_SQR - rk, 1));\n  const g = ll - sa * Math.max(-1, Math.min(gk - TRIA, TRIA ** POW_SQR - gk, 1));\n  const b = ll - sa * Math.max(-1, Math.min(bk - TRIA, TRIA ** POW_SQR - bk, 1));\n  return [\n    \"rgb\",\n    Math.min(Math.max(util.roundToPrecision(r * MAX_RGB, OCT), 0), MAX_RGB),\n    Math.min(Math.max(util.roundToPrecision(g * MAX_RGB, OCT), 0), MAX_RGB),\n    Math.min(Math.max(util.roundToPrecision(b * MAX_RGB, OCT), 0), MAX_RGB),\n    alpha\n  ];\n};\nconst parseHwb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_HWB.test(value)) {\n    switch (format) {\n      case \"hwb\":\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const [, val] = value.match(REG_HWB);\n  let [h, w, b, alpha] = val.replace(\"/\", \" \").split(/\\s+/);\n  if (h === constant.NONE) {\n    if (format !== \"hwb\") {\n      h = 0;\n    }\n  } else {\n    h = angleToDeg(h);\n  }\n  if (w === constant.NONE) {\n    if (format !== \"hwb\") {\n      w = 0;\n    }\n  } else {\n    if (w[0] === \".\") {\n      w = `0${w}`;\n    }\n    w = Math.min(Math.max(parseFloat(w), 0), MAX_PCT) / MAX_PCT;\n  }\n  if (b === constant.NONE) {\n    if (format !== \"hwb\") {\n      b = 0;\n    }\n  } else {\n    if (b[0] === \".\") {\n      b = `0${b}`;\n    }\n    b = Math.min(Math.max(parseFloat(b), 0), MAX_PCT) / MAX_PCT;\n  }\n  if (alpha !== constant.NONE || format !== \"hwb\") {\n    alpha = parseAlpha(alpha);\n  }\n  if (format === \"hwb\") {\n    return [\n      format,\n      h,\n      w === constant.NONE ? w : w * MAX_PCT,\n      b === constant.NONE ? b : b * MAX_PCT,\n      alpha\n    ];\n  }\n  if (w + b >= 1) {\n    const v = util.roundToPrecision(\n      w / (w + b) * MAX_RGB,\n      OCT\n    );\n    return [\"rgb\", v, v, v, alpha];\n  }\n  const factor = (1 - w - b) / MAX_RGB;\n  let [, rr, gg, bb] = parseHsl(`hsl(${h} 100 50)`);\n  rr = util.roundToPrecision(\n    (rr * factor + w) * MAX_RGB,\n    OCT\n  );\n  gg = util.roundToPrecision(\n    (gg * factor + w) * MAX_RGB,\n    OCT\n  );\n  bb = util.roundToPrecision(\n    (bb * factor + w) * MAX_RGB,\n    OCT\n  );\n  return [\n    \"rgb\",\n    Math.min(Math.max(rr, 0), MAX_RGB),\n    Math.min(Math.max(gg, 0), MAX_RGB),\n    Math.min(Math.max(bb, 0), MAX_RGB),\n    alpha\n  ];\n};\nconst parseLab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_LAB.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const COEF_PCT = 1.25;\n  const COND_POW = 8;\n  const [, val] = value.match(REG_LAB);\n  let [l, a, b, alpha] = val.replace(\"/\", \" \").split(/\\s+/);\n  if (l === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      l = 0;\n    }\n  } else {\n    if (l[0] === \".\") {\n      l = `0${l}`;\n    }\n    if (l.endsWith(\"%\")) {\n      l = parseFloat(l);\n      if (l > MAX_PCT) {\n        l = MAX_PCT;\n      }\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (a === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      a = 0;\n    }\n  } else {\n    if (a[0] === \".\") {\n      a = `0${a}`;\n    }\n    if (a.endsWith(\"%\")) {\n      a = parseFloat(a) * COEF_PCT;\n    } else {\n      a = parseFloat(a);\n    }\n  }\n  if (b === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      b = 0;\n    }\n  } else {\n    if (b.endsWith(\"%\")) {\n      b = parseFloat(b) * COEF_PCT;\n    } else {\n      b = parseFloat(b);\n    }\n  }\n  if (alpha !== constant.NONE || !REG_SPEC.test(format)) {\n    alpha = parseAlpha(alpha);\n  }\n  if (REG_SPEC.test(format)) {\n    return [\n      \"lab\",\n      l === constant.NONE ? l : util.roundToPrecision(l, HEX),\n      a === constant.NONE ? a : util.roundToPrecision(a, HEX),\n      b === constant.NONE ? b : util.roundToPrecision(b, HEX),\n      alpha\n    ];\n  }\n  const fl = (l + HEX) / LAB_L;\n  const fa = a / LAB_A + fl;\n  const fb = fl - b / LAB_B;\n  const powFl = Math.pow(fl, POW_CUBE);\n  const powFa = Math.pow(fa, POW_CUBE);\n  const powFb = Math.pow(fb, POW_CUBE);\n  const xyz = [\n    powFa > LAB_EPSILON ? powFa : (fa * LAB_L - HEX) / LAB_KAPPA,\n    l > COND_POW ? powFl : l / LAB_KAPPA,\n    powFb > LAB_EPSILON ? powFb : (fb * LAB_L - HEX) / LAB_KAPPA\n  ];\n  const [x, y, z] = xyz.map((val2, i) => val2 * D50[i]);\n  return [\n    \"xyz-d50\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    alpha\n  ];\n};\nconst parseLch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_LCH.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const COEF_PCT = 1.5;\n  const [, val] = value.match(REG_LCH);\n  let [l, c, h, alpha] = val.replace(\"/\", \" \").split(/\\s+/);\n  if (l === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      l = 0;\n    }\n  } else {\n    if (l[0] === \".\") {\n      l = `0${l}`;\n    }\n    l = parseFloat(l);\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (c === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      c = 0;\n    }\n  } else {\n    if (c[0] === \".\") {\n      c = `0${c}`;\n    }\n    if (c.endsWith(\"%\")) {\n      c = parseFloat(c) * COEF_PCT;\n    } else {\n      c = parseFloat(c);\n    }\n  }\n  if (h === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      h = 0;\n    }\n  } else {\n    h = angleToDeg(h);\n  }\n  if (alpha !== constant.NONE || !REG_SPEC.test(format)) {\n    alpha = parseAlpha(alpha);\n  }\n  if (REG_SPEC.test(format)) {\n    return [\n      \"lch\",\n      l === constant.NONE ? l : util.roundToPrecision(l, HEX),\n      c === constant.NONE ? c : util.roundToPrecision(c, HEX),\n      h === constant.NONE ? h : util.roundToPrecision(h, HEX),\n      alpha\n    ];\n  }\n  const a = c * Math.cos(h * Math.PI / (DEG * HALF));\n  const b = c * Math.sin(h * Math.PI / (DEG * HALF));\n  const [, x, y, z] = parseLab(`lab(${l} ${a} ${b})`);\n  return [\n    \"xyz-d50\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    alpha\n  ];\n};\nconst parseOklab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_OKLAB.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(REG_OKLAB);\n  let [l, a, b, alpha] = val.replace(\"/\", \" \").split(/\\s+/);\n  if (l === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      l = 0;\n    }\n  } else {\n    if (l[0] === \".\") {\n      l = `0${l}`;\n    }\n    if (l.endsWith(\"%\")) {\n      l = parseFloat(l) / MAX_PCT;\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (a === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      a = 0;\n    }\n  } else {\n    if (a[0] === \".\") {\n      a = `0${a}`;\n    }\n    if (a.endsWith(\"%\")) {\n      a = parseFloat(a) * COEF_PCT / MAX_PCT;\n    } else {\n      a = parseFloat(a);\n    }\n  }\n  if (b === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      b = 0;\n    }\n  } else {\n    if (b.endsWith(\"%\")) {\n      b = parseFloat(b) * COEF_PCT / MAX_PCT;\n    } else {\n      b = parseFloat(b);\n    }\n  }\n  if (alpha !== constant.NONE || !REG_SPEC.test(format)) {\n    alpha = parseAlpha(alpha);\n  }\n  if (REG_SPEC.test(format)) {\n    return [\n      \"oklab\",\n      l === constant.NONE ? l : util.roundToPrecision(l, HEX),\n      a === constant.NONE ? a : util.roundToPrecision(a, HEX),\n      b === constant.NONE ? b : util.roundToPrecision(b, HEX),\n      alpha\n    ];\n  }\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [\n    l,\n    a,\n    b\n  ]);\n  const xyzLms = lms.map((c) => Math.pow(c, POW_CUBE));\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms, true);\n  return [\n    \"xyz-d65\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    alpha\n  ];\n};\nconst parseOklch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  if (!REG_OKLCH.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(REG_OKLCH);\n  let [l, c, h, alpha] = val.replace(\"/\", \" \").split(/\\s+/);\n  if (l === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      l = 0;\n    }\n  } else {\n    if (l[0] === \".\") {\n      l = `0${l}`;\n    }\n    if (l.endsWith(\"%\")) {\n      l = parseFloat(l) / MAX_PCT;\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (c === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      c = 0;\n    }\n  } else {\n    if (c[0] === \".\") {\n      c = `0${c}`;\n    }\n    if (c.endsWith(\"%\")) {\n      c = parseFloat(c) * COEF_PCT / MAX_PCT;\n    } else {\n      c = parseFloat(c);\n    }\n    if (c < 0) {\n      c = 0;\n    }\n  }\n  if (h === constant.NONE) {\n    if (!REG_SPEC.test(format)) {\n      h = 0;\n    }\n  } else {\n    h = angleToDeg(h);\n  }\n  if (alpha !== constant.NONE || !REG_SPEC.test(format)) {\n    alpha = parseAlpha(alpha);\n  }\n  if (REG_SPEC.test(format)) {\n    return [\n      \"oklch\",\n      l === constant.NONE ? l : util.roundToPrecision(l, HEX),\n      c === constant.NONE ? c : util.roundToPrecision(c, HEX),\n      h === constant.NONE ? h : util.roundToPrecision(h, HEX),\n      alpha\n    ];\n  }\n  const a = c * Math.cos(h * Math.PI / (DEG * HALF));\n  const b = c * Math.sin(h * Math.PI / (DEG * HALF));\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [l, a, b]);\n  const xyzLms = lms.map((cl) => Math.pow(cl, POW_CUBE));\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms, true);\n  return [\n    \"xyz-d65\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    alpha\n  ];\n};\nconst parseColorFunc = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace, d50, format } = opt;\n  if (!REG_FN_COLOR.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const [, val] = value.match(REG_FN_COLOR);\n  let [cs, v1, v2, v3, v4] = val.replace(\"/\", \" \").split(/\\s+/);\n  let r, g, b;\n  if (cs === \"xyz\") {\n    cs = \"xyz-d65\";\n  }\n  if (v1 === constant.NONE) {\n    r = 0;\n  } else {\n    if (v1[0] === \".\") {\n      v1 = `0${v1}`;\n    }\n    r = v1.endsWith(\"%\") ? parseFloat(v1) / MAX_PCT : parseFloat(v1);\n  }\n  if (v2 === constant.NONE) {\n    g = 0;\n  } else {\n    if (v2[0] === \".\") {\n      v2 = `0${v2}`;\n    }\n    g = v2.endsWith(\"%\") ? parseFloat(v2) / MAX_PCT : parseFloat(v2);\n  }\n  if (v3 === constant.NONE) {\n    b = 0;\n  } else {\n    if (v3[0] === \".\") {\n      v3 = `0${v3}`;\n    }\n    b = v3.endsWith(\"%\") ? parseFloat(v3) / MAX_PCT : parseFloat(v3);\n  }\n  const alpha = parseAlpha(v4);\n  if (REG_SPEC.test(format) || format === VAL_MIX && cs === colorSpace) {\n    return [\n      cs,\n      v1 === constant.NONE ? constant.NONE : util.roundToPrecision(r, DEC),\n      v2 === constant.NONE ? constant.NONE : util.roundToPrecision(g, DEC),\n      v3 === constant.NONE ? constant.NONE : util.roundToPrecision(b, DEC),\n      v4 === constant.NONE ? constant.NONE : alpha\n    ];\n  }\n  let x, y, z;\n  if (cs === \"srgb\") {\n    [x, y, z] = convertRgbToXyz([r * MAX_RGB, g * MAX_RGB, b * MAX_RGB]);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (cs === \"srgb-linear\") {\n    [x, y, z] = transformMatrix(MATRIX_L_RGB_TO_XYZ, [r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (cs === \"display-p3\") {\n    const linearRgb = convertRgbToLinearRgb([\n      r * MAX_RGB,\n      g * MAX_RGB,\n      b * MAX_RGB\n    ]);\n    [x, y, z] = transformMatrix(MATRIX_P3_TO_XYZ, linearRgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (cs === \"rec2020\") {\n    const ALPHA = 1.09929682680944;\n    const BETA = 0.018053968510807;\n    const REC_COEF = 0.45;\n    const rgb = [r, g, b].map((c) => {\n      let cl;\n      if (c < BETA * REC_COEF * DEC) {\n        cl = c / (REC_COEF * DEC);\n      } else {\n        cl = Math.pow((c + ALPHA - 1) / ALPHA, 1 / REC_COEF);\n      }\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_REC2020_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (cs === \"a98-rgb\") {\n    const POW_A98 = 563 / 256;\n    const rgb = [r, g, b].map((c) => {\n      const cl = Math.pow(c, POW_A98);\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_A98_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (cs === \"prophoto-rgb\") {\n    const POW_PROPHOTO = 1.8;\n    const rgb = [r, g, b].map((c) => {\n      let cl;\n      if (c > 1 / (HEX * DUO)) {\n        cl = Math.pow(c, POW_PROPHOTO);\n      } else {\n        cl = c / HEX;\n      }\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_PROPHOTO_TO_XYZ_D50, rgb);\n    if (!d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D50_TO_D65,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (/^xyz(?:-d(?:50|65))?$/.test(cs)) {\n    [x, y, z] = [r, g, b];\n    if (cs === \"xyz-d50\") {\n      if (!d50) {\n        [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n      }\n    } else if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z], true);\n    }\n  }\n  return [\n    d50 ? \"xyz-d50\" : \"xyz-d65\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    format === VAL_MIX && v4 === constant.NONE ? constant.NONE : alpha\n  ];\n};\nconst parseColorValue = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { d50, format } = opt;\n  if (!REG_COLOR.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  let x, y, z, alpha;\n  if (REG_CURRENT.test(value)) {\n    if (format === constant.VAL_COMP) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    if (format === constant.VAL_SPEC) {\n      return value;\n    }\n    x = 0;\n    y = 0;\n    z = 0;\n    alpha = 0;\n  } else if (/^[a-z]+$/.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      if (format === constant.VAL_SPEC) {\n        return value;\n      }\n      const [r, g, b] = NAMED_COLORS[value];\n      alpha = 1;\n      if (format === constant.VAL_COMP) {\n        return [\"rgb\", r, g, b, alpha];\n      }\n      [x, y, z] = convertRgbToXyz([r, g, b], true);\n      if (d50) {\n        [x, y, z] = transformMatrix(\n          MATRIX_D65_TO_D50,\n          [x, y, z],\n          true\n        );\n      }\n    } else {\n      if (format === constant.VAL_COMP) {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n      if (format === constant.VAL_SPEC) {\n        if (value === \"transparent\") {\n          return value;\n        }\n        return \"\";\n      }\n      if (format === VAL_MIX) {\n        if (value === \"transparent\") {\n          return [\"rgb\", 0, 0, 0, 0];\n        }\n        return null;\n      }\n      x = 0;\n      y = 0;\n      z = 0;\n      alpha = 0;\n    }\n  } else if (value[0] === \"#\") {\n    if (REG_SPEC.test(format)) {\n      const rgb = convertHexToRgb(value);\n      return [\"rgb\", ...rgb];\n    }\n    [x, y, z, alpha] = convertHexToXyz(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (value.startsWith(\"lab\")) {\n    if (REG_SPEC.test(format)) {\n      return parseLab(value, opt);\n    }\n    [, x, y, z, alpha] = parseLab(value);\n    if (!d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D50_TO_D65,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (value.startsWith(\"lch\")) {\n    if (REG_SPEC.test(format)) {\n      return parseLch(value, opt);\n    }\n    [, x, y, z, alpha] = parseLch(value);\n    if (!d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D50_TO_D65,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (value.startsWith(\"oklab\")) {\n    if (REG_SPEC.test(format)) {\n      return parseOklab(value, opt);\n    }\n    [, x, y, z, alpha] = parseOklab(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else if (value.startsWith(\"oklch\")) {\n    if (REG_SPEC.test(format)) {\n      return parseOklch(value, opt);\n    }\n    [, x, y, z, alpha] = parseOklch(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  } else {\n    let r, g, b;\n    if (value.startsWith(\"hsl\")) {\n      [, r, g, b, alpha] = parseHsl(value);\n    } else if (value.startsWith(\"hwb\")) {\n      [, r, g, b, alpha] = parseHwb(value);\n    } else {\n      [, r, g, b, alpha] = parseRgb(value, opt);\n    }\n    if (REG_SPEC.test(format)) {\n      return [\n        \"rgb\",\n        Math.round(r),\n        Math.round(g),\n        Math.round(b),\n        alpha\n      ];\n    }\n    [x, y, z] = convertRgbToXyz([r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(\n        MATRIX_D65_TO_D50,\n        [x, y, z],\n        true\n      );\n    }\n  }\n  return [\n    d50 ? \"xyz-d50\" : \"xyz-d65\",\n    util.roundToPrecision(x, HEX),\n    util.roundToPrecision(y, HEX),\n    util.roundToPrecision(z, HEX),\n    alpha\n  ];\n};\nconst resolveColorValue = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace, format } = opt;\n  if (!REG_COLOR.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  let cs, r, g, b, alpha;\n  if (REG_CURRENT.test(value)) {\n    if (format === constant.VAL_SPEC) {\n      return value;\n    }\n    r = 0;\n    g = 0;\n    b = 0;\n    alpha = 0;\n  } else if (/^[a-z]+$/.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      if (format === constant.VAL_SPEC) {\n        return value;\n      }\n      [r, g, b] = NAMED_COLORS[value];\n      alpha = 1;\n    } else {\n      if (format === constant.VAL_SPEC) {\n        if (value === \"transparent\") {\n          return value;\n        }\n        return \"\";\n      }\n      if (format === VAL_MIX) {\n        if (value === \"transparent\") {\n          return [\"rgb\", 0, 0, 0, 0];\n        }\n        return null;\n      }\n      r = 0;\n      g = 0;\n      b = 0;\n      alpha = 0;\n    }\n  } else if (value[0] === \"#\") {\n    [r, g, b, alpha] = convertHexToRgb(value);\n  } else if (value.startsWith(\"rgb\")) {\n    [, r, g, b, alpha] = parseRgb(value, opt);\n  } else if (value.startsWith(\"hsl\")) {\n    [, r, g, b, alpha] = parseHsl(value, opt);\n  } else if (value.startsWith(\"hwb\")) {\n    [, r, g, b, alpha] = parseHwb(value, opt);\n  } else if (/^l(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith(\"lab\")) {\n      [cs, x, y, z, alpha] = parseLab(value, opt);\n    } else {\n      [cs, x, y, z, alpha] = parseLch(value, opt);\n    }\n    if (REG_SPEC.test(format)) {\n      return [cs, x, y, z, alpha];\n    }\n    [r, g, b, alpha] = convertXyzD50ToRgb([\n      x,\n      y,\n      z,\n      alpha\n    ]);\n  } else if (/^okl(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith(\"oklab\")) {\n      [cs, x, y, z, alpha] = parseOklab(value, opt);\n    } else {\n      [cs, x, y, z, alpha] = parseOklch(value, opt);\n    }\n    if (REG_SPEC.test(format)) {\n      return [cs, x, y, z, alpha];\n    }\n    [r, g, b, alpha] = convertXyzToRgb([\n      x,\n      y,\n      z,\n      alpha\n    ]);\n  }\n  if (format === VAL_MIX && colorSpace === \"srgb\") {\n    return [\n      \"srgb\",\n      r / MAX_RGB,\n      g / MAX_RGB,\n      b / MAX_RGB,\n      alpha\n    ];\n  }\n  return [\n    \"rgb\",\n    Math.round(r),\n    Math.round(g),\n    Math.round(b),\n    alpha\n  ];\n};\nconst resolveColorFunc = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace, format } = opt;\n  if (!REG_FN_COLOR.test(value)) {\n    switch (format) {\n      case VAL_MIX: {\n        return null;\n      }\n      case constant.VAL_SPEC: {\n        return \"\";\n      }\n      default: {\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    }\n  }\n  const [cs, x, y, z, alpha] = parseColorFunc(value, opt);\n  if (REG_SPEC.test(format) || format === VAL_MIX && cs === colorSpace) {\n    return [cs, x, y, z, alpha];\n  }\n  const [r, g, b] = convertXyzToRgb([\n    x,\n    y,\n    z\n  ], true);\n  return [\"rgb\", r, g, b, alpha];\n};\nconst convertColorToLinearRgb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { colorSpace, format } = opt;\n  let cs, r, g, b, alpha, x, y, z;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [cs, x, y, z, alpha] = xyz;\n    if (cs === colorSpace) {\n      return [x, y, z, alpha];\n    }\n    [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR);\n    const [cs2] = val.replace(\"/\", \" \").split(/\\s+/);\n    if (cs2 === \"srgb-linear\") {\n      [, r, g, b, alpha] = resolveColorFunc(value, {\n        format: constant.VAL_COMP\n      });\n    } else {\n      [, x, y, z, alpha] = parseColorFunc(value);\n      [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n    }\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value);\n    [r, g, b] = transformMatrix(MATRIX_XYZ_TO_L_RGB, [x, y, z], true);\n  }\n  return [\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1),\n    alpha\n  ];\n};\nconst convertColorToRgb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let r, g, b, alpha;\n  if (format === VAL_MIX) {\n    let rgb;\n    if (value.startsWith(constant.FN_COLOR)) {\n      rgb = resolveColorFunc(value, opt);\n    } else {\n      rgb = resolveColorValue(value, opt);\n    }\n    if (rgb === null) {\n      return rgb;\n    }\n    [, r, g, b, alpha] = rgb;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR);\n    const [cs] = val.replace(\"/\", \" \").split(/\\s+/);\n    if (cs === \"srgb\") {\n      [, r, g, b, alpha] = resolveColorFunc(value, {\n        format: constant.VAL_COMP\n      });\n      r *= MAX_RGB;\n      g *= MAX_RGB;\n      b *= MAX_RGB;\n    } else {\n      [, r, g, b, alpha] = resolveColorFunc(value);\n    }\n  } else if (/^(?:ok)?l(?:ab|ch)/.test(value)) {\n    [r, g, b, alpha] = convertColorToLinearRgb(value);\n    [r, g, b] = convertLinearRgbToRgb([r, g, b]);\n  } else {\n    [, r, g, b, alpha] = resolveColorValue(value, {\n      format: constant.VAL_COMP\n    });\n  }\n  return [r, g, b, alpha];\n};\nconst convertColorToXyz = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { d50, format } = opt;\n  let x, y, z, alpha;\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    const [, val] = value.match(REG_FN_COLOR);\n    const [cs] = val.replace(\"/\", \" \").split(/\\s+/);\n    if (d50) {\n      if (cs === \"xyz-d50\") {\n        [, x, y, z, alpha] = resolveColorFunc(value, {\n          format: constant.VAL_COMP\n        });\n      } else {\n        [, x, y, z, alpha] = parseColorFunc(value, opt);\n      }\n    } else if (/^xyz(?:-d65)?$/.test(cs)) {\n      [, x, y, z, alpha] = resolveColorFunc(value, {\n        format: constant.VAL_COMP\n      });\n    } else {\n      [, x, y, z, alpha] = parseColorFunc(value);\n    }\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, opt);\n  }\n  return [x, y, z, alpha];\n};\nconst convertColorToHsl = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let h, s, l, alpha, x, y, z;\n  if (REG_HSL.test(value)) {\n    [, h, s, l, alpha] = parseHsl(value, {\n      format: \"hsl\"\n    });\n    if (format === \"hsl\") {\n      return [\n        Math.round(h),\n        Math.round(s),\n        Math.round(l),\n        alpha\n      ];\n    }\n    return [h, s, l, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value);\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value);\n  }\n  [h, s, l] = convertXyzToHsl([x, y, z], true);\n  if (format === \"hsl\") {\n    return [Math.round(h), Math.round(s), Math.round(l), alpha];\n  }\n  return [h, s, l, alpha];\n};\nconst convertColorToHwb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let h, w, b, alpha, x, y, z;\n  if (REG_HWB.test(value)) {\n    [, h, w, b, alpha] = parseHwb(value, {\n      format: \"hwb\"\n    });\n    if (format === \"hwb\") {\n      return [Math.round(h), Math.round(w), Math.round(b), alpha];\n    }\n    return [h, w, b, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value);\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value);\n  }\n  [h, w, b] = convertXyzToHwb([x, y, z], true);\n  if (format === \"hwb\") {\n    return [Math.round(h), Math.round(w), Math.round(b), alpha];\n  }\n  return [h, w, b, alpha];\n};\nconst convertColorToLab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let l, a, b, alpha, x, y, z;\n  if (REG_LAB.test(value)) {\n    [, l, a, b, alpha] = parseLab(value, {\n      format: constant.VAL_COMP\n    });\n    return [l, a, b, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    opt.d50 = true;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value, {\n      d50: true\n    });\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, {\n      d50: true\n    });\n  }\n  [l, a, b] = convertXyzD50ToLab([x, y, z], true);\n  return [l, a, b, alpha];\n};\nconst convertColorToLch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let l, c, h, alpha, x, y, z;\n  if (REG_LCH.test(value)) {\n    [, l, c, h, alpha] = parseLch(value, {\n      format: constant.VAL_COMP\n    });\n    return [l, c, h, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    opt.d50 = true;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value, {\n      d50: true\n    });\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value, {\n      d50: true\n    });\n  }\n  [l, c, h] = convertXyzD50ToLch([x, y, z], true);\n  return [l, c, h, alpha];\n};\nconst convertColorToOklab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let l, a, b, alpha, x, y, z;\n  if (REG_OKLAB.test(value)) {\n    [, l, a, b, alpha] = parseOklab(value, {\n      format: constant.VAL_COMP\n    });\n    return [l, a, b, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value);\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value);\n  }\n  [l, a, b] = convertXyzToOklab([x, y, z], true);\n  return [l, a, b, alpha];\n};\nconst convertColorToOklch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  let l, c, h, alpha, x, y, z;\n  if (REG_OKLCH.test(value)) {\n    [, l, c, h, alpha] = parseOklch(value, {\n      format: constant.VAL_COMP\n    });\n    return [l, c, h, alpha];\n  }\n  if (format === VAL_MIX) {\n    let xyz;\n    if (value.startsWith(constant.FN_COLOR)) {\n      xyz = parseColorFunc(value, opt);\n    } else {\n      xyz = parseColorValue(value, opt);\n    }\n    if (xyz === null) {\n      return xyz;\n    }\n    [, x, y, z, alpha] = xyz;\n  } else if (value.startsWith(constant.FN_COLOR)) {\n    [, x, y, z, alpha] = parseColorFunc(value);\n  } else {\n    [, x, y, z, alpha] = parseColorValue(value);\n  }\n  [l, c, h] = convertXyzToOklch([x, y, z], true);\n  return [l, c, h, alpha];\n};\nconst resolveColorMix = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { format } = opt;\n  const nestedItems = [];\n  if (!REG_MIX.test(value)) {\n    if (value.startsWith(constant.FN_MIX) && REG_MIX_NEST.test(value)) {\n      const regColorSpace = new RegExp(`^(?:${constant.CS_RGB}|${constant.CS_XYZ})$`);\n      const items = value.match(REG_MIX_NEST);\n      for (const item of items) {\n        let val = resolveColorMix(item, {\n          format: format === constant.VAL_SPEC ? format : constant.VAL_COMP\n        });\n        if (Array.isArray(val)) {\n          const [v1, v2, v3, v4, v5] = val;\n          if (v2 === 0 && v3 === 0 && v4 === 0 && v5 === 0) {\n            value = \"\";\n            break;\n          }\n          if (regColorSpace.test(v1)) {\n            if (v5 === 1) {\n              val = `color(${v1} ${v2} ${v3} ${v4})`;\n            } else {\n              val = `color(${v1} ${v2} ${v3} ${v4} / ${v5})`;\n            }\n          } else if (v5 === 1) {\n            val = `${v1}(${v2} ${v3} ${v4})`;\n          } else {\n            val = `${v1}(${v2} ${v3} ${v4} / ${v5})`;\n          }\n        } else if (!REG_MIX.test(val)) {\n          value = \"\";\n          break;\n        }\n        nestedItems.push(val);\n        value = value.replace(item, val);\n      }\n      if (!value) {\n        if (format === constant.VAL_SPEC) {\n          return \"\";\n        }\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n    } else if (format === constant.VAL_SPEC) {\n      return \"\";\n    } else {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n  }\n  let colorSpace, hueArc, colorA, pctA, colorB, pctB;\n  if (nestedItems.length && format === constant.VAL_SPEC) {\n    const regColorSpace = new RegExp(`^color-mix\\\\(\\\\s*in\\\\s+(${constant.CS_MIX})\\\\s*,`);\n    const [, cs] = value.match(regColorSpace);\n    if (REG_CS_HUE.test(cs)) {\n      [, colorSpace, hueArc] = cs.match(REG_CS_HUE);\n    } else {\n      colorSpace = cs;\n    }\n    if (nestedItems.length === 2) {\n      const itemA = nestedItems[0].replace(/(?=[()])/g, \"\\\\\");\n      const regA = new RegExp(`(${itemA})(?:\\\\s+(${constant.PCT}))?`);\n      [, colorA, pctA] = value.match(regA);\n      const itemB = nestedItems[1].replace(/(?=[()])/g, \"\\\\\");\n      const regB = new RegExp(`(${itemB})(?:\\\\s+(${constant.PCT}))?`);\n      [, colorB, pctB] = value.match(regB);\n    } else {\n      const colorPart = `(?:${constant.SYN_COLOR_TYPE})(?:\\\\s+${constant.PCT})?`;\n      const item = nestedItems[0].replace(/(?=[()])/g, \"\\\\\");\n      const itemPart = `${item}(?:\\\\s+${constant.PCT})?`;\n      const itemPartCapt = `(${item})(?:\\\\s+(${constant.PCT}))?`;\n      const regColorPart = new RegExp(`^(${constant.SYN_COLOR_TYPE})(?:\\\\s+(${constant.PCT}))?$`);\n      const regItemPart = new RegExp(`^${itemPartCapt}$`);\n      const regPosition = new RegExp(`${itemPartCapt}\\\\s*\\\\)$`);\n      if (regPosition.test(value)) {\n        const reg = new RegExp(`(${colorPart})\\\\s*,\\\\s*(${itemPart})\\\\s*\\\\)$`);\n        const [, colorPartA, colorPartB] = value.match(reg);\n        [, colorA, pctA] = colorPartA.match(regColorPart);\n        [, colorB, pctB] = colorPartB.match(regItemPart);\n      } else {\n        const reg = new RegExp(`(${itemPart})\\\\s*,\\\\s*(${colorPart})\\\\s*\\\\)$`);\n        const [, colorPartA, colorPartB] = value.match(reg);\n        [, colorA, pctA] = colorPartA.match(regItemPart);\n        [, colorB, pctB] = colorPartB.match(regColorPart);\n      }\n    }\n  } else {\n    const [, cs, colorPartA, colorPartB] = value.match(REG_MIX_CAPT);\n    const reg = new RegExp(`^(${constant.SYN_COLOR_TYPE})(?:\\\\s+(${constant.PCT}))?$`);\n    [, colorA, pctA] = colorPartA.match(reg);\n    [, colorB, pctB] = colorPartB.match(reg);\n    if (REG_CS_HUE.test(cs)) {\n      [, colorSpace, hueArc] = REG_CS_HUE.exec(cs);\n    } else {\n      colorSpace = cs;\n    }\n  }\n  let pA, pB, m;\n  if (pctA && pctB) {\n    const p1 = parseFloat(pctA) / MAX_PCT;\n    const p2 = parseFloat(pctB) / MAX_PCT;\n    if (p1 < 0 || p1 > 1 || p2 < 0 || p2 > 1) {\n      if (format === constant.VAL_SPEC) {\n        return \"\";\n      }\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    const factor = p1 + p2;\n    if (factor === 0) {\n      if (format === constant.VAL_SPEC) {\n        return \"\";\n      }\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    pA = p1 / factor;\n    pB = p2 / factor;\n    m = factor < 1 ? factor : 1;\n  } else {\n    if (pctA) {\n      pA = parseFloat(pctA) / MAX_PCT;\n      if (pA < 0 || pA > 1) {\n        if (format === constant.VAL_SPEC) {\n          return \"\";\n        }\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n      pB = 1 - pA;\n    } else if (pctB) {\n      pB = parseFloat(pctB) / MAX_PCT;\n      if (pB < 0 || pB > 1) {\n        if (format === constant.VAL_SPEC) {\n          return \"\";\n        }\n        return [\"rgb\", 0, 0, 0, 0];\n      }\n      pA = 1 - pB;\n    } else {\n      pA = HALF;\n      pB = HALF;\n    }\n    m = 1;\n  }\n  if (colorSpace === \"xyz\") {\n    colorSpace = \"xyz-d65\";\n  }\n  if (format === constant.VAL_SPEC) {\n    let valueA, valueB;\n    if (colorA.startsWith(constant.FN_MIX)) {\n      valueA = colorA;\n    } else if (colorA.startsWith(constant.FN_COLOR)) {\n      valueA = parseColorFunc(colorA, opt);\n      if (Array.isArray(valueA)) {\n        const [v1, v2, v3, v4, v5] = [...valueA];\n        if (v5 === 1) {\n          valueA = `color(${v1} ${v2} ${v3} ${v4})`;\n        } else {\n          valueA = `color(${v1} ${v2} ${v3} ${v4} / ${v5})`;\n        }\n      }\n    } else {\n      valueA = parseColorValue(colorA, opt);\n      if (valueA === \"\") {\n        return valueA;\n      }\n      if (Array.isArray(valueA)) {\n        const [v1, v2, v3, v4, v5] = [...valueA];\n        if (v5 === 1) {\n          if (v1 === \"rgb\") {\n            valueA = `${v1}(${v2}, ${v3}, ${v4})`;\n          } else {\n            valueA = `${v1}(${v2} ${v3} ${v4})`;\n          }\n        } else if (v1 === \"rgb\") {\n          valueA = `${v1}a(${v2}, ${v3}, ${v4}, ${v5})`;\n        } else {\n          valueA = `${v1}(${v2} ${v3} ${v4} / ${v5})`;\n        }\n      }\n    }\n    if (colorB.startsWith(constant.FN_MIX)) {\n      valueB = colorB;\n    } else if (colorB.startsWith(constant.FN_COLOR)) {\n      valueB = parseColorFunc(colorB, opt);\n      if (Array.isArray(valueB)) {\n        const [v1, v2, v3, v4, v5] = [...valueB];\n        if (v5 === 1) {\n          valueB = `color(${v1} ${v2} ${v3} ${v4})`;\n        } else {\n          valueB = `color(${v1} ${v2} ${v3} ${v4} / ${v5})`;\n        }\n      }\n    } else {\n      valueB = parseColorValue(colorB, opt);\n      if (valueB === \"\") {\n        return valueB;\n      }\n      if (Array.isArray(valueB)) {\n        const [v1, v2, v3, v4, v5] = [...valueB];\n        if (v5 === 1) {\n          if (v1 === \"rgb\") {\n            valueB = `${v1}(${v2}, ${v3}, ${v4})`;\n          } else {\n            valueB = `${v1}(${v2} ${v3} ${v4})`;\n          }\n        } else if (v1 === \"rgb\") {\n          valueB = `${v1}a(${v2}, ${v3}, ${v4}, ${v5})`;\n        } else {\n          valueB = `${v1}(${v2} ${v3} ${v4} / ${v5})`;\n        }\n      }\n    }\n    if (pctA && pctB) {\n      valueA += ` ${parseFloat(pctA)}%`;\n      valueB += ` ${parseFloat(pctB)}%`;\n    } else if (pctA) {\n      const pA2 = parseFloat(pctA);\n      if (pA2 !== MAX_PCT * HALF) {\n        valueA += ` ${pA2}%`;\n      }\n    } else if (pctB) {\n      const pA2 = MAX_PCT - parseFloat(pctB);\n      if (pA2 !== MAX_PCT * HALF) {\n        valueA += ` ${pA2}%`;\n      }\n    }\n    if (hueArc) {\n      return `color-mix(in ${colorSpace} ${hueArc} hue, ${valueA}, ${valueB})`;\n    } else {\n      return `color-mix(in ${colorSpace}, ${valueA}, ${valueB})`;\n    }\n  }\n  let r, g, b, alpha;\n  if (/^srgb(?:-linear)?$/.test(colorSpace)) {\n    let rgbA, rgbB;\n    if (colorSpace === \"srgb\") {\n      if (REG_CURRENT.test(colorA)) {\n        rgbA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        rgbA = convertColorToRgb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        rgbB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        rgbB = convertColorToRgb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        rgbA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        rgbA = convertColorToLinearRgb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        rgbB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        rgbB = convertColorToLinearRgb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (rgbA === null || rgbB === null) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    let [rA, gA, bA, alphaA] = rgbA;\n    let [rB, gB, bB, alphaB] = rgbB;\n    const rNone = rA === constant.NONE && rB === constant.NONE;\n    const gNone = gA === constant.NONE && gB === constant.NONE;\n    const bNone = bA === constant.NONE && bB === constant.NONE;\n    const alphaNone = alphaA === constant.NONE && alphaB === constant.NONE;\n    [[rA, gA, bA, alphaA], [rB, gB, bB, alphaB]] = normalizeColorComponents(\n      [rA, gA, bA, alphaA],\n      [rB, gB, bB, alphaB],\n      true\n    );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    if (alpha === 0) {\n      r = rA * pA + rB * pB;\n      g = gA * pA + gB * pB;\n      b = bA * pA + bB * pB;\n    } else {\n      r = (rA * factorA + rB * factorB) / alpha;\n      g = (gA * factorA + gB * factorB) / alpha;\n      b = (bA * factorA + bB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === constant.VAL_COMP) {\n      return [\n        colorSpace,\n        rNone ? constant.NONE : util.roundToPrecision(r, HEX),\n        gNone ? constant.NONE : util.roundToPrecision(g, HEX),\n        bNone ? constant.NONE : util.roundToPrecision(b, HEX),\n        alphaNone ? constant.NONE : alpha * m\n      ];\n    }\n    r *= MAX_RGB;\n    g *= MAX_RGB;\n    b *= MAX_RGB;\n  } else if (REG_CS_XYZ.test(colorSpace)) {\n    let xyzA, xyzB;\n    if (REG_CURRENT.test(colorA)) {\n      xyzA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n    } else {\n      xyzA = convertColorToXyz(colorA, {\n        colorSpace,\n        d50: colorSpace === \"xyz-d50\",\n        format: VAL_MIX\n      });\n    }\n    if (REG_CURRENT.test(colorB)) {\n      xyzB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n    } else {\n      xyzB = convertColorToXyz(colorB, {\n        colorSpace,\n        d50: colorSpace === \"xyz-d50\",\n        format: VAL_MIX\n      });\n    }\n    if (xyzA === null || xyzB === null) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    let [xA, yA, zA, alphaA] = xyzA;\n    let [xB, yB, zB, alphaB] = xyzB;\n    const xNone = xA === constant.NONE && xB === constant.NONE;\n    const yNone = yA === constant.NONE && yB === constant.NONE;\n    const zNone = zA === constant.NONE && zB === constant.NONE;\n    const alphaNone = alphaA === constant.NONE && alphaB === constant.NONE;\n    [[xA, yA, zA, alphaA], [xB, yB, zB, alphaB]] = normalizeColorComponents(\n      [xA, yA, zA, alphaA],\n      [xB, yB, zB, alphaB],\n      true\n    );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    let x, y, z;\n    if (alpha === 0) {\n      x = xA * pA + xB * pB;\n      y = yA * pA + yB * pB;\n      z = zA * pA + zB * pB;\n    } else {\n      x = (xA * factorA + xB * factorB) / alpha;\n      y = (yA * factorA + yB * factorB) / alpha;\n      z = (zA * factorA + zB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === constant.VAL_COMP) {\n      return [\n        colorSpace,\n        xNone ? constant.NONE : util.roundToPrecision(x, HEX),\n        yNone ? constant.NONE : util.roundToPrecision(y, HEX),\n        zNone ? constant.NONE : util.roundToPrecision(z, HEX),\n        alphaNone ? constant.NONE : alpha * m\n      ];\n    }\n    if (colorSpace === \"xyz-d50\") {\n      [r, g, b] = convertXyzD50ToRgb([x, y, z], true);\n    } else {\n      [r, g, b] = convertXyzToRgb([x, y, z], true);\n    }\n  } else if (/^h(?:sl|wb)$/.test(colorSpace)) {\n    let hslA, hslB;\n    if (colorSpace === \"hsl\") {\n      if (REG_CURRENT.test(colorA)) {\n        hslA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        hslA = convertColorToHsl(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        hslB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        hslB = convertColorToHsl(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        hslA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        hslA = convertColorToHwb(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        hslB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        hslB = convertColorToHwb(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (hslA === null || hslB === null) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    let [hA, sA, lA, alphaA] = hslA;\n    let [hB, sB, lB, alphaB] = hslB;\n    const alphaNone = alphaA === constant.NONE && alphaB === constant.NONE;\n    [[hA, sA, lA, alphaA], [hB, sB, lB, alphaB]] = normalizeColorComponents(\n      [hA, sA, lA, alphaA],\n      [hB, sB, lB, alphaB],\n      true\n    );\n    if (hueArc) {\n      [hA, hB] = util.interpolateHue(hA, hB, hueArc);\n    }\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    const h = (hA * pA + hB * pB) % DEG;\n    let s, l;\n    if (alpha === 0) {\n      s = sA * pA + sB * pB;\n      l = lA * pA + lB * pB;\n    } else {\n      s = (sA * factorA + sB * factorB) / alpha;\n      l = (lA * factorA + lB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    [r, g, b] = convertColorToRgb(`${colorSpace}(${h} ${s} ${l})`);\n    if (format === constant.VAL_COMP) {\n      return [\n        \"srgb\",\n        util.roundToPrecision(r / MAX_RGB, HEX),\n        util.roundToPrecision(g / MAX_RGB, HEX),\n        util.roundToPrecision(b / MAX_RGB, HEX),\n        alphaNone ? constant.NONE : alpha * m\n      ];\n    }\n  } else if (/^(?:ok)?lab$/.test(colorSpace)) {\n    let labA, labB;\n    if (colorSpace === \"lab\") {\n      if (REG_CURRENT.test(colorA)) {\n        labA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        labA = convertColorToLab(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        labB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        labB = convertColorToLab(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        labA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        labA = convertColorToOklab(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        labB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        labB = convertColorToOklab(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (labA === null || labB === null) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    let [lA, aA, bA, alphaA] = labA;\n    let [lB, aB, bB, alphaB] = labB;\n    const lNone = lA === constant.NONE && lB === constant.NONE;\n    const aNone = aA === constant.NONE && aB === constant.NONE;\n    const bNone = bA === constant.NONE && bB === constant.NONE;\n    const alphaNone = alphaA === constant.NONE && alphaB === constant.NONE;\n    [[lA, aA, bA, alphaA], [lB, aB, bB, alphaB]] = normalizeColorComponents(\n      [lA, aA, bA, alphaA],\n      [lB, aB, bB, alphaB],\n      true\n    );\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    let l, aO, bO;\n    if (alpha === 0) {\n      l = lA * pA + lB * pB;\n      aO = aA * pA + aB * pB;\n      bO = bA * pA + bB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) / alpha;\n      aO = (aA * factorA + aB * factorB) / alpha;\n      bO = (bA * factorA + bB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === constant.VAL_COMP) {\n      return [\n        colorSpace,\n        lNone ? constant.NONE : util.roundToPrecision(l, HEX),\n        aNone ? constant.NONE : util.roundToPrecision(aO, HEX),\n        bNone ? constant.NONE : util.roundToPrecision(bO, HEX),\n        alphaNone ? constant.NONE : alpha * m\n      ];\n    }\n    [, r, g, b] = resolveColorValue(`${colorSpace}(${l} ${aO} ${bO})`);\n  } else if (/^(?:ok)?lch$/.test(colorSpace)) {\n    let lchA, lchB;\n    if (colorSpace === \"lch\") {\n      if (REG_CURRENT.test(colorA)) {\n        lchA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        lchA = convertColorToLch(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        lchB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        lchB = convertColorToLch(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    } else {\n      if (REG_CURRENT.test(colorA)) {\n        lchA = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        lchA = convertColorToOklch(colorA, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n      if (REG_CURRENT.test(colorB)) {\n        lchB = [constant.NONE, constant.NONE, constant.NONE, constant.NONE];\n      } else {\n        lchB = convertColorToOklch(colorB, {\n          colorSpace,\n          format: VAL_MIX\n        });\n      }\n    }\n    if (lchA === null || lchB === null) {\n      return [\"rgb\", 0, 0, 0, 0];\n    }\n    let [lA, cA, hA, alphaA] = lchA;\n    let [lB, cB, hB, alphaB] = lchB;\n    const lNone = lA === constant.NONE && lB === constant.NONE;\n    const cNone = cA === constant.NONE && cB === constant.NONE;\n    const hNone = hA === constant.NONE && hB === constant.NONE;\n    const alphaNone = alphaA === constant.NONE && alphaB === constant.NONE;\n    [[lA, cA, hA, alphaA], [lB, cB, hB, alphaB]] = normalizeColorComponents(\n      [lA, cA, hA, alphaA],\n      [lB, cB, hB, alphaB],\n      true\n    );\n    if (hueArc) {\n      [hA, hB] = util.interpolateHue(hA, hB, hueArc);\n    }\n    const factorA = alphaA * pA;\n    const factorB = alphaB * pB;\n    alpha = factorA + factorB;\n    const h = (hA * pA + hB * pB) % DEG;\n    let l, c;\n    if (alpha === 0) {\n      l = lA * pA + lB * pB;\n      c = cA * pA + cB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) / alpha;\n      c = (cA * factorA + cB * factorB) / alpha;\n      alpha = parseFloat(alpha.toFixed(3));\n    }\n    if (format === constant.VAL_COMP) {\n      return [\n        colorSpace,\n        lNone ? constant.NONE : util.roundToPrecision(l, HEX),\n        cNone ? constant.NONE : util.roundToPrecision(c, HEX),\n        hNone ? constant.NONE : util.roundToPrecision(h, HEX),\n        alphaNone ? constant.NONE : alpha * m\n      ];\n    }\n    [, r, g, b] = resolveColorValue(`${colorSpace}(${l} ${c} ${h})`);\n  }\n  return [\n    \"rgb\",\n    Math.round(r),\n    Math.round(g),\n    Math.round(b),\n    parseFloat((alpha * m).toFixed(3))\n  ];\n};\nexports.NAMED_COLORS = NAMED_COLORS;\nexports.angleToDeg = angleToDeg;\nexports.convertColorToHsl = convertColorToHsl;\nexports.convertColorToHwb = convertColorToHwb;\nexports.convertColorToLab = convertColorToLab;\nexports.convertColorToLch = convertColorToLch;\nexports.convertColorToLinearRgb = convertColorToLinearRgb;\nexports.convertColorToOklab = convertColorToOklab;\nexports.convertColorToOklch = convertColorToOklch;\nexports.convertColorToRgb = convertColorToRgb;\nexports.convertColorToXyz = convertColorToXyz;\nexports.convertHexToLinearRgb = convertHexToLinearRgb;\nexports.convertHexToRgb = convertHexToRgb;\nexports.convertHexToXyz = convertHexToXyz;\nexports.convertLinearRgbToRgb = convertLinearRgbToRgb;\nexports.convertRgbToHex = convertRgbToHex;\nexports.convertRgbToLinearRgb = convertRgbToLinearRgb;\nexports.convertRgbToXyz = convertRgbToXyz;\nexports.convertXyzD50ToLab = convertXyzD50ToLab;\nexports.convertXyzD50ToLch = convertXyzD50ToLch;\nexports.convertXyzD50ToRgb = convertXyzD50ToRgb;\nexports.convertXyzToHsl = convertXyzToHsl;\nexports.convertXyzToHwb = convertXyzToHwb;\nexports.convertXyzToOklab = convertXyzToOklab;\nexports.convertXyzToOklch = convertXyzToOklch;\nexports.convertXyzToRgb = convertXyzToRgb;\nexports.normalizeColorComponents = normalizeColorComponents;\nexports.numberToHexString = numberToHexString;\nexports.parseAlpha = parseAlpha;\nexports.parseColorFunc = parseColorFunc;\nexports.parseColorValue = parseColorValue;\nexports.parseHexAlpha = parseHexAlpha;\nexports.parseHsl = parseHsl;\nexports.parseHwb = parseHwb;\nexports.parseLab = parseLab;\nexports.parseLch = parseLch;\nexports.parseOklab = parseOklab;\nexports.parseOklch = parseOklch;\nexports.parseRgb = parseRgb;\nexports.resolveColorFunc = resolveColorFunc;\nexports.resolveColorMix = resolveColorMix;\nexports.resolveColorValue = resolveColorValue;\nexports.transformMatrix = transformMatrix;\nexports.validateColorComponents = validateColorComponents;\n//# sourceMappingURL=color.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY29sb3IuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscURBQXFELGlCQUFpQjtBQUN0RSxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtJQUFZO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBJQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQsa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RSw0Q0FBNEMsaUJBQWlCLEdBQUcscUJBQXFCO0FBQ3JGLDBDQUEwQyxpQkFBaUI7QUFDM0QsMENBQTBDLGlCQUFpQjtBQUMzRCwwQ0FBMEMsaUJBQWlCO0FBQzNELCtCQUErQixpQkFBaUI7QUFDaEQsb0NBQW9DLHNCQUFzQjtBQUMxRCxtQ0FBbUMsaUJBQWlCO0FBQ3BELDhDQUE4QyxpQkFBaUI7QUFDL0QsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQkFB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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUc7QUFDM0IsSUFBSTtBQUNKLGNBQWMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsSUFBSTtBQUNKLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsSUFBSTtBQUNKLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSiwyQkFBMkIsT0FBTztBQUNsQztBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLE9BQU87QUFDbEM7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSiwyQkFBMkIsT0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHO0FBQ25FLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9jb2xvci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZShcIi4vY29tbW9uLmNqc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmNqc1wiKTtcbmNvbnN0IGNvbnN0YW50ID0gcmVxdWlyZShcIi4vY29uc3RhbnQuY2pzXCIpO1xuY29uc3QgVkFMX01JWCA9IFwibWl4VmFsdWVcIjtcbmNvbnN0IFBQVEggPSAxZS0zO1xuY29uc3QgSEFMRiA9IDAuNTtcbmNvbnN0IERVTyA9IDI7XG5jb25zdCBUUklBID0gMztcbmNvbnN0IFFVQVQgPSA0O1xuY29uc3QgT0NUID0gODtcbmNvbnN0IERFQyA9IDEwO1xuY29uc3QgRE9aID0gMTI7XG5jb25zdCBIRVggPSAxNjtcbmNvbnN0IFNFWEEgPSA2MDtcbmNvbnN0IERFRyA9IDM2MDtcbmNvbnN0IE1BWF9QQ1QgPSAxMDA7XG5jb25zdCBNQVhfUkdCID0gMjU1O1xuY29uc3QgUE9XX1NRUiA9IDI7XG5jb25zdCBQT1dfQ1VCRSA9IDM7XG5jb25zdCBQT1dfTElORUFSID0gMi40O1xuY29uc3QgTElORUFSX0NPRUYgPSAxMi45MjtcbmNvbnN0IExJTkVBUl9PRkZTRVQgPSAwLjA1NTtcbmNvbnN0IExBQl9MID0gMTE2O1xuY29uc3QgTEFCX0EgPSA1MDA7XG5jb25zdCBMQUJfQiA9IDIwMDtcbmNvbnN0IExBQl9FUFNJTE9OID0gMjE2IC8gMjQzODk7XG5jb25zdCBMQUJfS0FQUEEgPSAyNDM4OSAvIDI3O1xuY29uc3QgRDUwID0gWzAuMzQ1NyAvIDAuMzU4NSwgMSwgKDEgLSAwLjM0NTcgLSAwLjM1ODUpIC8gMC4zNTg1XTtcbmNvbnN0IE1BVFJJWF9ENTBfVE9fRDY1ID0gW1xuICBbMC45NTU0NzM0MjE0ODgwNzUsIC0wLjAyMzA5ODQ1NDk0ODc2NDcxLCAwLjA2MzI1OTI0MzIwMDU3MDcyXSxcbiAgWy0wLjAyODM2OTcwOTMzMzg2MzcsIDEuMDA5OTk1Mzk4MDgxMzA0MSwgMC4wMjEwNDE0NDExOTE5MTczMjNdLFxuICBbMC4wMTIzMTQwMTQ4NjQ0ODE5OTgsIC0wLjAyMDUwNzY0OTI5ODg5ODk2NCwgMS4zMzAzNjU5MjYyNDIxMjRdXG5dO1xuY29uc3QgTUFUUklYX0Q2NV9UT19ENTAgPSBbXG4gIFsxLjA0NzkyOTc5MjU0NDk5NjksIDAuMDIyOTQ2ODcwNjAxNjA5NjUyLCAtMC4wNTAxOTIyNjYyODkyMDUyNF0sXG4gIFswLjAyOTYyNzgwODc3MDA1NTk5LCAwLjk5MDQzNDQyNjc1Mzg3OTksIC0wLjAxNzA3Mzc5OTA2MzQxODgyNl0sXG4gIFstMC4wMDkyNDMwNDA2NDYyMDQ1MDQsIDAuMDE1MDU1MTkxNDkwMjk4MTUyLCAwLjc1MTg3NDI4MTQyODEzNzFdXG5dO1xuY29uc3QgTUFUUklYX0xfUkdCX1RPX1hZWiA9IFtcbiAgWzUwNjc1MiAvIDEyMjg4MTUsIDg3ODgxIC8gMjQ1NzYzLCAxMjY3MyAvIDcwMjE4XSxcbiAgWzg3MDk4IC8gNDA5NjA1LCAxNzU3NjIgLyAyNDU3NjMsIDEyNjczIC8gMTc1NTQ1XSxcbiAgWzc5MTggLyA0MDk2MDUsIDg3ODgxIC8gNzM3Mjg5LCAxMDAxMTY3IC8gMTA1MzI3MF1cbl07XG5jb25zdCBNQVRSSVhfWFlaX1RPX0xfUkdCID0gW1xuICBbMTI4MzEgLyAzOTU5LCAtMzI5IC8gMjE0LCAtMTk3NCAvIDM5NTldLFxuICBbLTg1MTc4MSAvIDg3ODgxMCwgMTY0ODYxOSAvIDg3ODgxMCwgMzY1MTkgLyA4Nzg4MTBdLFxuICBbNzA1IC8gMTI2NzMsIC0yNTg1IC8gMTI2NzMsIDcwNSAvIDY2N11cbl07XG5jb25zdCBNQVRSSVhfWFlaX1RPX0xNUyA9IFtcbiAgWzAuODE5MDIyNDM3OTk2NzAzLCAwLjM2MTkwNjI2MDA1Mjg5MDQsIC0wLjEyODg3Mzc4MTUyMDk4NzldLFxuICBbMC4wMzI5ODM2NTM5MzIzODg1LCAwLjkyOTI4Njg2MTU4NjM0MzQsIDAuMDM2MTQ0NjY2MzUwNjQyNF0sXG4gIFswLjA0ODE3NzE4OTM1OTYyNDIsIDAuMjY0MjM5NTMxNzUyNzMwOCwgMC42MzM1NDc4Mjg0Njk0MzA5XVxuXTtcbmNvbnN0IE1BVFJJWF9MTVNfVE9fWFlaID0gW1xuICBbMS4yMjY4Nzk4NzU4NDU5MjQzLCAtMC41NTc4MTQ5OTQ0NjAyMTcxLCAwLjI4MTM5MTA0NTY2NTk2NDddLFxuICBbLTAuMDQwNTc1NzQ1MjE0ODAwOCwgMS4xMTIyODY4MDMyODAzMTcsIC0wLjA3MTcxMTA1ODA2NTUxNjRdLFxuICBbLTAuMDc2MzcyOTM2Njc0NjYwMSwgLTAuNDIxNDkzMzMyNDAyMjQzMiwgMS41ODY5MjQwMTk4MzY3ODE2XVxuXTtcbmNvbnN0IE1BVFJJWF9PS0xBQl9UT19MTVMgPSBbXG4gIFsxLCAwLjM5NjMzNzc3NzM3NjE3NDksIDAuMjE1ODAzNzU3MzA5OTEzNl0sXG4gIFsxLCAtMC4xMDU1NjEzNDU4MTU2NTg2LCAtMC4wNjM4NTQxNzI4MjU4MTMzXSxcbiAgWzEsIC0wLjA4OTQ4NDE3NzUyOTgxMTksIC0xLjI5MTQ4NTU0ODAxOTQwOTJdXG5dO1xuY29uc3QgTUFUUklYX0xNU19UT19PS0xBQiA9IFtcbiAgWzAuMjEwNDU0MjY4MzA5MzE0LCAwLjc5MzYxNzc3NDcwMjMwNTQsIC0wLjAwNDA3MjA0MzAxMTYxOTNdLFxuICBbMS45Nzc5OTg1MzI0MzExNjg0LCAtMi40Mjg1OTIyNDIwNDg1OCwgMC40NTA1OTM3MDk2MTc0MTFdLFxuICBbMC4wMjU5MDQwNDI0NjU1NDc4LCAwLjc4Mjc3MTcxMjQ1NzUyOTYsIC0wLjgwODY3NTc1NDkyMzA3NzRdXG5dO1xuY29uc3QgTUFUUklYX1AzX1RPX1hZWiA9IFtcbiAgWzYwODMxMSAvIDEyNTAyMDAsIDE4OTc5MyAvIDcxNDQwMCwgMTk4MjQ5IC8gMTAwMDE2MF0sXG4gIFszNTc4MyAvIDE1NjI3NSwgMjQ3MDg5IC8gMzU3MjAwLCAxOTgyNDkgLyAyNTAwNDAwXSxcbiAgWzAgLyAxLCAzMjIyOSAvIDcxNDQwMCwgNTIyMDU1NyAvIDUwMDA4MDBdXG5dO1xuY29uc3QgTUFUUklYX1JFQzIwMjBfVE9fWFlaID0gW1xuICBbNjM0MjY1MzQgLyA5OTU3NzI1NSwgMjAxNjA3NzYgLyAxMzk0MDgxNTcsIDQ3MDg2NzcxIC8gMjc4ODE2MzE0XSxcbiAgWzI2MTU4OTY2IC8gOTk1NzcyNTUsIDQ3MjU5MjMwOCAvIDY5NzA0MDc4NSwgODI2NzE0MyAvIDEzOTQwODE1N10sXG4gIFswIC8gMSwgMTk1Njc4MTIgLyA2OTcwNDA3ODUsIDI5NTgxOTk0MyAvIDI3ODgxNjMxNF1cbl07XG5jb25zdCBNQVRSSVhfQTk4X1RPX1hZWiA9IFtcbiAgWzU3MzUzNiAvIDk5NDU2NywgMjYzNjQzIC8gMTQyMDgxMCwgMTg3MjA2IC8gOTk0NTY3XSxcbiAgWzU5MTQ1OSAvIDE5ODkxMzQsIDYyMzk1NTEgLyA5OTQ1NjcwLCAzNzQ0MTIgLyA0OTcyODM1XSxcbiAgWzUzNzY5IC8gMTk4OTEzNCwgMzUxNTI0IC8gNDk3MjgzNSwgNDkyOTc1OCAvIDQ5NzI4MzVdXG5dO1xuY29uc3QgTUFUUklYX1BST1BIT1RPX1RPX1hZWl9ENTAgPSBbXG4gIFswLjc5Nzc2NjY0NDkwMDY0MjMsIDAuMTM1MTgxMjk3NDAwNTMzMDgsIDAuMDMxMzQ3NzM0MTI4MzkyMl0sXG4gIFswLjI4ODA3NDgyODgxOTQwMTMsIDAuNzExODM1MjM0MjQxODczLCA4OTkzNjkzODcyNTY0ZS0xN10sXG4gIFswLCAwLCAwLjgyNTEwNDYwMjUxMDQ2MDJdXG5dO1xuY29uc3QgUkVHX0NPTE9SID0gbmV3IFJlZ0V4cChgXig/OiR7Y29uc3RhbnQuU1lOX0NPTE9SX1RZUEV9KSRgKTtcbmNvbnN0IFJFR19DU19IVUUgPSBuZXcgUmVnRXhwKGBeJHtjb25zdGFudC5DU19IVUVfQ0FQVH0kYCk7XG5jb25zdCBSRUdfQ1NfWFlaID0gL154eXooPzotZCg/OjUwfDY1KSk/JC87XG5jb25zdCBSRUdfQ1VSUkVOVCA9IC9eY3VycmVudENvbG9yJC9pO1xuY29uc3QgUkVHX0ZOX0NPTE9SID0gbmV3IFJlZ0V4cChgXmNvbG9yXFxcXChcXFxccyooJHtjb25zdGFudC5TWU5fRk5fQ09MT1J9KVxcXFxzKlxcXFwpJGApO1xuY29uc3QgUkVHX0hTTCA9IG5ldyBSZWdFeHAoYF5oc2xhP1xcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX0hTTH18JHtjb25zdGFudC5TWU5fSFNMX0xWM30pXFxcXHMqXFxcXCkkYCk7XG5jb25zdCBSRUdfSFdCID0gbmV3IFJlZ0V4cChgXmh3YlxcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX0hTTH0pXFxcXHMqXFxcXCkkYCk7XG5jb25zdCBSRUdfTEFCID0gbmV3IFJlZ0V4cChgXmxhYlxcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX01PRH0pXFxcXHMqXFxcXCkkYCk7XG5jb25zdCBSRUdfTENIID0gbmV3IFJlZ0V4cChgXmxjaFxcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX0xDSH0pXFxcXHMqXFxcXCkkYCk7XG5jb25zdCBSRUdfTUlYID0gbmV3IFJlZ0V4cChgXiR7Y29uc3RhbnQuU1lOX01JWH0kYCk7XG5jb25zdCBSRUdfTUlYX0NBUFQgPSBuZXcgUmVnRXhwKGBeJHtjb25zdGFudC5TWU5fTUlYX0NBUFR9JGApO1xuY29uc3QgUkVHX01JWF9ORVNUID0gbmV3IFJlZ0V4cChgJHtjb25zdGFudC5TWU5fTUlYfWAsIFwiZ1wiKTtcbmNvbnN0IFJFR19PS0xBQiA9IG5ldyBSZWdFeHAoYF5va2xhYlxcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX01PRH0pXFxcXHMqXFxcXCkkYCk7XG5jb25zdCBSRUdfT0tMQ0ggPSBuZXcgUmVnRXhwKGBeb2tsY2hcXFxcKFxcXFxzKigke2NvbnN0YW50LlNZTl9MQ0h9KVxcXFxzKlxcXFwpJGApO1xuY29uc3QgUkVHX1NQRUMgPSAvXig/OnNwZWNpZml8Y29tcHV0KWVkVmFsdWUkLztcbmNvbnN0IE5BTUVEX0NPTE9SUyA9IHtcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuY29uc3QgdmFsaWRhdGVDb2xvckNvbXBvbmVudHMgPSAoYXJyLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7YXJyfSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGFscGhhID0gZmFsc2UsXG4gICAgbWluTGVuZ3RoID0gVFJJQSxcbiAgICBtYXhMZW5ndGggPSBRVUFULFxuICAgIG1pblJhbmdlID0gMCxcbiAgICBtYXhSYW5nZSA9IDEsXG4gICAgdmFsaWRhdGVSYW5nZSA9IHRydWVcbiAgfSA9IG9wdDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWluTGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bWluTGVuZ3RofSBpcyBub3QgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWF4TGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bWF4TGVuZ3RofSBpcyBub3QgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWluUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHttaW5SYW5nZX0gaXMgbm90IGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKG1heFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bWF4UmFuZ2V9IGlzIG5vdCBhIG51bWJlci5gKTtcbiAgfVxuICBjb25zdCBsID0gYXJyLmxlbmd0aDtcbiAgaWYgKGwgPCBtaW5MZW5ndGggfHwgbCA+IG1heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhcnJheSBsZW5ndGggJHtsfS5gKTtcbiAgfVxuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbCkge1xuICAgIGNvbnN0IHYgPSBhcnJbaV07XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dn0gaXMgbm90IGEgbnVtYmVyLmApO1xuICAgIH0gZWxzZSBpZiAoaSA8IFRSSUEgJiYgdmFsaWRhdGVSYW5nZSAmJiAodiA8IG1pblJhbmdlIHx8IHYgPiBtYXhSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAke3Z9IGlzIG5vdCBiZXR3ZWVuICR7bWluUmFuZ2V9IGFuZCAke21heFJhbmdlfS5gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IFRSSUEgJiYgKHYgPCAwIHx8IHYgPiAxKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7dn0gaXMgbm90IGJldHdlZW4gMCBhbmQgMS5gKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGlmIChhbHBoYSAmJiBsID09PSBUUklBKSB7XG4gICAgYXJyLnB1c2goMSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5jb25zdCB0cmFuc2Zvcm1NYXRyaXggPSAobXR4LCB2Y3QsIHNraXAgPSBmYWxzZSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobXR4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bXR4fSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gIH0gZWxzZSBpZiAobXR4Lmxlbmd0aCAhPT0gVFJJQSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhcnJheSBsZW5ndGggJHttdHgubGVuZ3RofS5gKTtcbiAgfSBlbHNlIGlmICghc2tpcCkge1xuICAgIGZvciAobGV0IGkgb2YgbXR4KSB7XG4gICAgICBpID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHMoaSwge1xuICAgICAgICBtYXhMZW5ndGg6IFRSSUEsXG4gICAgICAgIHZhbGlkYXRlUmFuZ2U6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgW1tyMWMxLCByMWMyLCByMWMzXSwgW3IyYzEsIHIyYzIsIHIyYzNdLCBbcjNjMSwgcjNjMiwgcjNjM11dID0gbXR4O1xuICBsZXQgdjEsIHYyLCB2MztcbiAgaWYgKHNraXApIHtcbiAgICBbdjEsIHYyLCB2M10gPSB2Y3Q7XG4gIH0gZWxzZSB7XG4gICAgW3YxLCB2MiwgdjNdID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHModmN0LCB7XG4gICAgICBtYXhMZW5ndGg6IFRSSUEsXG4gICAgICB2YWxpZGF0ZVJhbmdlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHAxID0gcjFjMSAqIHYxICsgcjFjMiAqIHYyICsgcjFjMyAqIHYzO1xuICBjb25zdCBwMiA9IHIyYzEgKiB2MSArIHIyYzIgKiB2MiArIHIyYzMgKiB2MztcbiAgY29uc3QgcDMgPSByM2MxICogdjEgKyByM2MyICogdjIgKyByM2MzICogdjM7XG4gIHJldHVybiBbcDEsIHAyLCBwM107XG59O1xuY29uc3Qgbm9ybWFsaXplQ29sb3JDb21wb25lbnRzID0gKGNvbG9yQSwgY29sb3JCLCBza2lwID0gZmFsc2UpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yQSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbG9yQX0gaXMgbm90IGFuIGFycmF5LmApO1xuICB9IGVsc2UgaWYgKGNvbG9yQS5sZW5ndGggIT09IFFVQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYXJyYXkgbGVuZ3RoICR7Y29sb3JBLmxlbmd0aH0uYCk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yQikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbG9yQn0gaXMgbm90IGFuIGFycmF5LmApO1xuICB9IGVsc2UgaWYgKGNvbG9yQi5sZW5ndGggIT09IFFVQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYXJyYXkgbGVuZ3RoICR7Y29sb3JCLmxlbmd0aH0uYCk7XG4gIH1cbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IFFVQVQpIHtcbiAgICBpZiAoY29sb3JBW2ldID09PSBjb25zdGFudC5OT05FICYmIGNvbG9yQltpXSA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgICAgY29sb3JBW2ldID0gMDtcbiAgICAgIGNvbG9yQltpXSA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2xvckFbaV0gPT09IGNvbnN0YW50Lk5PTkUpIHtcbiAgICAgIGNvbG9yQVtpXSA9IGNvbG9yQltpXTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yQltpXSA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgICAgY29sb3JCW2ldID0gY29sb3JBW2ldO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgaWYgKCFza2lwKSB7XG4gICAgY29sb3JBID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHMoY29sb3JBLCB7XG4gICAgICBtaW5MZW5ndGg6IFFVQVQsXG4gICAgICB2YWxpZGF0ZVJhbmdlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbG9yQiA9IHZhbGlkYXRlQ29sb3JDb21wb25lbnRzKGNvbG9yQiwge1xuICAgICAgbWluTGVuZ3RoOiBRVUFULFxuICAgICAgdmFsaWRhdGVSYW5nZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2NvbG9yQSwgY29sb3JCXTtcbn07XG5jb25zdCBudW1iZXJUb0hleFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBudW1iZXIuYCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gTUFYX1JHQikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBiZXR3ZWVuIDAgYW5kICR7TUFYX1JHQn0uYCk7XG4gICAgfVxuICB9XG4gIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZyhIRVgpO1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgfVxuICByZXR1cm4gaGV4O1xufTtcbmNvbnN0IGFuZ2xlVG9EZWcgPSAoYW5nbGUpID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyhhbmdsZSkpIHtcbiAgICBhbmdsZSA9IGFuZ2xlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2FuZ2xlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgR1JBRCA9IERFRyAvIDQwMDtcbiAgY29uc3QgUkFEID0gREVHIC8gKE1hdGguUEkgKiBEVU8pO1xuICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKGBeKCR7Y29uc3RhbnQuTlVNfSkoJHtjb25zdGFudC5BTkdMRX0pPyRgKTtcbiAgaWYgKCFyZWcudGVzdChhbmdsZSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgcHJvcGVydHkgdmFsdWU6ICR7YW5nbGV9YCk7XG4gIH1cbiAgY29uc3QgWywgdmFsLCB1bml0XSA9IGFuZ2xlLm1hdGNoKHJlZyk7XG4gIGNvbnN0IHZhbHVlID0gdmFsWzBdID09PSBcIi5cIiA/IGAwJHt2YWx9YCA6IHZhbDtcbiAgbGV0IGRlZztcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSBcImdyYWRcIjpcbiAgICAgIGRlZyA9IHBhcnNlRmxvYXQodmFsdWUpICogR1JBRDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyYWRcIjpcbiAgICAgIGRlZyA9IHBhcnNlRmxvYXQodmFsdWUpICogUkFEO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInR1cm5cIjpcbiAgICAgIGRlZyA9IHBhcnNlRmxvYXQodmFsdWUpICogREVHO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRlZyA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG4gIGRlZyAlPSBERUc7XG4gIGlmIChkZWcgPCAwKSB7XG4gICAgZGVnICs9IERFRztcbiAgfSBlbHNlIGlmIChPYmplY3QuaXMoZGVnLCAtMCkpIHtcbiAgICBkZWcgPSAwO1xuICB9XG4gIHJldHVybiBkZWc7XG59O1xuY29uc3QgcGFyc2VBbHBoYSA9IChfYWxwaGEpID0+IHtcbiAgbGV0IGFscGhhID0gX2FscGhhO1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKGFscGhhKSkge1xuICAgIGFscGhhID0gYWxwaGEudHJpbSgpO1xuICAgIGlmICghYWxwaGEpIHtcbiAgICAgIGFscGhhID0gMTtcbiAgICB9IGVsc2UgaWYgKGFscGhhID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbHBoYVswXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgYWxwaGEgPSBgMCR7YWxwaGF9YDtcbiAgICAgIH1cbiAgICAgIGlmIChhbHBoYS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKSAvIE1BWF9QQ1Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEpO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYWxwaGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7YWxwaGF9IGlzIG5vdCBhIG51bWJlci5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbHBoYSA8IFBQVEgpIHtcbiAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhbHBoYSA+IDEpIHtcbiAgICAgICAgYWxwaGEgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhLnRvRml4ZWQoMykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbHBoYSA9IDE7XG4gIH1cbiAgcmV0dXJuIGFscGhhO1xufTtcbmNvbnN0IHBhcnNlSGV4QWxwaGEgPSAodmFsdWUpID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgcHJvcGVydHkgdmFsdWU6IChlbXB0eSBzdHJpbmcpXCIpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgbGV0IGFscGhhID0gcGFyc2VJbnQodmFsdWUsIEhFWCk7XG4gIGlmIChhbHBoYSA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGFscGhhID49IE1BWF9SR0IpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCBhbHBoYU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgTUFYX1BDVDsgaSsrKSB7XG4gICAgYWxwaGFNYXAuc2V0KE1hdGgucm91bmQoaSAqIE1BWF9SR0IgLyBNQVhfUENUKSwgaSk7XG4gIH1cbiAgaWYgKGFscGhhTWFwLmhhcyhhbHBoYSkpIHtcbiAgICBhbHBoYSA9IGFscGhhTWFwLmdldChhbHBoYSkgLyBNQVhfUENUO1xuICB9IGVsc2Uge1xuICAgIGFscGhhID0gTWF0aC5yb3VuZChhbHBoYSAvIE1BWF9SR0IgLyBQUFRIKSAqIFBQVEg7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQoYWxwaGEudG9GaXhlZCgzKSk7XG59O1xuY29uc3QgY29udmVydFJnYlRvTGluZWFyUmdiID0gKHJnYiwgc2tpcCA9IGZhbHNlKSA9PiB7XG4gIGxldCByciwgZ2csIGJiO1xuICBpZiAoc2tpcCkge1xuICAgIFtyciwgZ2csIGJiXSA9IHJnYjtcbiAgfSBlbHNlIHtcbiAgICBbcnIsIGdnLCBiYl0gPSB2YWxpZGF0ZUNvbG9yQ29tcG9uZW50cyhyZ2IsIHtcbiAgICAgIG1heExlbmd0aDogVFJJQSxcbiAgICAgIG1heFJhbmdlOiBNQVhfUkdCXG4gICAgfSk7XG4gIH1cbiAgbGV0IHIgPSByciAvIE1BWF9SR0I7XG4gIGxldCBnID0gZ2cgLyBNQVhfUkdCO1xuICBsZXQgYiA9IGJiIC8gTUFYX1JHQjtcbiAgY29uc3QgQ09ORF9QT1cgPSAwLjA0MDQ1O1xuICBpZiAociA+IENPTkRfUE9XKSB7XG4gICAgciA9IE1hdGgucG93KChyICsgTElORUFSX09GRlNFVCkgLyAoMSArIExJTkVBUl9PRkZTRVQpLCBQT1dfTElORUFSKTtcbiAgfSBlbHNlIHtcbiAgICByIC89IExJTkVBUl9DT0VGO1xuICB9XG4gIGlmIChnID4gQ09ORF9QT1cpIHtcbiAgICBnID0gTWF0aC5wb3coKGcgKyBMSU5FQVJfT0ZGU0VUKSAvICgxICsgTElORUFSX09GRlNFVCksIFBPV19MSU5FQVIpO1xuICB9IGVsc2Uge1xuICAgIGcgLz0gTElORUFSX0NPRUY7XG4gIH1cbiAgaWYgKGIgPiBDT05EX1BPVykge1xuICAgIGIgPSBNYXRoLnBvdygoYiArIExJTkVBUl9PRkZTRVQpIC8gKDEgKyBMSU5FQVJfT0ZGU0VUKSwgUE9XX0xJTkVBUik7XG4gIH0gZWxzZSB7XG4gICAgYiAvPSBMSU5FQVJfQ09FRjtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGJdO1xufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb1h5eiA9IChyZ2IsIHNraXAgPSBmYWxzZSkgPT4ge1xuICBsZXQgciwgZywgYiwgYWxwaGE7XG4gIGlmIChza2lwKSB7XG4gICAgW3IsIGcsIGIsIGFscGhhXSA9IHJnYjtcbiAgfSBlbHNlIHtcbiAgICBbciwgZywgYiwgYWxwaGFdID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHMocmdiLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIG1heFJhbmdlOiBNQVhfUkdCXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgW3JyLCBnZywgYmJdID0gY29udmVydFJnYlRvTGluZWFyUmdiKFtyLCBnLCBiXSwgdHJ1ZSk7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfTF9SR0JfVE9fWFlaLCBbcnIsIGdnLCBiYl0sIHRydWUpO1xuICByZXR1cm4gW3gsIHksIHosIGFscGhhXTtcbn07XG5jb25zdCBjb252ZXJ0UmdiVG9IZXggPSAocmdiKSA9PiB7XG4gIGNvbnN0IFtyLCBnLCBiLCBhbHBoYV0gPSB2YWxpZGF0ZUNvbG9yQ29tcG9uZW50cyhyZ2IsIHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBtYXhSYW5nZTogTUFYX1JHQlxuICB9KTtcbiAgY29uc3QgcnIgPSBudW1iZXJUb0hleFN0cmluZyhyKTtcbiAgY29uc3QgZ2cgPSBudW1iZXJUb0hleFN0cmluZyhnKTtcbiAgY29uc3QgYmIgPSBudW1iZXJUb0hleFN0cmluZyhiKTtcbiAgY29uc3QgYWEgPSBudW1iZXJUb0hleFN0cmluZyhhbHBoYSAqIE1BWF9SR0IpO1xuICBsZXQgaGV4O1xuICBpZiAoYWEgPT09IFwiZmZcIikge1xuICAgIGhleCA9IGAjJHtycn0ke2dnfSR7YmJ9YDtcbiAgfSBlbHNlIHtcbiAgICBoZXggPSBgIyR7cnJ9JHtnZ30ke2JifSR7YWF9YDtcbiAgfVxuICByZXR1cm4gaGV4O1xufTtcbmNvbnN0IGNvbnZlcnRMaW5lYXJSZ2JUb1JnYiA9IChyZ2IsIHJvdW5kID0gZmFsc2UpID0+IHtcbiAgbGV0IFtyLCBnLCBiXSA9IHZhbGlkYXRlQ29sb3JDb21wb25lbnRzKHJnYiwge1xuICAgIG1heExlbmd0aDogVFJJQVxuICB9KTtcbiAgY29uc3QgQ09ORF9QT1cgPSA4MDkgLyAyNTg0MDA7XG4gIGlmIChyID4gQ09ORF9QT1cpIHtcbiAgICByID0gTWF0aC5wb3cociwgMSAvIFBPV19MSU5FQVIpICogKDEgKyBMSU5FQVJfT0ZGU0VUKSAtIExJTkVBUl9PRkZTRVQ7XG4gIH0gZWxzZSB7XG4gICAgciAqPSBMSU5FQVJfQ09FRjtcbiAgfVxuICByICo9IE1BWF9SR0I7XG4gIGlmIChnID4gQ09ORF9QT1cpIHtcbiAgICBnID0gTWF0aC5wb3coZywgMSAvIFBPV19MSU5FQVIpICogKDEgKyBMSU5FQVJfT0ZGU0VUKSAtIExJTkVBUl9PRkZTRVQ7XG4gIH0gZWxzZSB7XG4gICAgZyAqPSBMSU5FQVJfQ09FRjtcbiAgfVxuICBnICo9IE1BWF9SR0I7XG4gIGlmIChiID4gQ09ORF9QT1cpIHtcbiAgICBiID0gTWF0aC5wb3coYiwgMSAvIFBPV19MSU5FQVIpICogKDEgKyBMSU5FQVJfT0ZGU0VUKSAtIExJTkVBUl9PRkZTRVQ7XG4gIH0gZWxzZSB7XG4gICAgYiAqPSBMSU5FQVJfQ09FRjtcbiAgfVxuICBiICo9IE1BWF9SR0I7XG4gIHJldHVybiBbXG4gICAgcm91bmQgPyBNYXRoLnJvdW5kKHIpIDogcixcbiAgICByb3VuZCA/IE1hdGgucm91bmQoZykgOiBnLFxuICAgIHJvdW5kID8gTWF0aC5yb3VuZChiKSA6IGJcbiAgXTtcbn07XG5jb25zdCBjb252ZXJ0WHl6VG9SZ2IgPSAoeHl6LCBza2lwID0gZmFsc2UpID0+IHtcbiAgbGV0IHgsIHksIHosIGFscGhhO1xuICBpZiAoc2tpcCkge1xuICAgIFt4LCB5LCB6LCBhbHBoYV0gPSB4eXo7XG4gIH0gZWxzZSB7XG4gICAgW3gsIHksIHosIGFscGhhXSA9IHZhbGlkYXRlQ29sb3JDb21wb25lbnRzKHh5eiwge1xuICAgICAgdmFsaWRhdGVSYW5nZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBsZXQgW3IsIGcsIGJdID0gdHJhbnNmb3JtTWF0cml4KE1BVFJJWF9YWVpfVE9fTF9SR0IsIFt4LCB5LCB6XSwgdHJ1ZSk7XG4gIFtyLCBnLCBiXSA9IGNvbnZlcnRMaW5lYXJSZ2JUb1JnYihcbiAgICBbXG4gICAgICBNYXRoLm1pbihNYXRoLm1heChyLCAwKSwgMSksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heChnLCAwKSwgMSksXG4gICAgICBNYXRoLm1pbihNYXRoLm1heChiLCAwKSwgMSlcbiAgICBdLFxuICAgIHRydWVcbiAgKTtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydFh5elRvSHNsID0gKHh5eiwgc2tpcCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IFtyciwgZ2csIGJiLCBhbHBoYV0gPSBjb252ZXJ0WHl6VG9SZ2IoeHl6LCBza2lwKTtcbiAgY29uc3QgciA9IHJyIC8gTUFYX1JHQjtcbiAgY29uc3QgZyA9IGdnIC8gTUFYX1JHQjtcbiAgY29uc3QgYiA9IGJiIC8gTUFYX1JHQjtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBkID0gbWF4IC0gbWluO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgKiBIQUxGICogTUFYX1BDVDtcbiAgbGV0IGgsIHM7XG4gIGlmIChNYXRoLnJvdW5kKGwpID09PSAwIHx8IE1hdGgucm91bmQobCkgPT09IE1BWF9QQ1QpIHtcbiAgICBoID0gY29uc3RhbnQuTk9ORTtcbiAgICBzID0gY29uc3RhbnQuTk9ORTtcbiAgfSBlbHNlIHtcbiAgICBzID0gZCAvICgxIC0gTWF0aC5hYnMobWF4ICsgbWluIC0gMSkpICogTUFYX1BDVDtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgaCA9IGNvbnN0YW50Lk5PTkU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICBoID0gKGcgLSBiKSAvIGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZzpcbiAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyBEVU87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyBRVUFUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaCA9IGggKiBTRVhBICUgREVHO1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gREVHO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW2gsIHMsIGwsIGFscGhhXTtcbn07XG5jb25zdCBjb252ZXJ0WHl6VG9Id2IgPSAoeHl6LCBza2lwID0gZmFsc2UpID0+IHtcbiAgY29uc3QgW3IsIGcsIGIsIGFscGhhXSA9IGNvbnZlcnRYeXpUb1JnYih4eXosIHNraXApO1xuICBjb25zdCB3ID0gTWF0aC5taW4ociwgZywgYikgLyBNQVhfUkdCO1xuICBjb25zdCBiayA9IDEgLSBNYXRoLm1heChyLCBnLCBiKSAvIE1BWF9SR0I7XG4gIGxldCBoO1xuICBpZiAodyArIGJrID09PSAxKSB7XG4gICAgaCA9IGNvbnN0YW50Lk5PTkU7XG4gIH0gZWxzZSB7XG4gICAgW2hdID0gY29udmVydFh5elRvSHNsKHh5eik7XG4gIH1cbiAgcmV0dXJuIFtoLCB3ICogTUFYX1BDVCwgYmsgKiBNQVhfUENULCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydFh5elRvT2tsYWIgPSAoeHl6LCBza2lwID0gZmFsc2UpID0+IHtcbiAgbGV0IHgsIHksIHosIGFscGhhO1xuICBpZiAoc2tpcCkge1xuICAgIFt4LCB5LCB6LCBhbHBoYV0gPSB4eXo7XG4gIH0gZWxzZSB7XG4gICAgW3gsIHksIHosIGFscGhhXSA9IHZhbGlkYXRlQ29sb3JDb21wb25lbnRzKHh5eiwge1xuICAgICAgdmFsaWRhdGVSYW5nZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsbXMgPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX1hZWl9UT19MTVMsIFt4LCB5LCB6XSwgdHJ1ZSk7XG4gIGNvbnN0IHh5ekxtcyA9IGxtcy5tYXAoKGMpID0+IE1hdGguY2JydChjKSk7XG4gIGxldCBbbCwgYSwgYl0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX0xNU19UT19PS0xBQiwgeHl6TG1zLCB0cnVlKTtcbiAgbCA9IE1hdGgubWluKE1hdGgubWF4KGwsIDApLCAxKTtcbiAgY29uc3QgbFBjdCA9IE1hdGgucm91bmQocGFyc2VGbG9hdChsLnRvRml4ZWQoUVVBVCkpICogTUFYX1BDVCk7XG4gIGlmIChsUGN0ID09PSAwIHx8IGxQY3QgPT09IE1BWF9QQ1QpIHtcbiAgICBhID0gY29uc3RhbnQuTk9ORTtcbiAgICBiID0gY29uc3RhbnQuTk9ORTtcbiAgfVxuICByZXR1cm4gW2wsIGEsIGIsIGFscGhhXTtcbn07XG5jb25zdCBjb252ZXJ0WHl6VG9Pa2xjaCA9ICh4eXosIHNraXAgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBbbCwgYSwgYiwgYWFdID0gY29udmVydFh5elRvT2tsYWIoeHl6LCBza2lwKTtcbiAgbGV0IGMsIGg7XG4gIGNvbnN0IGxQY3QgPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobC50b0ZpeGVkKFFVQVQpKSAqIE1BWF9QQ1QpO1xuICBpZiAobFBjdCA9PT0gMCB8fCBsUGN0ID09PSBNQVhfUENUKSB7XG4gICAgYyA9IGNvbnN0YW50Lk5PTkU7XG4gICAgaCA9IGNvbnN0YW50Lk5PTkU7XG4gIH0gZWxzZSB7XG4gICAgYyA9IE1hdGgubWF4KE1hdGguc3FydChNYXRoLnBvdyhhLCBQT1dfU1FSKSArIE1hdGgucG93KGIsIFBPV19TUVIpKSwgMCk7XG4gICAgaWYgKHBhcnNlRmxvYXQoYy50b0ZpeGVkKFFVQVQpKSA9PT0gMCkge1xuICAgICAgaCA9IGNvbnN0YW50Lk5PTkU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBNYXRoLmF0YW4yKGIsIGEpICogREVHICogSEFMRiAvIE1hdGguUEk7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSBERUc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbbCwgYywgaCwgYWFdO1xufTtcbmNvbnN0IGNvbnZlcnRYeXpENTBUb1JnYiA9ICh4eXosIHNraXAgPSBmYWxzZSkgPT4ge1xuICBsZXQgeCwgeSwgeiwgYWxwaGE7XG4gIGlmIChza2lwKSB7XG4gICAgW3gsIHksIHosIGFscGhhXSA9IHh5ejtcbiAgfSBlbHNlIHtcbiAgICBbeCwgeSwgeiwgYWxwaGFdID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHMoeHl6LCB7XG4gICAgICBtaW5MZW5ndGg6IFFVQVQsXG4gICAgICB2YWxpZGF0ZVJhbmdlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHh5ekQ2NSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfRDUwX1RPX0Q2NSwgW3gsIHksIHpdLCB0cnVlKTtcbiAgY29uc3QgW3IsIGcsIGJdID0gY29udmVydFh5elRvUmdiKHh5ekQ2NSwgdHJ1ZSk7XG4gIHJldHVybiBbciwgZywgYiwgYWxwaGFdO1xufTtcbmNvbnN0IGNvbnZlcnRYeXpENTBUb0xhYiA9ICh4eXosIHNraXAgPSBmYWxzZSkgPT4ge1xuICBsZXQgeCwgeSwgeiwgYWxwaGE7XG4gIGlmIChza2lwKSB7XG4gICAgW3gsIHksIHosIGFscGhhXSA9IHh5ejtcbiAgfSBlbHNlIHtcbiAgICBbeCwgeSwgeiwgYWxwaGFdID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHMoeHl6LCB7XG4gICAgICB2YWxpZGF0ZVJhbmdlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHh5ekQ1MCA9IFt4LCB5LCB6XS5tYXAoKHZhbCwgaSkgPT4gdmFsIC8gRDUwW2ldKTtcbiAgY29uc3QgW2YwLCBmMSwgZjJdID0geHl6RDUwLm1hcChcbiAgICAodmFsKSA9PiB2YWwgPiBMQUJfRVBTSUxPTiA/IE1hdGguY2JydCh2YWwpIDogKHZhbCAqIExBQl9LQVBQQSArIEhFWCkgLyBMQUJfTFxuICApO1xuICBjb25zdCBsID0gTWF0aC5taW4oTWF0aC5tYXgoTEFCX0wgKiBmMSAtIEhFWCwgMCksIE1BWF9QQ1QpO1xuICBsZXQgYSwgYjtcbiAgaWYgKGwgPT09IDAgfHwgbCA9PT0gTUFYX1BDVCkge1xuICAgIGEgPSBjb25zdGFudC5OT05FO1xuICAgIGIgPSBjb25zdGFudC5OT05FO1xuICB9IGVsc2Uge1xuICAgIGEgPSAoZjAgLSBmMSkgKiBMQUJfQTtcbiAgICBiID0gKGYxIC0gZjIpICogTEFCX0I7XG4gIH1cbiAgcmV0dXJuIFtsLCBhLCBiLCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydFh5ekQ1MFRvTGNoID0gKHh5eiwgc2tpcCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IFtsLCBhLCBiLCBhbHBoYV0gPSBjb252ZXJ0WHl6RDUwVG9MYWIoeHl6LCBza2lwKTtcbiAgbGV0IGMsIGg7XG4gIGlmIChsID09PSAwIHx8IGwgPT09IE1BWF9QQ1QpIHtcbiAgICBjID0gY29uc3RhbnQuTk9ORTtcbiAgICBoID0gY29uc3RhbnQuTk9ORTtcbiAgfSBlbHNlIHtcbiAgICBjID0gTWF0aC5tYXgoTWF0aC5zcXJ0KE1hdGgucG93KGEsIFBPV19TUVIpICsgTWF0aC5wb3coYiwgUE9XX1NRUikpLCAwKTtcbiAgICBoID0gTWF0aC5hdGFuMihiLCBhKSAqIERFRyAqIEhBTEYgLyBNYXRoLlBJO1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSBERUc7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbCwgYywgaCwgYWxwaGFdO1xufTtcbmNvbnN0IGNvbnZlcnRIZXhUb1JnYiA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGlmICghKC9eI1tcXGRhLWZdezZ9JC8udGVzdCh2YWx1ZSkgfHwgL14jW1xcZGEtZl17M30kLy50ZXN0KHZhbHVlKSB8fCAvXiNbXFxkYS1mXXs4fSQvLnRlc3QodmFsdWUpIHx8IC9eI1tcXGRhLWZdezR9JC8udGVzdCh2YWx1ZSkpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHByb3BlcnR5IHZhbHVlOiAke3ZhbHVlfWApO1xuICB9XG4gIGNvbnN0IGFyciA9IFtdO1xuICBpZiAoL14jW1xcZGEtZl17Nn0kLy50ZXN0KHZhbHVlKSkge1xuICAgIGNvbnN0IFssIHIsIGcsIGJdID0gdmFsdWUubWF0Y2goXG4gICAgICAvXiMoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkkL1xuICAgICk7XG4gICAgYXJyLnB1c2gocGFyc2VJbnQociwgSEVYKSwgcGFyc2VJbnQoZywgSEVYKSwgcGFyc2VJbnQoYiwgSEVYKSwgMSk7XG4gIH0gZWxzZSBpZiAoL14jW1xcZGEtZl17M30kLy50ZXN0KHZhbHVlKSkge1xuICAgIGNvbnN0IFssIHIsIGcsIGJdID0gdmFsdWUubWF0Y2goL14jKFtcXGRhLWZdKShbXFxkYS1mXSkoW1xcZGEtZl0pJC8pO1xuICAgIGFyci5wdXNoKFxuICAgICAgcGFyc2VJbnQoYCR7cn0ke3J9YCwgSEVYKSxcbiAgICAgIHBhcnNlSW50KGAke2d9JHtnfWAsIEhFWCksXG4gICAgICBwYXJzZUludChgJHtifSR7Yn1gLCBIRVgpLFxuICAgICAgMVxuICAgICk7XG4gIH0gZWxzZSBpZiAoL14jW1xcZGEtZl17OH0kLy50ZXN0KHZhbHVlKSkge1xuICAgIGNvbnN0IFssIHIsIGcsIGIsIGFscGhhXSA9IHZhbHVlLm1hdGNoKFxuICAgICAgL14jKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KSQvXG4gICAgKTtcbiAgICBhcnIucHVzaChcbiAgICAgIHBhcnNlSW50KHIsIEhFWCksXG4gICAgICBwYXJzZUludChnLCBIRVgpLFxuICAgICAgcGFyc2VJbnQoYiwgSEVYKSxcbiAgICAgIHBhcnNlSGV4QWxwaGEoYWxwaGEpXG4gICAgKTtcbiAgfSBlbHNlIGlmICgvXiNbXFxkYS1mXXs0fSQvLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3QgWywgciwgZywgYiwgYWxwaGFdID0gdmFsdWUubWF0Y2goXG4gICAgICAvXiMoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSkoW1xcZGEtZl0pJC9cbiAgICApO1xuICAgIGFyci5wdXNoKFxuICAgICAgcGFyc2VJbnQoYCR7cn0ke3J9YCwgSEVYKSxcbiAgICAgIHBhcnNlSW50KGAke2d9JHtnfWAsIEhFWCksXG4gICAgICBwYXJzZUludChgJHtifSR7Yn1gLCBIRVgpLFxuICAgICAgcGFyc2VIZXhBbHBoYShgJHthbHBoYX0ke2FscGhhfWApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IGNvbnZlcnRIZXhUb0xpbmVhclJnYiA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBbcnIsIGdnLCBiYiwgYWxwaGFdID0gY29udmVydEhleFRvUmdiKHZhbHVlKTtcbiAgY29uc3QgW3IsIGcsIGJdID0gY29udmVydFJnYlRvTGluZWFyUmdiKFtyciwgZ2csIGJiXSwgdHJ1ZSk7XG4gIHJldHVybiBbciwgZywgYiwgYWxwaGFdO1xufTtcbmNvbnN0IGNvbnZlcnRIZXhUb1h5eiA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBbciwgZywgYiwgYWxwaGFdID0gY29udmVydEhleFRvTGluZWFyUmdiKHZhbHVlKTtcbiAgY29uc3QgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KE1BVFJJWF9MX1JHQl9UT19YWVosIFtyLCBnLCBiXSwgdHJ1ZSk7XG4gIHJldHVybiBbeCwgeSwgeiwgYWxwaGFdO1xufTtcbmNvbnN0IHBhcnNlUmdiID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHQ7XG4gIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoYF5yZ2JhP1xcXFwoXFxcXHMqKCR7Y29uc3RhbnQuU1lOX01PRH18JHtjb25zdGFudC5TWU5fUkdCX0xWM30pXFxcXHMqXFxcXCkkYCk7XG4gIGlmICghcmVnLnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFssIHZhbF0gPSB2YWx1ZS5tYXRjaChyZWcpO1xuICBsZXQgW3YxLCB2MiwgdjMsIHY0XSA9IHZhbC5yZXBsYWNlKC9bLC9dL2csIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHYxID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHYxWzBdID09PSBcIi5cIikge1xuICAgICAgdjEgPSBgMCR7djF9YDtcbiAgICB9XG4gICAgaWYgKHYxLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgciA9IHBhcnNlRmxvYXQodjEpICogTUFYX1JHQiAvIE1BWF9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUZsb2F0KHYxKTtcbiAgICB9XG4gICAgciA9IE1hdGgubWluKE1hdGgubWF4KHV0aWwucm91bmRUb1ByZWNpc2lvbihyLCBPQ1QpLCAwKSwgTUFYX1JHQik7XG4gIH1cbiAgaWYgKHYyID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgZyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHYyWzBdID09PSBcIi5cIikge1xuICAgICAgdjIgPSBgMCR7djJ9YDtcbiAgICB9XG4gICAgaWYgKHYyLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgZyA9IHBhcnNlRmxvYXQodjIpICogTUFYX1JHQiAvIE1BWF9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcgPSBwYXJzZUZsb2F0KHYyKTtcbiAgICB9XG4gICAgZyA9IE1hdGgubWluKE1hdGgubWF4KHV0aWwucm91bmRUb1ByZWNpc2lvbihnLCBPQ1QpLCAwKSwgTUFYX1JHQik7XG4gIH1cbiAgaWYgKHYzID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgYiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHYzWzBdID09PSBcIi5cIikge1xuICAgICAgdjMgPSBgMCR7djN9YDtcbiAgICB9XG4gICAgaWYgKHYzLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgYiA9IHBhcnNlRmxvYXQodjMpICogTUFYX1JHQiAvIE1BWF9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSBwYXJzZUZsb2F0KHYzKTtcbiAgICB9XG4gICAgYiA9IE1hdGgubWluKE1hdGgubWF4KHV0aWwucm91bmRUb1ByZWNpc2lvbihiLCBPQ1QpLCAwKSwgTUFYX1JHQik7XG4gIH1cbiAgY29uc3QgYWxwaGEgPSBwYXJzZUFscGhhKHY0KTtcbiAgcmV0dXJuIFtcInJnYlwiLCByLCBnLCBiLCBmb3JtYXQgPT09IFZBTF9NSVggJiYgdjQgPT09IGNvbnN0YW50Lk5PTkUgPyBjb25zdGFudC5OT05FIDogYWxwaGFdO1xufTtcbmNvbnN0IHBhcnNlSHNsID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGZvcm1hdCB9ID0gb3B0O1xuICBpZiAoIVJFR19IU0wudGVzdCh2YWx1ZSkpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgY2FzZSBWQUxfTUlYOiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBjb25zdGFudC5WQUxfU1BFQzoge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19IU0wpO1xuICBsZXQgW2gsIHMsIGwsIGFscGhhXSA9IHZhbC5yZXBsYWNlKC9bLC9dL2csIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAoaCA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmIChmb3JtYXQgIT09IFwiaHNsXCIpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoID0gYW5nbGVUb0RlZyhoKTtcbiAgfVxuICBpZiAocyA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmIChmb3JtYXQgIT09IFwiaHNsXCIpIHtcbiAgICAgIHMgPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc1swXSA9PT0gXCIuXCIpIHtcbiAgICAgIHMgPSBgMCR7c31gO1xuICAgIH1cbiAgICBzID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VGbG9hdChzKSwgMCksIE1BWF9QQ1QpO1xuICB9XG4gIGlmIChsID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKGZvcm1hdCAhPT0gXCJoc2xcIikge1xuICAgICAgbCA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsWzBdID09PSBcIi5cIikge1xuICAgICAgbCA9IGAwJHtsfWA7XG4gICAgfVxuICAgIGwgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUZsb2F0KGwpLCAwKSwgTUFYX1BDVCk7XG4gIH1cbiAgaWYgKGFscGhhICE9PSBjb25zdGFudC5OT05FIHx8IGZvcm1hdCAhPT0gXCJoc2xcIikge1xuICAgIGFscGhhID0gcGFyc2VBbHBoYShhbHBoYSk7XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gXCJoc2xcIikge1xuICAgIHJldHVybiBbZm9ybWF0LCBoLCBzLCBsLCBhbHBoYV07XG4gIH1cbiAgY29uc3QgbGwgPSBsIC8gTUFYX1BDVDtcbiAgY29uc3Qgc2EgPSBzIC8gTUFYX1BDVCAqIE1hdGgubWluKGxsLCAxIC0gbGwpO1xuICBjb25zdCByayA9IGggLyBERUcgKiBET1ogJSBET1o7XG4gIGNvbnN0IGdrID0gKDggKyBoIC8gREVHICogRE9aKSAlIERPWjtcbiAgY29uc3QgYmsgPSAoNCArIGggLyBERUcgKiBET1opICUgRE9aO1xuICBjb25zdCByID0gbGwgLSBzYSAqIE1hdGgubWF4KC0xLCBNYXRoLm1pbihyayAtIFRSSUEsIFRSSUEgKiogUE9XX1NRUiAtIHJrLCAxKSk7XG4gIGNvbnN0IGcgPSBsbCAtIHNhICogTWF0aC5tYXgoLTEsIE1hdGgubWluKGdrIC0gVFJJQSwgVFJJQSAqKiBQT1dfU1FSIC0gZ2ssIDEpKTtcbiAgY29uc3QgYiA9IGxsIC0gc2EgKiBNYXRoLm1heCgtMSwgTWF0aC5taW4oYmsgLSBUUklBLCBUUklBICoqIFBPV19TUVIgLSBiaywgMSkpO1xuICByZXR1cm4gW1xuICAgIFwicmdiXCIsXG4gICAgTWF0aC5taW4oTWF0aC5tYXgodXRpbC5yb3VuZFRvUHJlY2lzaW9uKHIgKiBNQVhfUkdCLCBPQ1QpLCAwKSwgTUFYX1JHQiksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgodXRpbC5yb3VuZFRvUHJlY2lzaW9uKGcgKiBNQVhfUkdCLCBPQ1QpLCAwKSwgTUFYX1JHQiksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgodXRpbC5yb3VuZFRvUHJlY2lzaW9uKGIgKiBNQVhfUkdCLCBPQ1QpLCAwKSwgTUFYX1JHQiksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCBwYXJzZUh3YiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKCFSRUdfSFdCLnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJod2JcIjpcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFssIHZhbF0gPSB2YWx1ZS5tYXRjaChSRUdfSFdCKTtcbiAgbGV0IFtoLCB3LCBiLCBhbHBoYV0gPSB2YWwucmVwbGFjZShcIi9cIiwgXCIgXCIpLnNwbGl0KC9cXHMrLyk7XG4gIGlmIChoID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKGZvcm1hdCAhPT0gXCJod2JcIikge1xuICAgICAgaCA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGggPSBhbmdsZVRvRGVnKGgpO1xuICB9XG4gIGlmICh3ID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKGZvcm1hdCAhPT0gXCJod2JcIikge1xuICAgICAgdyA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3WzBdID09PSBcIi5cIikge1xuICAgICAgdyA9IGAwJHt3fWA7XG4gICAgfVxuICAgIHcgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUZsb2F0KHcpLCAwKSwgTUFYX1BDVCkgLyBNQVhfUENUO1xuICB9XG4gIGlmIChiID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKGZvcm1hdCAhPT0gXCJod2JcIikge1xuICAgICAgYiA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChiWzBdID09PSBcIi5cIikge1xuICAgICAgYiA9IGAwJHtifWA7XG4gICAgfVxuICAgIGIgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUZsb2F0KGIpLCAwKSwgTUFYX1BDVCkgLyBNQVhfUENUO1xuICB9XG4gIGlmIChhbHBoYSAhPT0gY29uc3RhbnQuTk9ORSB8fCBmb3JtYXQgIT09IFwiaHdiXCIpIHtcbiAgICBhbHBoYSA9IHBhcnNlQWxwaGEoYWxwaGEpO1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFwiaHdiXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZm9ybWF0LFxuICAgICAgaCxcbiAgICAgIHcgPT09IGNvbnN0YW50Lk5PTkUgPyB3IDogdyAqIE1BWF9QQ1QsXG4gICAgICBiID09PSBjb25zdGFudC5OT05FID8gYiA6IGIgKiBNQVhfUENULFxuICAgICAgYWxwaGFcbiAgICBdO1xuICB9XG4gIGlmICh3ICsgYiA+PSAxKSB7XG4gICAgY29uc3QgdiA9IHV0aWwucm91bmRUb1ByZWNpc2lvbihcbiAgICAgIHcgLyAodyArIGIpICogTUFYX1JHQixcbiAgICAgIE9DVFxuICAgICk7XG4gICAgcmV0dXJuIFtcInJnYlwiLCB2LCB2LCB2LCBhbHBoYV07XG4gIH1cbiAgY29uc3QgZmFjdG9yID0gKDEgLSB3IC0gYikgLyBNQVhfUkdCO1xuICBsZXQgWywgcnIsIGdnLCBiYl0gPSBwYXJzZUhzbChgaHNsKCR7aH0gMTAwIDUwKWApO1xuICByciA9IHV0aWwucm91bmRUb1ByZWNpc2lvbihcbiAgICAocnIgKiBmYWN0b3IgKyB3KSAqIE1BWF9SR0IsXG4gICAgT0NUXG4gICk7XG4gIGdnID0gdXRpbC5yb3VuZFRvUHJlY2lzaW9uKFxuICAgIChnZyAqIGZhY3RvciArIHcpICogTUFYX1JHQixcbiAgICBPQ1RcbiAgKTtcbiAgYmIgPSB1dGlsLnJvdW5kVG9QcmVjaXNpb24oXG4gICAgKGJiICogZmFjdG9yICsgdykgKiBNQVhfUkdCLFxuICAgIE9DVFxuICApO1xuICByZXR1cm4gW1xuICAgIFwicmdiXCIsXG4gICAgTWF0aC5taW4oTWF0aC5tYXgocnIsIDApLCBNQVhfUkdCKSxcbiAgICBNYXRoLm1pbihNYXRoLm1heChnZywgMCksIE1BWF9SR0IpLFxuICAgIE1hdGgubWluKE1hdGgubWF4KGJiLCAwKSwgTUFYX1JHQiksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCBwYXJzZUxhYiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKCFSRUdfTEFCLnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IENPRUZfUENUID0gMS4yNTtcbiAgY29uc3QgQ09ORF9QT1cgPSA4O1xuICBjb25zdCBbLCB2YWxdID0gdmFsdWUubWF0Y2goUkVHX0xBQik7XG4gIGxldCBbbCwgYSwgYiwgYWxwaGFdID0gdmFsLnJlcGxhY2UoXCIvXCIsIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAobCA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBsID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxbMF0gPT09IFwiLlwiKSB7XG4gICAgICBsID0gYDAke2x9YDtcbiAgICB9XG4gICAgaWYgKGwuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBsID0gcGFyc2VGbG9hdChsKTtcbiAgICAgIGlmIChsID4gTUFYX1BDVCkge1xuICAgICAgICBsID0gTUFYX1BDVDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IHBhcnNlRmxvYXQobCk7XG4gICAgfVxuICAgIGlmIChsIDwgMCkge1xuICAgICAgbCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChhID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKCFSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIGEgPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYVswXSA9PT0gXCIuXCIpIHtcbiAgICAgIGEgPSBgMCR7YX1gO1xuICAgIH1cbiAgICBpZiAoYS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgIGEgPSBwYXJzZUZsb2F0KGEpICogQ09FRl9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuICAgIH1cbiAgfVxuICBpZiAoYiA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGIuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBiID0gcGFyc2VGbG9hdChiKSAqIENPRUZfUENUO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gcGFyc2VGbG9hdChiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFscGhhICE9PSBjb25zdGFudC5OT05FIHx8ICFSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICBhbHBoYSA9IHBhcnNlQWxwaGEoYWxwaGEpO1xuICB9XG4gIGlmIChSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJsYWJcIixcbiAgICAgIGwgPT09IGNvbnN0YW50Lk5PTkUgPyBsIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGwsIEhFWCksXG4gICAgICBhID09PSBjb25zdGFudC5OT05FID8gYSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihhLCBIRVgpLFxuICAgICAgYiA9PT0gY29uc3RhbnQuTk9ORSA/IGIgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYiwgSEVYKSxcbiAgICAgIGFscGhhXG4gICAgXTtcbiAgfVxuICBjb25zdCBmbCA9IChsICsgSEVYKSAvIExBQl9MO1xuICBjb25zdCBmYSA9IGEgLyBMQUJfQSArIGZsO1xuICBjb25zdCBmYiA9IGZsIC0gYiAvIExBQl9CO1xuICBjb25zdCBwb3dGbCA9IE1hdGgucG93KGZsLCBQT1dfQ1VCRSk7XG4gIGNvbnN0IHBvd0ZhID0gTWF0aC5wb3coZmEsIFBPV19DVUJFKTtcbiAgY29uc3QgcG93RmIgPSBNYXRoLnBvdyhmYiwgUE9XX0NVQkUpO1xuICBjb25zdCB4eXogPSBbXG4gICAgcG93RmEgPiBMQUJfRVBTSUxPTiA/IHBvd0ZhIDogKGZhICogTEFCX0wgLSBIRVgpIC8gTEFCX0tBUFBBLFxuICAgIGwgPiBDT05EX1BPVyA/IHBvd0ZsIDogbCAvIExBQl9LQVBQQSxcbiAgICBwb3dGYiA+IExBQl9FUFNJTE9OID8gcG93RmIgOiAoZmIgKiBMQUJfTCAtIEhFWCkgLyBMQUJfS0FQUEFcbiAgXTtcbiAgY29uc3QgW3gsIHksIHpdID0geHl6Lm1hcCgodmFsMiwgaSkgPT4gdmFsMiAqIEQ1MFtpXSk7XG4gIHJldHVybiBbXG4gICAgXCJ4eXotZDUwXCIsXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHgsIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHksIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHosIEhFWCksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCBwYXJzZUxjaCA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKCFSRUdfTENILnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IENPRUZfUENUID0gMS41O1xuICBjb25zdCBbLCB2YWxdID0gdmFsdWUubWF0Y2goUkVHX0xDSCk7XG4gIGxldCBbbCwgYywgaCwgYWxwaGFdID0gdmFsLnJlcGxhY2UoXCIvXCIsIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAobCA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBsID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxbMF0gPT09IFwiLlwiKSB7XG4gICAgICBsID0gYDAke2x9YDtcbiAgICB9XG4gICAgbCA9IHBhcnNlRmxvYXQobCk7XG4gICAgaWYgKGwgPCAwKSB7XG4gICAgICBsID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGMgPT09IGNvbnN0YW50Lk5PTkUpIHtcbiAgICBpZiAoIVJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgYyA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChjWzBdID09PSBcIi5cIikge1xuICAgICAgYyA9IGAwJHtjfWA7XG4gICAgfVxuICAgIGlmIChjLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgYyA9IHBhcnNlRmxvYXQoYykgKiBDT0VGX1BDVDtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IHBhcnNlRmxvYXQoYyk7XG4gICAgfVxuICB9XG4gIGlmIChoID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKCFSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoID0gYW5nbGVUb0RlZyhoKTtcbiAgfVxuICBpZiAoYWxwaGEgIT09IGNvbnN0YW50Lk5PTkUgfHwgIVJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgIGFscGhhID0gcGFyc2VBbHBoYShhbHBoYSk7XG4gIH1cbiAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgIHJldHVybiBbXG4gICAgICBcImxjaFwiLFxuICAgICAgbCA9PT0gY29uc3RhbnQuTk9ORSA/IGwgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24obCwgSEVYKSxcbiAgICAgIGMgPT09IGNvbnN0YW50Lk5PTkUgPyBjIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGMsIEhFWCksXG4gICAgICBoID09PSBjb25zdGFudC5OT05FID8gaCA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihoLCBIRVgpLFxuICAgICAgYWxwaGFcbiAgICBdO1xuICB9XG4gIGNvbnN0IGEgPSBjICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAoREVHICogSEFMRikpO1xuICBjb25zdCBiID0gYyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gKERFRyAqIEhBTEYpKTtcbiAgY29uc3QgWywgeCwgeSwgel0gPSBwYXJzZUxhYihgbGFiKCR7bH0gJHthfSAke2J9KWApO1xuICByZXR1cm4gW1xuICAgIFwieHl6LWQ1MFwiLFxuICAgIHV0aWwucm91bmRUb1ByZWNpc2lvbih4LCBIRVgpLFxuICAgIHV0aWwucm91bmRUb1ByZWNpc2lvbih5LCBIRVgpLFxuICAgIHV0aWwucm91bmRUb1ByZWNpc2lvbih6LCBIRVgpLFxuICAgIGFscGhhXG4gIF07XG59O1xuY29uc3QgcGFyc2VPa2xhYiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKCFSRUdfT0tMQUIudGVzdCh2YWx1ZSkpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBWQUxfTUlYOiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBjb25zdGFudC5WQUxfU1BFQzoge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgQ09FRl9QQ1QgPSAwLjQ7XG4gIGNvbnN0IFssIHZhbF0gPSB2YWx1ZS5tYXRjaChSRUdfT0tMQUIpO1xuICBsZXQgW2wsIGEsIGIsIGFscGhhXSA9IHZhbC5yZXBsYWNlKFwiL1wiLCBcIiBcIikuc3BsaXQoL1xccysvKTtcbiAgaWYgKGwgPT09IGNvbnN0YW50Lk5PTkUpIHtcbiAgICBpZiAoIVJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgbCA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsWzBdID09PSBcIi5cIikge1xuICAgICAgbCA9IGAwJHtsfWA7XG4gICAgfVxuICAgIGlmIChsLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgbCA9IHBhcnNlRmxvYXQobCkgLyBNQVhfUENUO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gcGFyc2VGbG9hdChsKTtcbiAgICB9XG4gICAgaWYgKGwgPCAwKSB7XG4gICAgICBsID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGEgPT09IGNvbnN0YW50Lk5PTkUpIHtcbiAgICBpZiAoIVJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgYSA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhWzBdID09PSBcIi5cIikge1xuICAgICAgYSA9IGAwJHthfWA7XG4gICAgfVxuICAgIGlmIChhLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgYSA9IHBhcnNlRmxvYXQoYSkgKiBDT0VGX1BDVCAvIE1BWF9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuICAgIH1cbiAgfVxuICBpZiAoYiA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGIuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBiID0gcGFyc2VGbG9hdChiKSAqIENPRUZfUENUIC8gTUFYX1BDVDtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHBhcnNlRmxvYXQoYik7XG4gICAgfVxuICB9XG4gIGlmIChhbHBoYSAhPT0gY29uc3RhbnQuTk9ORSB8fCAhUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgYWxwaGEgPSBwYXJzZUFscGhhKGFscGhhKTtcbiAgfVxuICBpZiAoUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwib2tsYWJcIixcbiAgICAgIGwgPT09IGNvbnN0YW50Lk5PTkUgPyBsIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGwsIEhFWCksXG4gICAgICBhID09PSBjb25zdGFudC5OT05FID8gYSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihhLCBIRVgpLFxuICAgICAgYiA9PT0gY29uc3RhbnQuTk9ORSA/IGIgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYiwgSEVYKSxcbiAgICAgIGFscGhhXG4gICAgXTtcbiAgfVxuICBjb25zdCBsbXMgPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX09LTEFCX1RPX0xNUywgW1xuICAgIGwsXG4gICAgYSxcbiAgICBiXG4gIF0pO1xuICBjb25zdCB4eXpMbXMgPSBsbXMubWFwKChjKSA9PiBNYXRoLnBvdyhjLCBQT1dfQ1VCRSkpO1xuICBjb25zdCBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX0xNU19UT19YWVosIHh5ekxtcywgdHJ1ZSk7XG4gIHJldHVybiBbXG4gICAgXCJ4eXotZDY1XCIsXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHgsIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHksIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHosIEhFWCksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCBwYXJzZU9rbGNoID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGZvcm1hdCB9ID0gb3B0O1xuICBpZiAoIVJFR19PS0xDSC50ZXN0KHZhbHVlKSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFZBTF9NSVg6IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjYXNlIGNvbnN0YW50LlZBTF9TUEVDOiB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBDT0VGX1BDVCA9IDAuNDtcbiAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19PS0xDSCk7XG4gIGxldCBbbCwgYywgaCwgYWxwaGFdID0gdmFsLnJlcGxhY2UoXCIvXCIsIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAobCA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBsID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxbMF0gPT09IFwiLlwiKSB7XG4gICAgICBsID0gYDAke2x9YDtcbiAgICB9XG4gICAgaWYgKGwuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBsID0gcGFyc2VGbG9hdChsKSAvIE1BWF9QQ1Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBwYXJzZUZsb2F0KGwpO1xuICAgIH1cbiAgICBpZiAobCA8IDApIHtcbiAgICAgIGwgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoYyA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGlmICghUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBjID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNbMF0gPT09IFwiLlwiKSB7XG4gICAgICBjID0gYDAke2N9YDtcbiAgICB9XG4gICAgaWYgKGMuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICBjID0gcGFyc2VGbG9hdChjKSAqIENPRUZfUENUIC8gTUFYX1BDVDtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IHBhcnNlRmxvYXQoYyk7XG4gICAgfVxuICAgIGlmIChjIDwgMCkge1xuICAgICAgYyA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChoID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgaWYgKCFSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIGggPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoID0gYW5nbGVUb0RlZyhoKTtcbiAgfVxuICBpZiAoYWxwaGEgIT09IGNvbnN0YW50Lk5PTkUgfHwgIVJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgIGFscGhhID0gcGFyc2VBbHBoYShhbHBoYSk7XG4gIH1cbiAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgIHJldHVybiBbXG4gICAgICBcIm9rbGNoXCIsXG4gICAgICBsID09PSBjb25zdGFudC5OT05FID8gbCA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihsLCBIRVgpLFxuICAgICAgYyA9PT0gY29uc3RhbnQuTk9ORSA/IGMgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYywgSEVYKSxcbiAgICAgIGggPT09IGNvbnN0YW50Lk5PTkUgPyBoIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGgsIEhFWCksXG4gICAgICBhbHBoYVxuICAgIF07XG4gIH1cbiAgY29uc3QgYSA9IGMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIChERUcgKiBIQUxGKSk7XG4gIGNvbnN0IGIgPSBjICogTWF0aC5zaW4oaCAqIE1hdGguUEkgLyAoREVHICogSEFMRikpO1xuICBjb25zdCBsbXMgPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX09LTEFCX1RPX0xNUywgW2wsIGEsIGJdKTtcbiAgY29uc3QgeHl6TG1zID0gbG1zLm1hcCgoY2wpID0+IE1hdGgucG93KGNsLCBQT1dfQ1VCRSkpO1xuICBjb25zdCBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX0xNU19UT19YWVosIHh5ekxtcywgdHJ1ZSk7XG4gIHJldHVybiBbXG4gICAgXCJ4eXotZDY1XCIsXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHgsIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHksIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHosIEhFWCksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCBwYXJzZUNvbG9yRnVuYyA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBjb2xvclNwYWNlLCBkNTAsIGZvcm1hdCB9ID0gb3B0O1xuICBpZiAoIVJFR19GTl9DT0xPUi50ZXN0KHZhbHVlKSkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFZBTF9NSVg6IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjYXNlIGNvbnN0YW50LlZBTF9TUEVDOiB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbLCB2YWxdID0gdmFsdWUubWF0Y2goUkVHX0ZOX0NPTE9SKTtcbiAgbGV0IFtjcywgdjEsIHYyLCB2MywgdjRdID0gdmFsLnJlcGxhY2UoXCIvXCIsIFwiIFwiKS5zcGxpdCgvXFxzKy8pO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKGNzID09PSBcInh5elwiKSB7XG4gICAgY3MgPSBcInh5ei1kNjVcIjtcbiAgfVxuICBpZiAodjEgPT09IGNvbnN0YW50Lk5PTkUpIHtcbiAgICByID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodjFbMF0gPT09IFwiLlwiKSB7XG4gICAgICB2MSA9IGAwJHt2MX1gO1xuICAgIH1cbiAgICByID0gdjEuZW5kc1dpdGgoXCIlXCIpID8gcGFyc2VGbG9hdCh2MSkgLyBNQVhfUENUIDogcGFyc2VGbG9hdCh2MSk7XG4gIH1cbiAgaWYgKHYyID09PSBjb25zdGFudC5OT05FKSB7XG4gICAgZyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHYyWzBdID09PSBcIi5cIikge1xuICAgICAgdjIgPSBgMCR7djJ9YDtcbiAgICB9XG4gICAgZyA9IHYyLmVuZHNXaXRoKFwiJVwiKSA/IHBhcnNlRmxvYXQodjIpIC8gTUFYX1BDVCA6IHBhcnNlRmxvYXQodjIpO1xuICB9XG4gIGlmICh2MyA9PT0gY29uc3RhbnQuTk9ORSkge1xuICAgIGIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmICh2M1swXSA9PT0gXCIuXCIpIHtcbiAgICAgIHYzID0gYDAke3YzfWA7XG4gICAgfVxuICAgIGIgPSB2My5lbmRzV2l0aChcIiVcIikgPyBwYXJzZUZsb2F0KHYzKSAvIE1BWF9QQ1QgOiBwYXJzZUZsb2F0KHYzKTtcbiAgfVxuICBjb25zdCBhbHBoYSA9IHBhcnNlQWxwaGEodjQpO1xuICBpZiAoUkVHX1NQRUMudGVzdChmb3JtYXQpIHx8IGZvcm1hdCA9PT0gVkFMX01JWCAmJiBjcyA9PT0gY29sb3JTcGFjZSkge1xuICAgIHJldHVybiBbXG4gICAgICBjcyxcbiAgICAgIHYxID09PSBjb25zdGFudC5OT05FID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihyLCBERUMpLFxuICAgICAgdjIgPT09IGNvbnN0YW50Lk5PTkUgPyBjb25zdGFudC5OT05FIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGcsIERFQyksXG4gICAgICB2MyA9PT0gY29uc3RhbnQuTk9ORSA/IGNvbnN0YW50Lk5PTkUgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYiwgREVDKSxcbiAgICAgIHY0ID09PSBjb25zdGFudC5OT05FID8gY29uc3RhbnQuTk9ORSA6IGFscGhhXG4gICAgXTtcbiAgfVxuICBsZXQgeCwgeSwgejtcbiAgaWYgKGNzID09PSBcInNyZ2JcIikge1xuICAgIFt4LCB5LCB6XSA9IGNvbnZlcnRSZ2JUb1h5eihbciAqIE1BWF9SR0IsIGcgKiBNQVhfUkdCLCBiICogTUFYX1JHQl0pO1xuICAgIGlmIChkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q2NV9UT19ENTAsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3MgPT09IFwic3JnYi1saW5lYXJcIikge1xuICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfTF9SR0JfVE9fWFlaLCBbciwgZywgYl0pO1xuICAgIGlmIChkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q2NV9UT19ENTAsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3MgPT09IFwiZGlzcGxheS1wM1wiKSB7XG4gICAgY29uc3QgbGluZWFyUmdiID0gY29udmVydFJnYlRvTGluZWFyUmdiKFtcbiAgICAgIHIgKiBNQVhfUkdCLFxuICAgICAgZyAqIE1BWF9SR0IsXG4gICAgICBiICogTUFYX1JHQlxuICAgIF0pO1xuICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfUDNfVE9fWFlaLCBsaW5lYXJSZ2IpO1xuICAgIGlmIChkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q2NV9UT19ENTAsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3MgPT09IFwicmVjMjAyMFwiKSB7XG4gICAgY29uc3QgQUxQSEEgPSAxLjA5OTI5NjgyNjgwOTQ0O1xuICAgIGNvbnN0IEJFVEEgPSAwLjAxODA1Mzk2ODUxMDgwNztcbiAgICBjb25zdCBSRUNfQ09FRiA9IDAuNDU7XG4gICAgY29uc3QgcmdiID0gW3IsIGcsIGJdLm1hcCgoYykgPT4ge1xuICAgICAgbGV0IGNsO1xuICAgICAgaWYgKGMgPCBCRVRBICogUkVDX0NPRUYgKiBERUMpIHtcbiAgICAgICAgY2wgPSBjIC8gKFJFQ19DT0VGICogREVDKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsID0gTWF0aC5wb3coKGMgKyBBTFBIQSAtIDEpIC8gQUxQSEEsIDEgLyBSRUNfQ09FRik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2w7XG4gICAgfSk7XG4gICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KE1BVFJJWF9SRUMyMDIwX1RPX1hZWiwgcmdiKTtcbiAgICBpZiAoZDUwKSB7XG4gICAgICBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoXG4gICAgICAgIE1BVFJJWF9ENjVfVE9fRDUwLFxuICAgICAgICBbeCwgeSwgel0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNzID09PSBcImE5OC1yZ2JcIikge1xuICAgIGNvbnN0IFBPV19BOTggPSA1NjMgLyAyNTY7XG4gICAgY29uc3QgcmdiID0gW3IsIGcsIGJdLm1hcCgoYykgPT4ge1xuICAgICAgY29uc3QgY2wgPSBNYXRoLnBvdyhjLCBQT1dfQTk4KTtcbiAgICAgIHJldHVybiBjbDtcbiAgICB9KTtcbiAgICBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX0E5OF9UT19YWVosIHJnYik7XG4gICAgaWYgKGQ1MCkge1xuICAgICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KFxuICAgICAgICBNQVRSSVhfRDY1X1RPX0Q1MCxcbiAgICAgICAgW3gsIHksIHpdLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjcyA9PT0gXCJwcm9waG90by1yZ2JcIikge1xuICAgIGNvbnN0IFBPV19QUk9QSE9UTyA9IDEuODtcbiAgICBjb25zdCByZ2IgPSBbciwgZywgYl0ubWFwKChjKSA9PiB7XG4gICAgICBsZXQgY2w7XG4gICAgICBpZiAoYyA+IDEgLyAoSEVYICogRFVPKSkge1xuICAgICAgICBjbCA9IE1hdGgucG93KGMsIFBPV19QUk9QSE9UTyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbCA9IGMgLyBIRVg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2w7XG4gICAgfSk7XG4gICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KE1BVFJJWF9QUk9QSE9UT19UT19YWVpfRDUwLCByZ2IpO1xuICAgIGlmICghZDUwKSB7XG4gICAgICBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoXG4gICAgICAgIE1BVFJJWF9ENTBfVE9fRDY1LFxuICAgICAgICBbeCwgeSwgel0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKC9eeHl6KD86LWQoPzo1MHw2NSkpPyQvLnRlc3QoY3MpKSB7XG4gICAgW3gsIHksIHpdID0gW3IsIGcsIGJdO1xuICAgIGlmIChjcyA9PT0gXCJ4eXotZDUwXCIpIHtcbiAgICAgIGlmICghZDUwKSB7XG4gICAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfRDUwX1RPX0Q2NSwgW3gsIHksIHpdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGQ1MCkge1xuICAgICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KE1BVFJJWF9ENjVfVE9fRDUwLCBbeCwgeSwgel0sIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIGQ1MCA/IFwieHl6LWQ1MFwiIDogXCJ4eXotZDY1XCIsXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHgsIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHksIEhFWCksXG4gICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHosIEhFWCksXG4gICAgZm9ybWF0ID09PSBWQUxfTUlYICYmIHY0ID09PSBjb25zdGFudC5OT05FID8gY29uc3RhbnQuTk9ORSA6IGFscGhhXG4gIF07XG59O1xuY29uc3QgcGFyc2VDb2xvclZhbHVlID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZDUwLCBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKCFSRUdfQ09MT1IudGVzdCh2YWx1ZSkpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBWQUxfTUlYOiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBjb25zdGFudC5WQUxfU1BFQzoge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHgsIHksIHosIGFscGhhO1xuICBpZiAoUkVHX0NVUlJFTlQudGVzdCh2YWx1ZSkpIHtcbiAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfQ09NUCkge1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gICAgeiA9IDA7XG4gICAgYWxwaGEgPSAwO1xuICB9IGVsc2UgaWYgKC9eW2Etel0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE5BTUVEX0NPTE9SUywgdmFsdWUpKSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbciwgZywgYl0gPSBOQU1FRF9DT0xPUlNbdmFsdWVdO1xuICAgICAgYWxwaGEgPSAxO1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX0NPTVApIHtcbiAgICAgICAgcmV0dXJuIFtcInJnYlwiLCByLCBnLCBiLCBhbHBoYV07XG4gICAgICB9XG4gICAgICBbeCwgeSwgel0gPSBjb252ZXJ0UmdiVG9YeXooW3IsIGcsIGJdLCB0cnVlKTtcbiAgICAgIGlmIChkNTApIHtcbiAgICAgICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KFxuICAgICAgICAgIE1BVFJJWF9ENjVfVE9fRDUwLFxuICAgICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9DT01QKSB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgICBpZiAodmFsdWUgPT09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQgPT09IFZBTF9NSVgpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICAgIHogPSAwO1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZVswXSA9PT0gXCIjXCIpIHtcbiAgICBpZiAoUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICBjb25zdCByZ2IgPSBjb252ZXJ0SGV4VG9SZ2IodmFsdWUpO1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAuLi5yZ2JdO1xuICAgIH1cbiAgICBbeCwgeSwgeiwgYWxwaGFdID0gY29udmVydEhleFRvWHl6KHZhbHVlKTtcbiAgICBpZiAoZDUwKSB7XG4gICAgICBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoXG4gICAgICAgIE1BVFJJWF9ENjVfVE9fRDUwLFxuICAgICAgICBbeCwgeSwgel0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJsYWJcIikpIHtcbiAgICBpZiAoUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICByZXR1cm4gcGFyc2VMYWIodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlTGFiKHZhbHVlKTtcbiAgICBpZiAoIWQ1MCkge1xuICAgICAgW3gsIHksIHpdID0gdHJhbnNmb3JtTWF0cml4KFxuICAgICAgICBNQVRSSVhfRDUwX1RPX0Q2NSxcbiAgICAgICAgW3gsIHksIHpdLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwibGNoXCIpKSB7XG4gICAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHBhcnNlTGNoKHZhbHVlLCBvcHQpO1xuICAgIH1cbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUxjaCh2YWx1ZSk7XG4gICAgaWYgKCFkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q1MF9UT19ENjUsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChcIm9rbGFiXCIpKSB7XG4gICAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHBhcnNlT2tsYWIodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlT2tsYWIodmFsdWUpO1xuICAgIGlmIChkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q2NV9UT19ENTAsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChcIm9rbGNoXCIpKSB7XG4gICAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIHBhcnNlT2tsY2godmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlT2tsY2godmFsdWUpO1xuICAgIGlmIChkNTApIHtcbiAgICAgIFt4LCB5LCB6XSA9IHRyYW5zZm9ybU1hdHJpeChcbiAgICAgICAgTUFUUklYX0Q2NV9UT19ENTAsXG4gICAgICAgIFt4LCB5LCB6XSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHIsIGcsIGI7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICAgIFssIHIsIGcsIGIsIGFscGhhXSA9IHBhcnNlSHNsKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJod2JcIikpIHtcbiAgICAgIFssIHIsIGcsIGIsIGFscGhhXSA9IHBhcnNlSHdiKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgWywgciwgZywgYiwgYWxwaGFdID0gcGFyc2VSZ2IodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIGlmIChSRUdfU1BFQy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwicmdiXCIsXG4gICAgICAgIE1hdGgucm91bmQociksXG4gICAgICAgIE1hdGgucm91bmQoZyksXG4gICAgICAgIE1hdGgucm91bmQoYiksXG4gICAgICAgIGFscGhhXG4gICAgICBdO1xuICAgIH1cbiAgICBbeCwgeSwgel0gPSBjb252ZXJ0UmdiVG9YeXooW3IsIGcsIGJdKTtcbiAgICBpZiAoZDUwKSB7XG4gICAgICBbeCwgeSwgel0gPSB0cmFuc2Zvcm1NYXRyaXgoXG4gICAgICAgIE1BVFJJWF9ENjVfVE9fRDUwLFxuICAgICAgICBbeCwgeSwgel0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbXG4gICAgZDUwID8gXCJ4eXotZDUwXCIgOiBcInh5ei1kNjVcIixcbiAgICB1dGlsLnJvdW5kVG9QcmVjaXNpb24oeCwgSEVYKSxcbiAgICB1dGlsLnJvdW5kVG9QcmVjaXNpb24oeSwgSEVYKSxcbiAgICB1dGlsLnJvdW5kVG9QcmVjaXNpb24oeiwgSEVYKSxcbiAgICBhbHBoYVxuICBdO1xufTtcbmNvbnN0IHJlc29sdmVDb2xvclZhbHVlID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY29sb3JTcGFjZSwgZm9ybWF0IH0gPSBvcHQ7XG4gIGlmICghUkVHX0NPTE9SLnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBjcywgciwgZywgYiwgYWxwaGE7XG4gIGlmIChSRUdfQ1VSUkVOVC50ZXN0KHZhbHVlKSkge1xuICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9TUEVDKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHIgPSAwO1xuICAgIGcgPSAwO1xuICAgIGIgPSAwO1xuICAgIGFscGhhID0gMDtcbiAgfSBlbHNlIGlmICgvXlthLXpdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChOQU1FRF9DT0xPUlMsIHZhbHVlKSkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgW3IsIGcsIGJdID0gTkFNRURfQ09MT1JTW3ZhbHVlXTtcbiAgICAgIGFscGhhID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0ID09PSBWQUxfTUlYKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHIgPSAwO1xuICAgICAgZyA9IDA7XG4gICAgICBiID0gMDtcbiAgICAgIGFscGhhID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWVbMF0gPT09IFwiI1wiKSB7XG4gICAgW3IsIGcsIGIsIGFscGhhXSA9IGNvbnZlcnRIZXhUb1JnYih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgIFssIHIsIGcsIGIsIGFscGhhXSA9IHBhcnNlUmdiKHZhbHVlLCBvcHQpO1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbLCByLCBnLCBiLCBhbHBoYV0gPSBwYXJzZUhzbCh2YWx1ZSwgb3B0KTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiaHdiXCIpKSB7XG4gICAgWywgciwgZywgYiwgYWxwaGFdID0gcGFyc2VId2IodmFsdWUsIG9wdCk7XG4gIH0gZWxzZSBpZiAoL15sKD86YWJ8Y2gpLy50ZXN0KHZhbHVlKSkge1xuICAgIGxldCB4LCB5LCB6O1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwibGFiXCIpKSB7XG4gICAgICBbY3MsIHgsIHksIHosIGFscGhhXSA9IHBhcnNlTGFiKHZhbHVlLCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbY3MsIHgsIHksIHosIGFscGhhXSA9IHBhcnNlTGNoKHZhbHVlLCBvcHQpO1xuICAgIH1cbiAgICBpZiAoUkVHX1NQRUMudGVzdChmb3JtYXQpKSB7XG4gICAgICByZXR1cm4gW2NzLCB4LCB5LCB6LCBhbHBoYV07XG4gICAgfVxuICAgIFtyLCBnLCBiLCBhbHBoYV0gPSBjb252ZXJ0WHl6RDUwVG9SZ2IoW1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgYWxwaGFcbiAgICBdKTtcbiAgfSBlbHNlIGlmICgvXm9rbCg/OmFifGNoKS8udGVzdCh2YWx1ZSkpIHtcbiAgICBsZXQgeCwgeSwgejtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcIm9rbGFiXCIpKSB7XG4gICAgICBbY3MsIHgsIHksIHosIGFscGhhXSA9IHBhcnNlT2tsYWIodmFsdWUsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtjcywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VPa2xjaCh2YWx1ZSwgb3B0KTtcbiAgICB9XG4gICAgaWYgKFJFR19TUEVDLnRlc3QoZm9ybWF0KSkge1xuICAgICAgcmV0dXJuIFtjcywgeCwgeSwgeiwgYWxwaGFdO1xuICAgIH1cbiAgICBbciwgZywgYiwgYWxwaGFdID0gY29udmVydFh5elRvUmdiKFtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeixcbiAgICAgIGFscGhhXG4gICAgXSk7XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gVkFMX01JWCAmJiBjb2xvclNwYWNlID09PSBcInNyZ2JcIikge1xuICAgIHJldHVybiBbXG4gICAgICBcInNyZ2JcIixcbiAgICAgIHIgLyBNQVhfUkdCLFxuICAgICAgZyAvIE1BWF9SR0IsXG4gICAgICBiIC8gTUFYX1JHQixcbiAgICAgIGFscGhhXG4gICAgXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIFwicmdiXCIsXG4gICAgTWF0aC5yb3VuZChyKSxcbiAgICBNYXRoLnJvdW5kKGcpLFxuICAgIE1hdGgucm91bmQoYiksXG4gICAgYWxwaGFcbiAgXTtcbn07XG5jb25zdCByZXNvbHZlQ29sb3JGdW5jID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY29sb3JTcGFjZSwgZm9ybWF0IH0gPSBvcHQ7XG4gIGlmICghUkVHX0ZOX0NPTE9SLnRlc3QodmFsdWUpKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgVkFMX01JWDoge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX1NQRUM6IHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFtjcywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvckZ1bmModmFsdWUsIG9wdCk7XG4gIGlmIChSRUdfU1BFQy50ZXN0KGZvcm1hdCkgfHwgZm9ybWF0ID09PSBWQUxfTUlYICYmIGNzID09PSBjb2xvclNwYWNlKSB7XG4gICAgcmV0dXJuIFtjcywgeCwgeSwgeiwgYWxwaGFdO1xuICB9XG4gIGNvbnN0IFtyLCBnLCBiXSA9IGNvbnZlcnRYeXpUb1JnYihbXG4gICAgeCxcbiAgICB5LFxuICAgIHpcbiAgXSwgdHJ1ZSk7XG4gIHJldHVybiBbXCJyZ2JcIiwgciwgZywgYiwgYWxwaGFdO1xufTtcbmNvbnN0IGNvbnZlcnRDb2xvclRvTGluZWFyUmdiID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGNvbG9yU3BhY2UsIGZvcm1hdCB9ID0gb3B0O1xuICBsZXQgY3MsIHIsIGcsIGIsIGFscGhhLCB4LCB5LCB6O1xuICBpZiAoZm9ybWF0ID09PSBWQUxfTUlYKSB7XG4gICAgbGV0IHh5ejtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JGdW5jKHZhbHVlLCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4eXogPSBwYXJzZUNvbG9yVmFsdWUodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIGlmICh4eXogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB4eXo7XG4gICAgfVxuICAgIFtjcywgeCwgeSwgeiwgYWxwaGFdID0geHl6O1xuICAgIGlmIChjcyA9PT0gY29sb3JTcGFjZSkge1xuICAgICAgcmV0dXJuIFt4LCB5LCB6LCBhbHBoYV07XG4gICAgfVxuICAgIFtyLCBnLCBiXSA9IHRyYW5zZm9ybU1hdHJpeChNQVRSSVhfWFlaX1RPX0xfUkdCLCBbeCwgeSwgel0sIHRydWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19GTl9DT0xPUik7XG4gICAgY29uc3QgW2NzMl0gPSB2YWwucmVwbGFjZShcIi9cIiwgXCIgXCIpLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKGNzMiA9PT0gXCJzcmdiLWxpbmVhclwiKSB7XG4gICAgICBbLCByLCBnLCBiLCBhbHBoYV0gPSByZXNvbHZlQ29sb3JGdW5jKHZhbHVlLCB7XG4gICAgICAgIGZvcm1hdDogY29uc3RhbnQuVkFMX0NPTVBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUNvbG9yRnVuYyh2YWx1ZSk7XG4gICAgICBbciwgZywgYl0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX1hZWl9UT19MX1JHQiwgW3gsIHksIHpdLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvclZhbHVlKHZhbHVlKTtcbiAgICBbciwgZywgYl0gPSB0cmFuc2Zvcm1NYXRyaXgoTUFUUklYX1hZWl9UT19MX1JHQiwgW3gsIHksIHpdLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIE1hdGgubWluKE1hdGgubWF4KHIsIDApLCAxKSxcbiAgICBNYXRoLm1pbihNYXRoLm1heChnLCAwKSwgMSksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgoYiwgMCksIDEpLFxuICAgIGFscGhhXG4gIF07XG59O1xuY29uc3QgY29udmVydENvbG9yVG9SZ2IgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHQ7XG4gIGxldCByLCBnLCBiLCBhbHBoYTtcbiAgaWYgKGZvcm1hdCA9PT0gVkFMX01JWCkge1xuICAgIGxldCByZ2I7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgICByZ2IgPSByZXNvbHZlQ29sb3JGdW5jKHZhbHVlLCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZ2IgPSByZXNvbHZlQ29sb3JWYWx1ZSh2YWx1ZSwgb3B0KTtcbiAgICB9XG4gICAgaWYgKHJnYiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgWywgciwgZywgYiwgYWxwaGFdID0gcmdiO1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19GTl9DT0xPUik7XG4gICAgY29uc3QgW2NzXSA9IHZhbC5yZXBsYWNlKFwiL1wiLCBcIiBcIikuc3BsaXQoL1xccysvKTtcbiAgICBpZiAoY3MgPT09IFwic3JnYlwiKSB7XG4gICAgICBbLCByLCBnLCBiLCBhbHBoYV0gPSByZXNvbHZlQ29sb3JGdW5jKHZhbHVlLCB7XG4gICAgICAgIGZvcm1hdDogY29uc3RhbnQuVkFMX0NPTVBcbiAgICAgIH0pO1xuICAgICAgciAqPSBNQVhfUkdCO1xuICAgICAgZyAqPSBNQVhfUkdCO1xuICAgICAgYiAqPSBNQVhfUkdCO1xuICAgIH0gZWxzZSB7XG4gICAgICBbLCByLCBnLCBiLCBhbHBoYV0gPSByZXNvbHZlQ29sb3JGdW5jKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoL14oPzpvayk/bCg/OmFifGNoKS8udGVzdCh2YWx1ZSkpIHtcbiAgICBbciwgZywgYiwgYWxwaGFdID0gY29udmVydENvbG9yVG9MaW5lYXJSZ2IodmFsdWUpO1xuICAgIFtyLCBnLCBiXSA9IGNvbnZlcnRMaW5lYXJSZ2JUb1JnYihbciwgZywgYl0pO1xuICB9IGVsc2Uge1xuICAgIFssIHIsIGcsIGIsIGFscGhhXSA9IHJlc29sdmVDb2xvclZhbHVlKHZhbHVlLCB7XG4gICAgICBmb3JtYXQ6IGNvbnN0YW50LlZBTF9DT01QXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtyLCBnLCBiLCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydENvbG9yVG9YeXogPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZDUwLCBmb3JtYXQgfSA9IG9wdDtcbiAgbGV0IHgsIHksIHosIGFscGhhO1xuICBpZiAoZm9ybWF0ID09PSBWQUxfTUlYKSB7XG4gICAgbGV0IHh5ejtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JGdW5jKHZhbHVlLCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4eXogPSBwYXJzZUNvbG9yVmFsdWUodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIGlmICh4eXogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB4eXo7XG4gICAgfVxuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHh5ejtcbiAgfSBlbHNlIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgIGNvbnN0IFssIHZhbF0gPSB2YWx1ZS5tYXRjaChSRUdfRk5fQ09MT1IpO1xuICAgIGNvbnN0IFtjc10gPSB2YWwucmVwbGFjZShcIi9cIiwgXCIgXCIpLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKGQ1MCkge1xuICAgICAgaWYgKGNzID09PSBcInh5ei1kNTBcIikge1xuICAgICAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSByZXNvbHZlQ29sb3JGdW5jKHZhbHVlLCB7XG4gICAgICAgICAgZm9ybWF0OiBjb25zdGFudC5WQUxfQ09NUFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlQ29sb3JGdW5jKHZhbHVlLCBvcHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL154eXooPzotZDY1KT8kLy50ZXN0KGNzKSkge1xuICAgICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcmVzb2x2ZUNvbG9yRnVuYyh2YWx1ZSwge1xuICAgICAgICBmb3JtYXQ6IGNvbnN0YW50LlZBTF9DT01QXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvckZ1bmModmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUNvbG9yVmFsdWUodmFsdWUsIG9wdCk7XG4gIH1cbiAgcmV0dXJuIFt4LCB5LCB6LCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydENvbG9yVG9Ic2wgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHQ7XG4gIGxldCBoLCBzLCBsLCBhbHBoYSwgeCwgeSwgejtcbiAgaWYgKFJFR19IU0wudGVzdCh2YWx1ZSkpIHtcbiAgICBbLCBoLCBzLCBsLCBhbHBoYV0gPSBwYXJzZUhzbCh2YWx1ZSwge1xuICAgICAgZm9ybWF0OiBcImhzbFwiXG4gICAgfSk7XG4gICAgaWYgKGZvcm1hdCA9PT0gXCJoc2xcIikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoKSxcbiAgICAgICAgTWF0aC5yb3VuZChzKSxcbiAgICAgICAgTWF0aC5yb3VuZChsKSxcbiAgICAgICAgYWxwaGFcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbaCwgcywgbCwgYWxwaGFdO1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFZBTF9NSVgpIHtcbiAgICBsZXQgeHl6O1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgICAgeHl6ID0gcGFyc2VDb2xvckZ1bmModmFsdWUsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSwgb3B0KTtcbiAgICB9XG4gICAgaWYgKHh5eiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHh5ejtcbiAgICB9XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0geHl6O1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvckZ1bmModmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgW2gsIHMsIGxdID0gY29udmVydFh5elRvSHNsKFt4LCB5LCB6XSwgdHJ1ZSk7XG4gIGlmIChmb3JtYXQgPT09IFwiaHNsXCIpIHtcbiAgICByZXR1cm4gW01hdGgucm91bmQoaCksIE1hdGgucm91bmQocyksIE1hdGgucm91bmQobCksIGFscGhhXTtcbiAgfVxuICByZXR1cm4gW2gsIHMsIGwsIGFscGhhXTtcbn07XG5jb25zdCBjb252ZXJ0Q29sb3JUb0h3YiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgbGV0IGgsIHcsIGIsIGFscGhhLCB4LCB5LCB6O1xuICBpZiAoUkVHX0hXQi50ZXN0KHZhbHVlKSkge1xuICAgIFssIGgsIHcsIGIsIGFscGhhXSA9IHBhcnNlSHdiKHZhbHVlLCB7XG4gICAgICBmb3JtYXQ6IFwiaHdiXCJcbiAgICB9KTtcbiAgICBpZiAoZm9ybWF0ID09PSBcImh3YlwiKSB7XG4gICAgICByZXR1cm4gW01hdGgucm91bmQoaCksIE1hdGgucm91bmQodyksIE1hdGgucm91bmQoYiksIGFscGhhXTtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCB3LCBiLCBhbHBoYV07XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gVkFMX01JWCkge1xuICAgIGxldCB4eXo7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgICB4eXogPSBwYXJzZUNvbG9yRnVuYyh2YWx1ZSwgb3B0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeHl6ID0gcGFyc2VDb2xvclZhbHVlKHZhbHVlLCBvcHQpO1xuICAgIH1cbiAgICBpZiAoeHl6ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4geHl6O1xuICAgIH1cbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSB4eXo7XG4gIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUNvbG9yRnVuYyh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvclZhbHVlKHZhbHVlKTtcbiAgfVxuICBbaCwgdywgYl0gPSBjb252ZXJ0WHl6VG9Id2IoW3gsIHksIHpdLCB0cnVlKTtcbiAgaWYgKGZvcm1hdCA9PT0gXCJod2JcIikge1xuICAgIHJldHVybiBbTWF0aC5yb3VuZChoKSwgTWF0aC5yb3VuZCh3KSwgTWF0aC5yb3VuZChiKSwgYWxwaGFdO1xuICB9XG4gIHJldHVybiBbaCwgdywgYiwgYWxwaGFdO1xufTtcbmNvbnN0IGNvbnZlcnRDb2xvclRvTGFiID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGZvcm1hdCB9ID0gb3B0O1xuICBsZXQgbCwgYSwgYiwgYWxwaGEsIHgsIHksIHo7XG4gIGlmIChSRUdfTEFCLnRlc3QodmFsdWUpKSB7XG4gICAgWywgbCwgYSwgYiwgYWxwaGFdID0gcGFyc2VMYWIodmFsdWUsIHtcbiAgICAgIGZvcm1hdDogY29uc3RhbnQuVkFMX0NPTVBcbiAgICB9KTtcbiAgICByZXR1cm4gW2wsIGEsIGIsIGFscGhhXTtcbiAgfVxuICBpZiAoZm9ybWF0ID09PSBWQUxfTUlYKSB7XG4gICAgbGV0IHh5ejtcbiAgICBvcHQuZDUwID0gdHJ1ZTtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JGdW5jKHZhbHVlLCBvcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4eXogPSBwYXJzZUNvbG9yVmFsdWUodmFsdWUsIG9wdCk7XG4gICAgfVxuICAgIGlmICh4eXogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB4eXo7XG4gICAgfVxuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHh5ejtcbiAgfSBlbHNlIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlQ29sb3JGdW5jKHZhbHVlLCB7XG4gICAgICBkNTA6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUNvbG9yVmFsdWUodmFsdWUsIHtcbiAgICAgIGQ1MDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIFtsLCBhLCBiXSA9IGNvbnZlcnRYeXpENTBUb0xhYihbeCwgeSwgel0sIHRydWUpO1xuICByZXR1cm4gW2wsIGEsIGIsIGFscGhhXTtcbn07XG5jb25zdCBjb252ZXJ0Q29sb3JUb0xjaCA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgbGV0IGwsIGMsIGgsIGFscGhhLCB4LCB5LCB6O1xuICBpZiAoUkVHX0xDSC50ZXN0KHZhbHVlKSkge1xuICAgIFssIGwsIGMsIGgsIGFscGhhXSA9IHBhcnNlTGNoKHZhbHVlLCB7XG4gICAgICBmb3JtYXQ6IGNvbnN0YW50LlZBTF9DT01QXG4gICAgfSk7XG4gICAgcmV0dXJuIFtsLCBjLCBoLCBhbHBoYV07XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gVkFMX01JWCkge1xuICAgIGxldCB4eXo7XG4gICAgb3B0LmQ1MCA9IHRydWU7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgICB4eXogPSBwYXJzZUNvbG9yRnVuYyh2YWx1ZSwgb3B0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeHl6ID0gcGFyc2VDb2xvclZhbHVlKHZhbHVlLCBvcHQpO1xuICAgIH1cbiAgICBpZiAoeHl6ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4geHl6O1xuICAgIH1cbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSB4eXo7XG4gIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICBbLCB4LCB5LCB6LCBhbHBoYV0gPSBwYXJzZUNvbG9yRnVuYyh2YWx1ZSwge1xuICAgICAgZDUwOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvclZhbHVlKHZhbHVlLCB7XG4gICAgICBkNTA6IHRydWVcbiAgICB9KTtcbiAgfVxuICBbbCwgYywgaF0gPSBjb252ZXJ0WHl6RDUwVG9MY2goW3gsIHksIHpdLCB0cnVlKTtcbiAgcmV0dXJuIFtsLCBjLCBoLCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydENvbG9yVG9Pa2xhYiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgbGV0IGwsIGEsIGIsIGFscGhhLCB4LCB5LCB6O1xuICBpZiAoUkVHX09LTEFCLnRlc3QodmFsdWUpKSB7XG4gICAgWywgbCwgYSwgYiwgYWxwaGFdID0gcGFyc2VPa2xhYih2YWx1ZSwge1xuICAgICAgZm9ybWF0OiBjb25zdGFudC5WQUxfQ09NUFxuICAgIH0pO1xuICAgIHJldHVybiBbbCwgYSwgYiwgYWxwaGFdO1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFZBTF9NSVgpIHtcbiAgICBsZXQgeHl6O1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgICAgeHl6ID0gcGFyc2VDb2xvckZ1bmModmFsdWUsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSwgb3B0KTtcbiAgICB9XG4gICAgaWYgKHh5eiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHh5ejtcbiAgICB9XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0geHl6O1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvckZ1bmModmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgW2wsIGEsIGJdID0gY29udmVydFh5elRvT2tsYWIoW3gsIHksIHpdLCB0cnVlKTtcbiAgcmV0dXJuIFtsLCBhLCBiLCBhbHBoYV07XG59O1xuY29uc3QgY29udmVydENvbG9yVG9Pa2xjaCA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgbGV0IGwsIGMsIGgsIGFscGhhLCB4LCB5LCB6O1xuICBpZiAoUkVHX09LTENILnRlc3QodmFsdWUpKSB7XG4gICAgWywgbCwgYywgaCwgYWxwaGFdID0gcGFyc2VPa2xjaCh2YWx1ZSwge1xuICAgICAgZm9ybWF0OiBjb25zdGFudC5WQUxfQ09NUFxuICAgIH0pO1xuICAgIHJldHVybiBbbCwgYywgaCwgYWxwaGFdO1xuICB9XG4gIGlmIChmb3JtYXQgPT09IFZBTF9NSVgpIHtcbiAgICBsZXQgeHl6O1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgICAgeHl6ID0gcGFyc2VDb2xvckZ1bmModmFsdWUsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHh5eiA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSwgb3B0KTtcbiAgICB9XG4gICAgaWYgKHh5eiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHh5ejtcbiAgICB9XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0geHl6O1xuICB9IGVsc2UgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgWywgeCwgeSwgeiwgYWxwaGFdID0gcGFyc2VDb2xvckZ1bmModmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFssIHgsIHksIHosIGFscGhhXSA9IHBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgW2wsIGMsIGhdID0gY29udmVydFh5elRvT2tsY2goW3gsIHksIHpdLCB0cnVlKTtcbiAgcmV0dXJuIFtsLCBjLCBoLCBhbHBoYV07XG59O1xuY29uc3QgcmVzb2x2ZUNvbG9yTWl4ID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHQ7XG4gIGNvbnN0IG5lc3RlZEl0ZW1zID0gW107XG4gIGlmICghUkVHX01JWC50ZXN0KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX01JWCkgJiYgUkVHX01JWF9ORVNULnRlc3QodmFsdWUpKSB7XG4gICAgICBjb25zdCByZWdDb2xvclNwYWNlID0gbmV3IFJlZ0V4cChgXig/OiR7Y29uc3RhbnQuQ1NfUkdCfXwke2NvbnN0YW50LkNTX1hZWn0pJGApO1xuICAgICAgY29uc3QgaXRlbXMgPSB2YWx1ZS5tYXRjaChSRUdfTUlYX05FU1QpO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgIGxldCB2YWwgPSByZXNvbHZlQ29sb3JNaXgoaXRlbSwge1xuICAgICAgICAgIGZvcm1hdDogZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQyA/IGZvcm1hdCA6IGNvbnN0YW50LlZBTF9DT01QXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgY29uc3QgW3YxLCB2MiwgdjMsIHY0LCB2NV0gPSB2YWw7XG4gICAgICAgICAgaWYgKHYyID09PSAwICYmIHYzID09PSAwICYmIHY0ID09PSAwICYmIHY1ID09PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlZ0NvbG9yU3BhY2UudGVzdCh2MSkpIHtcbiAgICAgICAgICAgIGlmICh2NSA9PT0gMSkge1xuICAgICAgICAgICAgICB2YWwgPSBgY29sb3IoJHt2MX0gJHt2Mn0gJHt2M30gJHt2NH0pYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbCA9IGBjb2xvcigke3YxfSAke3YyfSAke3YzfSAke3Y0fSAvICR7djV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh2NSA9PT0gMSkge1xuICAgICAgICAgICAgdmFsID0gYCR7djF9KCR7djJ9ICR7djN9ICR7djR9KWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IGAke3YxfSgke3YyfSAke3YzfSAke3Y0fSAvICR7djV9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFSRUdfTUlYLnRlc3QodmFsKSkge1xuICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWRJdGVtcy5wdXNoKHZhbCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShpdGVtLCB2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9TUEVDKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvbG9yU3BhY2UsIGh1ZUFyYywgY29sb3JBLCBwY3RBLCBjb2xvckIsIHBjdEI7XG4gIGlmIChuZXN0ZWRJdGVtcy5sZW5ndGggJiYgZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgIGNvbnN0IHJlZ0NvbG9yU3BhY2UgPSBuZXcgUmVnRXhwKGBeY29sb3ItbWl4XFxcXChcXFxccyppblxcXFxzKygke2NvbnN0YW50LkNTX01JWH0pXFxcXHMqLGApO1xuICAgIGNvbnN0IFssIGNzXSA9IHZhbHVlLm1hdGNoKHJlZ0NvbG9yU3BhY2UpO1xuICAgIGlmIChSRUdfQ1NfSFVFLnRlc3QoY3MpKSB7XG4gICAgICBbLCBjb2xvclNwYWNlLCBodWVBcmNdID0gY3MubWF0Y2goUkVHX0NTX0hVRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yU3BhY2UgPSBjcztcbiAgICB9XG4gICAgaWYgKG5lc3RlZEl0ZW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgaXRlbUEgPSBuZXN0ZWRJdGVtc1swXS5yZXBsYWNlKC8oPz1bKCldKS9nLCBcIlxcXFxcIik7XG4gICAgICBjb25zdCByZWdBID0gbmV3IFJlZ0V4cChgKCR7aXRlbUF9KSg/OlxcXFxzKygke2NvbnN0YW50LlBDVH0pKT9gKTtcbiAgICAgIFssIGNvbG9yQSwgcGN0QV0gPSB2YWx1ZS5tYXRjaChyZWdBKTtcbiAgICAgIGNvbnN0IGl0ZW1CID0gbmVzdGVkSXRlbXNbMV0ucmVwbGFjZSgvKD89WygpXSkvZywgXCJcXFxcXCIpO1xuICAgICAgY29uc3QgcmVnQiA9IG5ldyBSZWdFeHAoYCgke2l0ZW1CfSkoPzpcXFxccysoJHtjb25zdGFudC5QQ1R9KSk/YCk7XG4gICAgICBbLCBjb2xvckIsIHBjdEJdID0gdmFsdWUubWF0Y2gocmVnQik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbG9yUGFydCA9IGAoPzoke2NvbnN0YW50LlNZTl9DT0xPUl9UWVBFfSkoPzpcXFxccyske2NvbnN0YW50LlBDVH0pP2A7XG4gICAgICBjb25zdCBpdGVtID0gbmVzdGVkSXRlbXNbMF0ucmVwbGFjZSgvKD89WygpXSkvZywgXCJcXFxcXCIpO1xuICAgICAgY29uc3QgaXRlbVBhcnQgPSBgJHtpdGVtfSg/OlxcXFxzKyR7Y29uc3RhbnQuUENUfSk/YDtcbiAgICAgIGNvbnN0IGl0ZW1QYXJ0Q2FwdCA9IGAoJHtpdGVtfSkoPzpcXFxccysoJHtjb25zdGFudC5QQ1R9KSk/YDtcbiAgICAgIGNvbnN0IHJlZ0NvbG9yUGFydCA9IG5ldyBSZWdFeHAoYF4oJHtjb25zdGFudC5TWU5fQ09MT1JfVFlQRX0pKD86XFxcXHMrKCR7Y29uc3RhbnQuUENUfSkpPyRgKTtcbiAgICAgIGNvbnN0IHJlZ0l0ZW1QYXJ0ID0gbmV3IFJlZ0V4cChgXiR7aXRlbVBhcnRDYXB0fSRgKTtcbiAgICAgIGNvbnN0IHJlZ1Bvc2l0aW9uID0gbmV3IFJlZ0V4cChgJHtpdGVtUGFydENhcHR9XFxcXHMqXFxcXCkkYCk7XG4gICAgICBpZiAocmVnUG9zaXRpb24udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChgKCR7Y29sb3JQYXJ0fSlcXFxccyosXFxcXHMqKCR7aXRlbVBhcnR9KVxcXFxzKlxcXFwpJGApO1xuICAgICAgICBjb25zdCBbLCBjb2xvclBhcnRBLCBjb2xvclBhcnRCXSA9IHZhbHVlLm1hdGNoKHJlZyk7XG4gICAgICAgIFssIGNvbG9yQSwgcGN0QV0gPSBjb2xvclBhcnRBLm1hdGNoKHJlZ0NvbG9yUGFydCk7XG4gICAgICAgIFssIGNvbG9yQiwgcGN0Ql0gPSBjb2xvclBhcnRCLm1hdGNoKHJlZ0l0ZW1QYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoYCgke2l0ZW1QYXJ0fSlcXFxccyosXFxcXHMqKCR7Y29sb3JQYXJ0fSlcXFxccypcXFxcKSRgKTtcbiAgICAgICAgY29uc3QgWywgY29sb3JQYXJ0QSwgY29sb3JQYXJ0Ql0gPSB2YWx1ZS5tYXRjaChyZWcpO1xuICAgICAgICBbLCBjb2xvckEsIHBjdEFdID0gY29sb3JQYXJ0QS5tYXRjaChyZWdJdGVtUGFydCk7XG4gICAgICAgIFssIGNvbG9yQiwgcGN0Ql0gPSBjb2xvclBhcnRCLm1hdGNoKHJlZ0NvbG9yUGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IFssIGNzLCBjb2xvclBhcnRBLCBjb2xvclBhcnRCXSA9IHZhbHVlLm1hdGNoKFJFR19NSVhfQ0FQVCk7XG4gICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChgXigke2NvbnN0YW50LlNZTl9DT0xPUl9UWVBFfSkoPzpcXFxccysoJHtjb25zdGFudC5QQ1R9KSk/JGApO1xuICAgIFssIGNvbG9yQSwgcGN0QV0gPSBjb2xvclBhcnRBLm1hdGNoKHJlZyk7XG4gICAgWywgY29sb3JCLCBwY3RCXSA9IGNvbG9yUGFydEIubWF0Y2gocmVnKTtcbiAgICBpZiAoUkVHX0NTX0hVRS50ZXN0KGNzKSkge1xuICAgICAgWywgY29sb3JTcGFjZSwgaHVlQXJjXSA9IFJFR19DU19IVUUuZXhlYyhjcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yU3BhY2UgPSBjcztcbiAgICB9XG4gIH1cbiAgbGV0IHBBLCBwQiwgbTtcbiAgaWYgKHBjdEEgJiYgcGN0Qikge1xuICAgIGNvbnN0IHAxID0gcGFyc2VGbG9hdChwY3RBKSAvIE1BWF9QQ1Q7XG4gICAgY29uc3QgcDIgPSBwYXJzZUZsb2F0KHBjdEIpIC8gTUFYX1BDVDtcbiAgICBpZiAocDEgPCAwIHx8IHAxID4gMSB8fCBwMiA8IDAgfHwgcDIgPiAxKSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXCJyZ2JcIiwgMCwgMCwgMCwgMF07XG4gICAgfVxuICAgIGNvbnN0IGZhY3RvciA9IHAxICsgcDI7XG4gICAgaWYgKGZhY3RvciA9PT0gMCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBwQSA9IHAxIC8gZmFjdG9yO1xuICAgIHBCID0gcDIgLyBmYWN0b3I7XG4gICAgbSA9IGZhY3RvciA8IDEgPyBmYWN0b3IgOiAxO1xuICB9IGVsc2Uge1xuICAgIGlmIChwY3RBKSB7XG4gICAgICBwQSA9IHBhcnNlRmxvYXQocGN0QSkgLyBNQVhfUENUO1xuICAgICAgaWYgKHBBIDwgMCB8fCBwQSA+IDEpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcEIgPSAxIC0gcEE7XG4gICAgfSBlbHNlIGlmIChwY3RCKSB7XG4gICAgICBwQiA9IHBhcnNlRmxvYXQocGN0QikgLyBNQVhfUENUO1xuICAgICAgaWYgKHBCIDwgMCB8fCBwQiA+IDEpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcEEgPSAxIC0gcEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBBID0gSEFMRjtcbiAgICAgIHBCID0gSEFMRjtcbiAgICB9XG4gICAgbSA9IDE7XG4gIH1cbiAgaWYgKGNvbG9yU3BhY2UgPT09IFwieHl6XCIpIHtcbiAgICBjb2xvclNwYWNlID0gXCJ4eXotZDY1XCI7XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICBsZXQgdmFsdWVBLCB2YWx1ZUI7XG4gICAgaWYgKGNvbG9yQS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX01JWCkpIHtcbiAgICAgIHZhbHVlQSA9IGNvbG9yQTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yQS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgICAgdmFsdWVBID0gcGFyc2VDb2xvckZ1bmMoY29sb3JBLCBvcHQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVBKSkge1xuICAgICAgICBjb25zdCBbdjEsIHYyLCB2MywgdjQsIHY1XSA9IFsuLi52YWx1ZUFdO1xuICAgICAgICBpZiAodjUgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZUEgPSBgY29sb3IoJHt2MX0gJHt2Mn0gJHt2M30gJHt2NH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZUEgPSBgY29sb3IoJHt2MX0gJHt2Mn0gJHt2M30gJHt2NH0gLyAke3Y1fSlgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQSA9IHBhcnNlQ29sb3JWYWx1ZShjb2xvckEsIG9wdCk7XG4gICAgICBpZiAodmFsdWVBID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUE7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZUEpKSB7XG4gICAgICAgIGNvbnN0IFt2MSwgdjIsIHYzLCB2NCwgdjVdID0gWy4uLnZhbHVlQV07XG4gICAgICAgIGlmICh2NSA9PT0gMSkge1xuICAgICAgICAgIGlmICh2MSA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgdmFsdWVBID0gYCR7djF9KCR7djJ9LCAke3YzfSwgJHt2NH0pYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVBID0gYCR7djF9KCR7djJ9ICR7djN9ICR7djR9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHYxID09PSBcInJnYlwiKSB7XG4gICAgICAgICAgdmFsdWVBID0gYCR7djF9YSgke3YyfSwgJHt2M30sICR7djR9LCAke3Y1fSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQSA9IGAke3YxfSgke3YyfSAke3YzfSAke3Y0fSAvICR7djV9KWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yQi5zdGFydHNXaXRoKGNvbnN0YW50LkZOX01JWCkpIHtcbiAgICAgIHZhbHVlQiA9IGNvbG9yQjtcbiAgICB9IGVsc2UgaWYgKGNvbG9yQi5zdGFydHNXaXRoKGNvbnN0YW50LkZOX0NPTE9SKSkge1xuICAgICAgdmFsdWVCID0gcGFyc2VDb2xvckZ1bmMoY29sb3JCLCBvcHQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVCKSkge1xuICAgICAgICBjb25zdCBbdjEsIHYyLCB2MywgdjQsIHY1XSA9IFsuLi52YWx1ZUJdO1xuICAgICAgICBpZiAodjUgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZUIgPSBgY29sb3IoJHt2MX0gJHt2Mn0gJHt2M30gJHt2NH0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZUIgPSBgY29sb3IoJHt2MX0gJHt2Mn0gJHt2M30gJHt2NH0gLyAke3Y1fSlgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQiA9IHBhcnNlQ29sb3JWYWx1ZShjb2xvckIsIG9wdCk7XG4gICAgICBpZiAodmFsdWVCID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUI7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZUIpKSB7XG4gICAgICAgIGNvbnN0IFt2MSwgdjIsIHYzLCB2NCwgdjVdID0gWy4uLnZhbHVlQl07XG4gICAgICAgIGlmICh2NSA9PT0gMSkge1xuICAgICAgICAgIGlmICh2MSA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgdmFsdWVCID0gYCR7djF9KCR7djJ9LCAke3YzfSwgJHt2NH0pYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVCID0gYCR7djF9KCR7djJ9ICR7djN9ICR7djR9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHYxID09PSBcInJnYlwiKSB7XG4gICAgICAgICAgdmFsdWVCID0gYCR7djF9YSgke3YyfSwgJHt2M30sICR7djR9LCAke3Y1fSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQiA9IGAke3YxfSgke3YyfSAke3YzfSAke3Y0fSAvICR7djV9KWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBjdEEgJiYgcGN0Qikge1xuICAgICAgdmFsdWVBICs9IGAgJHtwYXJzZUZsb2F0KHBjdEEpfSVgO1xuICAgICAgdmFsdWVCICs9IGAgJHtwYXJzZUZsb2F0KHBjdEIpfSVgO1xuICAgIH0gZWxzZSBpZiAocGN0QSkge1xuICAgICAgY29uc3QgcEEyID0gcGFyc2VGbG9hdChwY3RBKTtcbiAgICAgIGlmIChwQTIgIT09IE1BWF9QQ1QgKiBIQUxGKSB7XG4gICAgICAgIHZhbHVlQSArPSBgICR7cEEyfSVgO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGN0Qikge1xuICAgICAgY29uc3QgcEEyID0gTUFYX1BDVCAtIHBhcnNlRmxvYXQocGN0Qik7XG4gICAgICBpZiAocEEyICE9PSBNQVhfUENUICogSEFMRikge1xuICAgICAgICB2YWx1ZUEgKz0gYCAke3BBMn0lYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGh1ZUFyYykge1xuICAgICAgcmV0dXJuIGBjb2xvci1taXgoaW4gJHtjb2xvclNwYWNlfSAke2h1ZUFyY30gaHVlLCAke3ZhbHVlQX0sICR7dmFsdWVCfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYGNvbG9yLW1peChpbiAke2NvbG9yU3BhY2V9LCAke3ZhbHVlQX0sICR7dmFsdWVCfSlgO1xuICAgIH1cbiAgfVxuICBsZXQgciwgZywgYiwgYWxwaGE7XG4gIGlmICgvXnNyZ2IoPzotbGluZWFyKT8kLy50ZXN0KGNvbG9yU3BhY2UpKSB7XG4gICAgbGV0IHJnYkEsIHJnYkI7XG4gICAgaWYgKGNvbG9yU3BhY2UgPT09IFwic3JnYlwiKSB7XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckEpKSB7XG4gICAgICAgIHJnYkEgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZ2JBID0gY29udmVydENvbG9yVG9SZ2IoY29sb3JBLCB7XG4gICAgICAgICAgY29sb3JTcGFjZSxcbiAgICAgICAgICBmb3JtYXQ6IFZBTF9NSVhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckIpKSB7XG4gICAgICAgIHJnYkIgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZ2JCID0gY29udmVydENvbG9yVG9SZ2IoY29sb3JCLCB7XG4gICAgICAgICAgY29sb3JTcGFjZSxcbiAgICAgICAgICBmb3JtYXQ6IFZBTF9NSVhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQSkpIHtcbiAgICAgICAgcmdiQSA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJnYkEgPSBjb252ZXJ0Q29sb3JUb0xpbmVhclJnYihjb2xvckEsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQikpIHtcbiAgICAgICAgcmdiQiA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJnYkIgPSBjb252ZXJ0Q29sb3JUb0xpbmVhclJnYihjb2xvckIsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJnYkEgPT09IG51bGwgfHwgcmdiQiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgbGV0IFtyQSwgZ0EsIGJBLCBhbHBoYUFdID0gcmdiQTtcbiAgICBsZXQgW3JCLCBnQiwgYkIsIGFscGhhQl0gPSByZ2JCO1xuICAgIGNvbnN0IHJOb25lID0gckEgPT09IGNvbnN0YW50Lk5PTkUgJiYgckIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgY29uc3QgZ05vbmUgPSBnQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBnQiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBjb25zdCBiTm9uZSA9IGJBID09PSBjb25zdGFudC5OT05FICYmIGJCID09PSBjb25zdGFudC5OT05FO1xuICAgIGNvbnN0IGFscGhhTm9uZSA9IGFscGhhQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBhbHBoYUIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgW1tyQSwgZ0EsIGJBLCBhbHBoYUFdLCBbckIsIGdCLCBiQiwgYWxwaGFCXV0gPSBub3JtYWxpemVDb2xvckNvbXBvbmVudHMoXG4gICAgICBbckEsIGdBLCBiQSwgYWxwaGFBXSxcbiAgICAgIFtyQiwgZ0IsIGJCLCBhbHBoYUJdLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZmFjdG9yQSA9IGFscGhhQSAqIHBBO1xuICAgIGNvbnN0IGZhY3RvckIgPSBhbHBoYUIgKiBwQjtcbiAgICBhbHBoYSA9IGZhY3RvckEgKyBmYWN0b3JCO1xuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgciA9IHJBICogcEEgKyByQiAqIHBCO1xuICAgICAgZyA9IGdBICogcEEgKyBnQiAqIHBCO1xuICAgICAgYiA9IGJBICogcEEgKyBiQiAqIHBCO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKHJBICogZmFjdG9yQSArIHJCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIGcgPSAoZ0EgKiBmYWN0b3JBICsgZ0IgKiBmYWN0b3JCKSAvIGFscGhhO1xuICAgICAgYiA9IChiQSAqIGZhY3RvckEgKyBiQiAqIGZhY3RvckIpIC8gYWxwaGE7XG4gICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9DT01QKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICByTm9uZSA/IGNvbnN0YW50Lk5PTkUgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24ociwgSEVYKSxcbiAgICAgICAgZ05vbmUgPyBjb25zdGFudC5OT05FIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGcsIEhFWCksXG4gICAgICAgIGJOb25lID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihiLCBIRVgpLFxuICAgICAgICBhbHBoYU5vbmUgPyBjb25zdGFudC5OT05FIDogYWxwaGEgKiBtXG4gICAgICBdO1xuICAgIH1cbiAgICByICo9IE1BWF9SR0I7XG4gICAgZyAqPSBNQVhfUkdCO1xuICAgIGIgKj0gTUFYX1JHQjtcbiAgfSBlbHNlIGlmIChSRUdfQ1NfWFlaLnRlc3QoY29sb3JTcGFjZSkpIHtcbiAgICBsZXQgeHl6QSwgeHl6QjtcbiAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckEpKSB7XG4gICAgICB4eXpBID0gW2NvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4eXpBID0gY29udmVydENvbG9yVG9YeXooY29sb3JBLCB7XG4gICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgIGQ1MDogY29sb3JTcGFjZSA9PT0gXCJ4eXotZDUwXCIsXG4gICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQikpIHtcbiAgICAgIHh5ekIgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHh5ekIgPSBjb252ZXJ0Q29sb3JUb1h5eihjb2xvckIsIHtcbiAgICAgICAgY29sb3JTcGFjZSxcbiAgICAgICAgZDUwOiBjb2xvclNwYWNlID09PSBcInh5ei1kNTBcIixcbiAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHh5ekEgPT09IG51bGwgfHwgeHl6QiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgbGV0IFt4QSwgeUEsIHpBLCBhbHBoYUFdID0geHl6QTtcbiAgICBsZXQgW3hCLCB5QiwgekIsIGFscGhhQl0gPSB4eXpCO1xuICAgIGNvbnN0IHhOb25lID0geEEgPT09IGNvbnN0YW50Lk5PTkUgJiYgeEIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgY29uc3QgeU5vbmUgPSB5QSA9PT0gY29uc3RhbnQuTk9ORSAmJiB5QiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBjb25zdCB6Tm9uZSA9IHpBID09PSBjb25zdGFudC5OT05FICYmIHpCID09PSBjb25zdGFudC5OT05FO1xuICAgIGNvbnN0IGFscGhhTm9uZSA9IGFscGhhQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBhbHBoYUIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgW1t4QSwgeUEsIHpBLCBhbHBoYUFdLCBbeEIsIHlCLCB6QiwgYWxwaGFCXV0gPSBub3JtYWxpemVDb2xvckNvbXBvbmVudHMoXG4gICAgICBbeEEsIHlBLCB6QSwgYWxwaGFBXSxcbiAgICAgIFt4QiwgeUIsIHpCLCBhbHBoYUJdLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgZmFjdG9yQSA9IGFscGhhQSAqIHBBO1xuICAgIGNvbnN0IGZhY3RvckIgPSBhbHBoYUIgKiBwQjtcbiAgICBhbHBoYSA9IGZhY3RvckEgKyBmYWN0b3JCO1xuICAgIGxldCB4LCB5LCB6O1xuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgeCA9IHhBICogcEEgKyB4QiAqIHBCO1xuICAgICAgeSA9IHlBICogcEEgKyB5QiAqIHBCO1xuICAgICAgeiA9IHpBICogcEEgKyB6QiAqIHBCO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKHhBICogZmFjdG9yQSArIHhCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIHkgPSAoeUEgKiBmYWN0b3JBICsgeUIgKiBmYWN0b3JCKSAvIGFscGhhO1xuICAgICAgeiA9ICh6QSAqIGZhY3RvckEgKyB6QiAqIGZhY3RvckIpIC8gYWxwaGE7XG4gICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9DT01QKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICB4Tm9uZSA/IGNvbnN0YW50Lk5PTkUgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oeCwgSEVYKSxcbiAgICAgICAgeU5vbmUgPyBjb25zdGFudC5OT05FIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHksIEhFWCksXG4gICAgICAgIHpOb25lID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbih6LCBIRVgpLFxuICAgICAgICBhbHBoYU5vbmUgPyBjb25zdGFudC5OT05FIDogYWxwaGEgKiBtXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY29sb3JTcGFjZSA9PT0gXCJ4eXotZDUwXCIpIHtcbiAgICAgIFtyLCBnLCBiXSA9IGNvbnZlcnRYeXpENTBUb1JnYihbeCwgeSwgel0sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbciwgZywgYl0gPSBjb252ZXJ0WHl6VG9SZ2IoW3gsIHksIHpdLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoL15oKD86c2x8d2IpJC8udGVzdChjb2xvclNwYWNlKSkge1xuICAgIGxldCBoc2xBLCBoc2xCO1xuICAgIGlmIChjb2xvclNwYWNlID09PSBcImhzbFwiKSB7XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckEpKSB7XG4gICAgICAgIGhzbEEgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoc2xBID0gY29udmVydENvbG9yVG9Ic2woY29sb3JBLCB7XG4gICAgICAgICAgY29sb3JTcGFjZSxcbiAgICAgICAgICBmb3JtYXQ6IFZBTF9NSVhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckIpKSB7XG4gICAgICAgIGhzbEIgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoc2xCID0gY29udmVydENvbG9yVG9Ic2woY29sb3JCLCB7XG4gICAgICAgICAgY29sb3JTcGFjZSxcbiAgICAgICAgICBmb3JtYXQ6IFZBTF9NSVhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQSkpIHtcbiAgICAgICAgaHNsQSA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhzbEEgPSBjb252ZXJ0Q29sb3JUb0h3Yihjb2xvckEsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQikpIHtcbiAgICAgICAgaHNsQiA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhzbEIgPSBjb252ZXJ0Q29sb3JUb0h3Yihjb2xvckIsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhzbEEgPT09IG51bGwgfHwgaHNsQiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtcInJnYlwiLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgbGV0IFtoQSwgc0EsIGxBLCBhbHBoYUFdID0gaHNsQTtcbiAgICBsZXQgW2hCLCBzQiwgbEIsIGFscGhhQl0gPSBoc2xCO1xuICAgIGNvbnN0IGFscGhhTm9uZSA9IGFscGhhQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBhbHBoYUIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgW1toQSwgc0EsIGxBLCBhbHBoYUFdLCBbaEIsIHNCLCBsQiwgYWxwaGFCXV0gPSBub3JtYWxpemVDb2xvckNvbXBvbmVudHMoXG4gICAgICBbaEEsIHNBLCBsQSwgYWxwaGFBXSxcbiAgICAgIFtoQiwgc0IsIGxCLCBhbHBoYUJdLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgaWYgKGh1ZUFyYykge1xuICAgICAgW2hBLCBoQl0gPSB1dGlsLmludGVycG9sYXRlSHVlKGhBLCBoQiwgaHVlQXJjKTtcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yQSA9IGFscGhhQSAqIHBBO1xuICAgIGNvbnN0IGZhY3RvckIgPSBhbHBoYUIgKiBwQjtcbiAgICBhbHBoYSA9IGZhY3RvckEgKyBmYWN0b3JCO1xuICAgIGNvbnN0IGggPSAoaEEgKiBwQSArIGhCICogcEIpICUgREVHO1xuICAgIGxldCBzLCBsO1xuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgcyA9IHNBICogcEEgKyBzQiAqIHBCO1xuICAgICAgbCA9IGxBICogcEEgKyBsQiAqIHBCO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHNBICogZmFjdG9yQSArIHNCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIGwgPSAobEEgKiBmYWN0b3JBICsgbEIgKiBmYWN0b3JCKSAvIGFscGhhO1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhLnRvRml4ZWQoMykpO1xuICAgIH1cbiAgICBbciwgZywgYl0gPSBjb252ZXJ0Q29sb3JUb1JnYihgJHtjb2xvclNwYWNlfSgke2h9ICR7c30gJHtsfSlgKTtcbiAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfQ09NUCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJzcmdiXCIsXG4gICAgICAgIHV0aWwucm91bmRUb1ByZWNpc2lvbihyIC8gTUFYX1JHQiwgSEVYKSxcbiAgICAgICAgdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGcgLyBNQVhfUkdCLCBIRVgpLFxuICAgICAgICB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYiAvIE1BWF9SR0IsIEhFWCksXG4gICAgICAgIGFscGhhTm9uZSA/IGNvbnN0YW50Lk5PTkUgOiBhbHBoYSAqIG1cbiAgICAgIF07XG4gICAgfVxuICB9IGVsc2UgaWYgKC9eKD86b2spP2xhYiQvLnRlc3QoY29sb3JTcGFjZSkpIHtcbiAgICBsZXQgbGFiQSwgbGFiQjtcbiAgICBpZiAoY29sb3JTcGFjZSA9PT0gXCJsYWJcIikge1xuICAgICAgaWYgKFJFR19DVVJSRU5ULnRlc3QoY29sb3JBKSkge1xuICAgICAgICBsYWJBID0gW2NvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiQSA9IGNvbnZlcnRDb2xvclRvTGFiKGNvbG9yQSwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFJFR19DVVJSRU5ULnRlc3QoY29sb3JCKSkge1xuICAgICAgICBsYWJCID0gW2NvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiQiA9IGNvbnZlcnRDb2xvclRvTGFiKGNvbG9yQiwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckEpKSB7XG4gICAgICAgIGxhYkEgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJBID0gY29udmVydENvbG9yVG9Pa2xhYihjb2xvckEsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQikpIHtcbiAgICAgICAgbGFiQiA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYkIgPSBjb252ZXJ0Q29sb3JUb09rbGFiKGNvbG9yQiwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFiQSA9PT0gbnVsbCB8fCBsYWJCID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBsZXQgW2xBLCBhQSwgYkEsIGFscGhhQV0gPSBsYWJBO1xuICAgIGxldCBbbEIsIGFCLCBiQiwgYWxwaGFCXSA9IGxhYkI7XG4gICAgY29uc3QgbE5vbmUgPSBsQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBsQiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBjb25zdCBhTm9uZSA9IGFBID09PSBjb25zdGFudC5OT05FICYmIGFCID09PSBjb25zdGFudC5OT05FO1xuICAgIGNvbnN0IGJOb25lID0gYkEgPT09IGNvbnN0YW50Lk5PTkUgJiYgYkIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgY29uc3QgYWxwaGFOb25lID0gYWxwaGFBID09PSBjb25zdGFudC5OT05FICYmIGFscGhhQiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBbW2xBLCBhQSwgYkEsIGFscGhhQV0sIFtsQiwgYUIsIGJCLCBhbHBoYUJdXSA9IG5vcm1hbGl6ZUNvbG9yQ29tcG9uZW50cyhcbiAgICAgIFtsQSwgYUEsIGJBLCBhbHBoYUFdLFxuICAgICAgW2xCLCBhQiwgYkIsIGFscGhhQl0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBmYWN0b3JBID0gYWxwaGFBICogcEE7XG4gICAgY29uc3QgZmFjdG9yQiA9IGFscGhhQiAqIHBCO1xuICAgIGFscGhhID0gZmFjdG9yQSArIGZhY3RvckI7XG4gICAgbGV0IGwsIGFPLCBiTztcbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIGwgPSBsQSAqIHBBICsgbEIgKiBwQjtcbiAgICAgIGFPID0gYUEgKiBwQSArIGFCICogcEI7XG4gICAgICBiTyA9IGJBICogcEEgKyBiQiAqIHBCO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gKGxBICogZmFjdG9yQSArIGxCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIGFPID0gKGFBICogZmFjdG9yQSArIGFCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIGJPID0gKGJBICogZmFjdG9yQSArIGJCICogZmFjdG9yQikgLyBhbHBoYTtcbiAgICAgIGFscGhhID0gcGFyc2VGbG9hdChhbHBoYS50b0ZpeGVkKDMpKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX0NPTVApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgIGxOb25lID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihsLCBIRVgpLFxuICAgICAgICBhTm9uZSA/IGNvbnN0YW50Lk5PTkUgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24oYU8sIEhFWCksXG4gICAgICAgIGJOb25lID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihiTywgSEVYKSxcbiAgICAgICAgYWxwaGFOb25lID8gY29uc3RhbnQuTk9ORSA6IGFscGhhICogbVxuICAgICAgXTtcbiAgICB9XG4gICAgWywgciwgZywgYl0gPSByZXNvbHZlQ29sb3JWYWx1ZShgJHtjb2xvclNwYWNlfSgke2x9ICR7YU99ICR7Yk99KWApO1xuICB9IGVsc2UgaWYgKC9eKD86b2spP2xjaCQvLnRlc3QoY29sb3JTcGFjZSkpIHtcbiAgICBsZXQgbGNoQSwgbGNoQjtcbiAgICBpZiAoY29sb3JTcGFjZSA9PT0gXCJsY2hcIikge1xuICAgICAgaWYgKFJFR19DVVJSRU5ULnRlc3QoY29sb3JBKSkge1xuICAgICAgICBsY2hBID0gW2NvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGNoQSA9IGNvbnZlcnRDb2xvclRvTGNoKGNvbG9yQSwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFJFR19DVVJSRU5ULnRlc3QoY29sb3JCKSkge1xuICAgICAgICBsY2hCID0gW2NvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkUsIGNvbnN0YW50Lk5PTkVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGNoQiA9IGNvbnZlcnRDb2xvclRvTGNoKGNvbG9yQiwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoUkVHX0NVUlJFTlQudGVzdChjb2xvckEpKSB7XG4gICAgICAgIGxjaEEgPSBbY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORSwgY29uc3RhbnQuTk9ORV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsY2hBID0gY29udmVydENvbG9yVG9Pa2xjaChjb2xvckEsIHtcbiAgICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICAgIGZvcm1hdDogVkFMX01JWFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSRUdfQ1VSUkVOVC50ZXN0KGNvbG9yQikpIHtcbiAgICAgICAgbGNoQiA9IFtjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FLCBjb25zdGFudC5OT05FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxjaEIgPSBjb252ZXJ0Q29sb3JUb09rbGNoKGNvbG9yQiwge1xuICAgICAgICAgIGNvbG9yU3BhY2UsXG4gICAgICAgICAgZm9ybWF0OiBWQUxfTUlYXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGNoQSA9PT0gbnVsbCB8fCBsY2hCID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW1wicmdiXCIsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICBsZXQgW2xBLCBjQSwgaEEsIGFscGhhQV0gPSBsY2hBO1xuICAgIGxldCBbbEIsIGNCLCBoQiwgYWxwaGFCXSA9IGxjaEI7XG4gICAgY29uc3QgbE5vbmUgPSBsQSA9PT0gY29uc3RhbnQuTk9ORSAmJiBsQiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBjb25zdCBjTm9uZSA9IGNBID09PSBjb25zdGFudC5OT05FICYmIGNCID09PSBjb25zdGFudC5OT05FO1xuICAgIGNvbnN0IGhOb25lID0gaEEgPT09IGNvbnN0YW50Lk5PTkUgJiYgaEIgPT09IGNvbnN0YW50Lk5PTkU7XG4gICAgY29uc3QgYWxwaGFOb25lID0gYWxwaGFBID09PSBjb25zdGFudC5OT05FICYmIGFscGhhQiA9PT0gY29uc3RhbnQuTk9ORTtcbiAgICBbW2xBLCBjQSwgaEEsIGFscGhhQV0sIFtsQiwgY0IsIGhCLCBhbHBoYUJdXSA9IG5vcm1hbGl6ZUNvbG9yQ29tcG9uZW50cyhcbiAgICAgIFtsQSwgY0EsIGhBLCBhbHBoYUFdLFxuICAgICAgW2xCLCBjQiwgaEIsIGFscGhhQl0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBpZiAoaHVlQXJjKSB7XG4gICAgICBbaEEsIGhCXSA9IHV0aWwuaW50ZXJwb2xhdGVIdWUoaEEsIGhCLCBodWVBcmMpO1xuICAgIH1cbiAgICBjb25zdCBmYWN0b3JBID0gYWxwaGFBICogcEE7XG4gICAgY29uc3QgZmFjdG9yQiA9IGFscGhhQiAqIHBCO1xuICAgIGFscGhhID0gZmFjdG9yQSArIGZhY3RvckI7XG4gICAgY29uc3QgaCA9IChoQSAqIHBBICsgaEIgKiBwQikgJSBERUc7XG4gICAgbGV0IGwsIGM7XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBsID0gbEEgKiBwQSArIGxCICogcEI7XG4gICAgICBjID0gY0EgKiBwQSArIGNCICogcEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSAobEEgKiBmYWN0b3JBICsgbEIgKiBmYWN0b3JCKSAvIGFscGhhO1xuICAgICAgYyA9IChjQSAqIGZhY3RvckEgKyBjQiAqIGZhY3RvckIpIC8gYWxwaGE7XG4gICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9DT01QKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBjb2xvclNwYWNlLFxuICAgICAgICBsTm9uZSA/IGNvbnN0YW50Lk5PTkUgOiB1dGlsLnJvdW5kVG9QcmVjaXNpb24obCwgSEVYKSxcbiAgICAgICAgY05vbmUgPyBjb25zdGFudC5OT05FIDogdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGMsIEhFWCksXG4gICAgICAgIGhOb25lID8gY29uc3RhbnQuTk9ORSA6IHV0aWwucm91bmRUb1ByZWNpc2lvbihoLCBIRVgpLFxuICAgICAgICBhbHBoYU5vbmUgPyBjb25zdGFudC5OT05FIDogYWxwaGEgKiBtXG4gICAgICBdO1xuICAgIH1cbiAgICBbLCByLCBnLCBiXSA9IHJlc29sdmVDb2xvclZhbHVlKGAke2NvbG9yU3BhY2V9KCR7bH0gJHtjfSAke2h9KWApO1xuICB9XG4gIHJldHVybiBbXG4gICAgXCJyZ2JcIixcbiAgICBNYXRoLnJvdW5kKHIpLFxuICAgIE1hdGgucm91bmQoZyksXG4gICAgTWF0aC5yb3VuZChiKSxcbiAgICBwYXJzZUZsb2F0KChhbHBoYSAqIG0pLnRvRml4ZWQoMykpXG4gIF07XG59O1xuZXhwb3J0cy5OQU1FRF9DT0xPUlMgPSBOQU1FRF9DT0xPUlM7XG5leHBvcnRzLmFuZ2xlVG9EZWcgPSBhbmdsZVRvRGVnO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb0hzbCA9IGNvbnZlcnRDb2xvclRvSHNsO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb0h3YiA9IGNvbnZlcnRDb2xvclRvSHdiO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb0xhYiA9IGNvbnZlcnRDb2xvclRvTGFiO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb0xjaCA9IGNvbnZlcnRDb2xvclRvTGNoO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb0xpbmVhclJnYiA9IGNvbnZlcnRDb2xvclRvTGluZWFyUmdiO1xuZXhwb3J0cy5jb252ZXJ0Q29sb3JUb09rbGFiID0gY29udmVydENvbG9yVG9Pa2xhYjtcbmV4cG9ydHMuY29udmVydENvbG9yVG9Pa2xjaCA9IGNvbnZlcnRDb2xvclRvT2tsY2g7XG5leHBvcnRzLmNvbnZlcnRDb2xvclRvUmdiID0gY29udmVydENvbG9yVG9SZ2I7XG5leHBvcnRzLmNvbnZlcnRDb2xvclRvWHl6ID0gY29udmVydENvbG9yVG9YeXo7XG5leHBvcnRzLmNvbnZlcnRIZXhUb0xpbmVhclJnYiA9IGNvbnZlcnRIZXhUb0xpbmVhclJnYjtcbmV4cG9ydHMuY29udmVydEhleFRvUmdiID0gY29udmVydEhleFRvUmdiO1xuZXhwb3J0cy5jb252ZXJ0SGV4VG9YeXogPSBjb252ZXJ0SGV4VG9YeXo7XG5leHBvcnRzLmNvbnZlcnRMaW5lYXJSZ2JUb1JnYiA9IGNvbnZlcnRMaW5lYXJSZ2JUb1JnYjtcbmV4cG9ydHMuY29udmVydFJnYlRvSGV4ID0gY29udmVydFJnYlRvSGV4O1xuZXhwb3J0cy5jb252ZXJ0UmdiVG9MaW5lYXJSZ2IgPSBjb252ZXJ0UmdiVG9MaW5lYXJSZ2I7XG5leHBvcnRzLmNvbnZlcnRSZ2JUb1h5eiA9IGNvbnZlcnRSZ2JUb1h5ejtcbmV4cG9ydHMuY29udmVydFh5ekQ1MFRvTGFiID0gY29udmVydFh5ekQ1MFRvTGFiO1xuZXhwb3J0cy5jb252ZXJ0WHl6RDUwVG9MY2ggPSBjb252ZXJ0WHl6RDUwVG9MY2g7XG5leHBvcnRzLmNvbnZlcnRYeXpENTBUb1JnYiA9IGNvbnZlcnRYeXpENTBUb1JnYjtcbmV4cG9ydHMuY29udmVydFh5elRvSHNsID0gY29udmVydFh5elRvSHNsO1xuZXhwb3J0cy5jb252ZXJ0WHl6VG9Id2IgPSBjb252ZXJ0WHl6VG9Id2I7XG5leHBvcnRzLmNvbnZlcnRYeXpUb09rbGFiID0gY29udmVydFh5elRvT2tsYWI7XG5leHBvcnRzLmNvbnZlcnRYeXpUb09rbGNoID0gY29udmVydFh5elRvT2tsY2g7XG5leHBvcnRzLmNvbnZlcnRYeXpUb1JnYiA9IGNvbnZlcnRYeXpUb1JnYjtcbmV4cG9ydHMubm9ybWFsaXplQ29sb3JDb21wb25lbnRzID0gbm9ybWFsaXplQ29sb3JDb21wb25lbnRzO1xuZXhwb3J0cy5udW1iZXJUb0hleFN0cmluZyA9IG51bWJlclRvSGV4U3RyaW5nO1xuZXhwb3J0cy5wYXJzZUFscGhhID0gcGFyc2VBbHBoYTtcbmV4cG9ydHMucGFyc2VDb2xvckZ1bmMgPSBwYXJzZUNvbG9yRnVuYztcbmV4cG9ydHMucGFyc2VDb2xvclZhbHVlID0gcGFyc2VDb2xvclZhbHVlO1xuZXhwb3J0cy5wYXJzZUhleEFscGhhID0gcGFyc2VIZXhBbHBoYTtcbmV4cG9ydHMucGFyc2VIc2wgPSBwYXJzZUhzbDtcbmV4cG9ydHMucGFyc2VId2IgPSBwYXJzZUh3YjtcbmV4cG9ydHMucGFyc2VMYWIgPSBwYXJzZUxhYjtcbmV4cG9ydHMucGFyc2VMY2ggPSBwYXJzZUxjaDtcbmV4cG9ydHMucGFyc2VPa2xhYiA9IHBhcnNlT2tsYWI7XG5leHBvcnRzLnBhcnNlT2tsY2ggPSBwYXJzZU9rbGNoO1xuZXhwb3J0cy5wYXJzZVJnYiA9IHBhcnNlUmdiO1xuZXhwb3J0cy5yZXNvbHZlQ29sb3JGdW5jID0gcmVzb2x2ZUNvbG9yRnVuYztcbmV4cG9ydHMucmVzb2x2ZUNvbG9yTWl4ID0gcmVzb2x2ZUNvbG9yTWl4O1xuZXhwb3J0cy5yZXNvbHZlQ29sb3JWYWx1ZSA9IHJlc29sdmVDb2xvclZhbHVlO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXRyaXggPSB0cmFuc2Zvcm1NYXRyaXg7XG5leHBvcnRzLnZhbGlkYXRlQ29sb3JDb21wb25lbnRzID0gdmFsaWRhdGVDb2xvckNvbXBvbmVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci5janMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst isString = (o) => typeof o === \"string\" || o instanceof String;\nexports.isString = isString;\n//# sourceMappingURL=common.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY29tbW9uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9jb21tb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KTtcbmNvbnN0IGlzU3RyaW5nID0gKG8pID0+IHR5cGVvZiBvID09PSBcInN0cmluZ1wiIHx8IG8gaW5zdGFuY2VvZiBTdHJpbmc7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst VAL_COMP = \"computedValue\";\nconst VAL_SPEC = \"specifiedValue\";\nconst _DIGIT = \"(?:0|[1-9]\\\\d*)\";\nconst _COMP = \"clamp|max|min\";\nconst _STEP = \"mod|rem|round\";\nconst _TRIG = \"a?(?:cos|sin|tan)|atan2\";\nconst _EXP = \"exp|hypot|log|pow|sqrt\";\nconst _SIGN = \"abs|sign\";\nconst _MATH = `${_COMP}|${_STEP}|${_TRIG}|${_EXP}|${_SIGN}`;\nconst _CALC = `calc|${_MATH}`;\nconst _VAR = `var|${_CALC}`;\nconst ANGLE = \"deg|g?rad|turn\";\nconst NUM = `[+-]?(?:${_DIGIT}(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e-?${_DIGIT})?`;\nconst NONE = \"none\";\nconst PCT = `${NUM}%`;\nconst SYN_FN_MATH = `^(?:${_MATH})\\\\($`;\nconst SYN_FN_MATH_CALC = `^(?:${_CALC})\\\\(|(?<=[*\\\\/\\\\s\\\\(])(?:${_CALC})\\\\(`;\nconst SYN_FN_MATH_VAR = `^(?:${_VAR})\\\\(`;\nconst SYN_FN_VAR = \"^var\\\\(|(?<=[*\\\\/\\\\s\\\\(])var\\\\(\";\nconst _ALPHA = `(?:\\\\s*\\\\/\\\\s*(?:${NUM}|${PCT}|${NONE}))?`;\nconst _ALPHA_LV3 = `(?:\\\\s*,\\\\s*(?:${NUM}|${PCT}))?`;\nconst _COLOR_FUNC = \"(?:ok)?l(?:ab|ch)|color|hsla?|hwb|rgba?\";\nconst _COLOR_KEY = \"[a-z]+|#[\\\\da-f]{3}|#[\\\\da-f]{4}|#[\\\\da-f]{6}|#[\\\\da-f]{8}\";\nconst _CS_HUE = \"(?:ok)?lch|hsl|hwb\";\nconst _CS_HUE_ARC = \"(?:de|in)creasing|longer|shorter\";\nconst _NUM_ANGLE = `${NUM}(?:${ANGLE})?`;\nconst _NUM_ANGLE_NONE = `(?:${NUM}(?:${ANGLE})?|${NONE})`;\nconst _NUM_PCT_NONE = `(?:${NUM}|${PCT}|${NONE})`;\nconst CS_HUE = `(?:${_CS_HUE})(?:\\\\s(?:${_CS_HUE_ARC})\\\\shue)?`;\nconst CS_HUE_CAPT = `(${_CS_HUE})(?:\\\\s(${_CS_HUE_ARC})\\\\shue)?`;\nconst CS_LAB = \"(?:ok)?lab\";\nconst CS_LCH = \"(?:ok)?lch\";\nconst CS_SRGB = \"srgb(?:-linear)?\";\nconst CS_RGB = `(?:a98|prophoto)-rgb|display-p3|rec2020|${CS_SRGB}`;\nconst CS_XYZ = \"xyz(?:-d(?:50|65))?\";\nconst CS_MIX = `${CS_HUE}|${CS_LAB}|${CS_SRGB}|${CS_XYZ}`;\nconst FN_COLOR = \"color(\";\nconst FN_MIX = \"color-mix(\";\nconst FN_REL = `(?:${_COLOR_FUNC})\\\\(\\\\s*from\\\\s+`;\nconst FN_REL_CAPT = `(${_COLOR_FUNC})\\\\(\\\\s*from\\\\s+`;\nconst FN_VAR = \"var(\";\nconst SYN_FN_COLOR = `(?:${CS_RGB}|${CS_XYZ})(?:\\\\s+${_NUM_PCT_NONE}){3}${_ALPHA}`;\nconst SYN_FN_REL = `^${FN_REL}|(?<=[\\\\s])${FN_REL}`;\nconst SYN_HSL = `${_NUM_ANGLE_NONE}(?:\\\\s+${_NUM_PCT_NONE}){2}${_ALPHA}`;\nconst SYN_HSL_LV3 = `${_NUM_ANGLE}(?:\\\\s*,\\\\s*${PCT}){2}${_ALPHA_LV3}`;\nconst SYN_LCH = `(?:${_NUM_PCT_NONE}\\\\s+){2}${_NUM_ANGLE_NONE}${_ALPHA}`;\nconst SYN_MOD = `${_NUM_PCT_NONE}(?:\\\\s+${_NUM_PCT_NONE}){2}${_ALPHA}`;\nconst SYN_RGB_LV3 = `(?:${NUM}(?:\\\\s*,\\\\s*${NUM}){2}|${PCT}(?:\\\\s*,\\\\s*${PCT}){2})${_ALPHA_LV3}`;\nconst SYN_COLOR_TYPE = `${_COLOR_KEY}|hsla?\\\\(\\\\s*${SYN_HSL_LV3}\\\\s*\\\\)|rgba?\\\\(\\\\s*${SYN_RGB_LV3}\\\\s*\\\\)|(?:hsla?|hwb)\\\\(\\\\s*${SYN_HSL}\\\\s*\\\\)|(?:(?:ok)?lab|rgba?)\\\\(\\\\s*${SYN_MOD}\\\\s*\\\\)|(?:ok)?lch\\\\(\\\\s*${SYN_LCH}\\\\s*\\\\)|color\\\\(\\\\s*${SYN_FN_COLOR}\\\\s*\\\\)`;\nconst SYN_MIX_PART = `(?:${SYN_COLOR_TYPE})(?:\\\\s+${PCT})?`;\nconst SYN_MIX = `color-mix\\\\(\\\\s*in\\\\s+(?:${CS_MIX})\\\\s*,\\\\s*${SYN_MIX_PART}\\\\s*,\\\\s*${SYN_MIX_PART}\\\\s*\\\\)`;\nconst SYN_MIX_CAPT = `color-mix\\\\(\\\\s*in\\\\s+(${CS_MIX})\\\\s*,\\\\s*(${SYN_MIX_PART})\\\\s*,\\\\s*(${SYN_MIX_PART})\\\\s*\\\\)`;\nexports.ANGLE = ANGLE;\nexports.CS_HUE = CS_HUE;\nexports.CS_HUE_CAPT = CS_HUE_CAPT;\nexports.CS_LAB = CS_LAB;\nexports.CS_LCH = CS_LCH;\nexports.CS_MIX = CS_MIX;\nexports.CS_RGB = CS_RGB;\nexports.CS_SRGB = CS_SRGB;\nexports.CS_XYZ = CS_XYZ;\nexports.FN_COLOR = FN_COLOR;\nexports.FN_MIX = FN_MIX;\nexports.FN_REL = FN_REL;\nexports.FN_REL_CAPT = FN_REL_CAPT;\nexports.FN_VAR = FN_VAR;\nexports.NONE = NONE;\nexports.NUM = NUM;\nexports.PCT = PCT;\nexports.SYN_COLOR_TYPE = SYN_COLOR_TYPE;\nexports.SYN_FN_COLOR = SYN_FN_COLOR;\nexports.SYN_FN_MATH = SYN_FN_MATH;\nexports.SYN_FN_MATH_CALC = SYN_FN_MATH_CALC;\nexports.SYN_FN_MATH_VAR = SYN_FN_MATH_VAR;\nexports.SYN_FN_REL = SYN_FN_REL;\nexports.SYN_FN_VAR = SYN_FN_VAR;\nexports.SYN_HSL = SYN_HSL;\nexports.SYN_HSL_LV3 = SYN_HSL_LV3;\nexports.SYN_LCH = SYN_LCH;\nexports.SYN_MIX = SYN_MIX;\nexports.SYN_MIX_CAPT = SYN_MIX_CAPT;\nexports.SYN_MIX_PART = SYN_MIX_PART;\nexports.SYN_MOD = SYN_MOD;\nexports.SYN_RGB_LV3 = SYN_RGB_LV3;\nexports.VAL_COMP = VAL_COMP;\nexports.VAL_SPEC = VAL_SPEC;\n//# sourceMappingURL=constant.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY29uc3RhbnQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLEtBQUssR0FBRyxNQUFNO0FBQzFELHNCQUFzQixNQUFNO0FBQzVCLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0EsdUJBQXVCLE9BQU8sNkJBQTZCLE9BQU87QUFDbEU7QUFDQSxlQUFlLElBQUk7QUFDbkIsMkJBQTJCLE1BQU07QUFDakMsZ0NBQWdDLE1BQU0sMkJBQTJCLE1BQU07QUFDdkUsK0JBQStCLEtBQUs7QUFDcEM7QUFDQSxtQ0FBbUMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQ3RELHFDQUFxQyxJQUFJLEdBQUcsSUFBSTtBQUNoRDtBQUNBLHFDQUFxQyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFO0FBQzlFO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxLQUFLLE1BQU07QUFDckMsOEJBQThCLElBQUksS0FBSyxNQUFNLEtBQUssS0FBSztBQUN2RCw0QkFBNEIsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBQy9DLHFCQUFxQixRQUFRLFlBQVksWUFBWTtBQUNyRCx3QkFBd0IsUUFBUSxVQUFVLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVE7QUFDbEU7QUFDQSxrQkFBa0IsT0FBTyxHQUFHLE9BQU8sR0FBRyxRQUFRLEdBQUcsT0FBTztBQUN4RDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakMsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQSwyQkFBMkIsT0FBTyxHQUFHLE9BQU8sVUFBVSxjQUFjLEVBQUUsRUFBRSxFQUFFLE9BQU87QUFDakYsdUJBQXVCLE9BQU8sYUFBYSxPQUFPO0FBQ2xELG1CQUFtQixnQkFBZ0IsU0FBUyxjQUFjLEVBQUUsRUFBRSxFQUFFLE9BQU87QUFDdkUsdUJBQXVCLFdBQVcsY0FBYyxJQUFJLEVBQUUsRUFBRSxFQUFFLFdBQVc7QUFDckUsc0JBQXNCLGNBQWMsTUFBTSxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTztBQUN2RSxtQkFBbUIsY0FBYyxTQUFTLGNBQWMsRUFBRSxFQUFFLEVBQUUsT0FBTztBQUNyRSwwQkFBMEIsSUFBSSxjQUFjLElBQUksRUFBRSxFQUFFLEdBQUcsSUFBSSxjQUFjLElBQUksRUFBRSxFQUFFLEdBQUcsV0FBVztBQUMvRiwwQkFBMEIsV0FBVyxlQUFlLFlBQVksc0JBQXNCLFlBQVksOEJBQThCLFFBQVEscUNBQXFDLFFBQVEsMkJBQTJCLFFBQVEsc0JBQXNCLGFBQWE7QUFDM1AsMkJBQTJCLGVBQWUsVUFBVSxJQUFJO0FBQ3hELDRDQUE0QyxPQUFPLFlBQVksYUFBYSxXQUFXLGFBQWE7QUFDcEcsK0NBQStDLE9BQU8sYUFBYSxhQUFhLGFBQWEsYUFBYTtBQUMxRyxhQUFhO0FBQ2IsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsY0FBYztBQUNkLFlBQVk7QUFDWixXQUFXO0FBQ1gsV0FBVztBQUNYLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9jb25zdGFudC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgVkFMX0NPTVAgPSBcImNvbXB1dGVkVmFsdWVcIjtcbmNvbnN0IFZBTF9TUEVDID0gXCJzcGVjaWZpZWRWYWx1ZVwiO1xuY29uc3QgX0RJR0lUID0gXCIoPzowfFsxLTldXFxcXGQqKVwiO1xuY29uc3QgX0NPTVAgPSBcImNsYW1wfG1heHxtaW5cIjtcbmNvbnN0IF9TVEVQID0gXCJtb2R8cmVtfHJvdW5kXCI7XG5jb25zdCBfVFJJRyA9IFwiYT8oPzpjb3N8c2lufHRhbil8YXRhbjJcIjtcbmNvbnN0IF9FWFAgPSBcImV4cHxoeXBvdHxsb2d8cG93fHNxcnRcIjtcbmNvbnN0IF9TSUdOID0gXCJhYnN8c2lnblwiO1xuY29uc3QgX01BVEggPSBgJHtfQ09NUH18JHtfU1RFUH18JHtfVFJJR318JHtfRVhQfXwke19TSUdOfWA7XG5jb25zdCBfQ0FMQyA9IGBjYWxjfCR7X01BVEh9YDtcbmNvbnN0IF9WQVIgPSBgdmFyfCR7X0NBTEN9YDtcbmNvbnN0IEFOR0xFID0gXCJkZWd8Zz9yYWR8dHVyblwiO1xuY29uc3QgTlVNID0gYFsrLV0/KD86JHtfRElHSVR9KD86XFxcXC5cXFxcZCopP3xcXFxcLlxcXFxkKykoPzplLT8ke19ESUdJVH0pP2A7XG5jb25zdCBOT05FID0gXCJub25lXCI7XG5jb25zdCBQQ1QgPSBgJHtOVU19JWA7XG5jb25zdCBTWU5fRk5fTUFUSCA9IGBeKD86JHtfTUFUSH0pXFxcXCgkYDtcbmNvbnN0IFNZTl9GTl9NQVRIX0NBTEMgPSBgXig/OiR7X0NBTEN9KVxcXFwofCg/PD1bKlxcXFwvXFxcXHNcXFxcKF0pKD86JHtfQ0FMQ30pXFxcXChgO1xuY29uc3QgU1lOX0ZOX01BVEhfVkFSID0gYF4oPzoke19WQVJ9KVxcXFwoYDtcbmNvbnN0IFNZTl9GTl9WQVIgPSBcIl52YXJcXFxcKHwoPzw9WypcXFxcL1xcXFxzXFxcXChdKXZhclxcXFwoXCI7XG5jb25zdCBfQUxQSEEgPSBgKD86XFxcXHMqXFxcXC9cXFxccyooPzoke05VTX18JHtQQ1R9fCR7Tk9ORX0pKT9gO1xuY29uc3QgX0FMUEhBX0xWMyA9IGAoPzpcXFxccyosXFxcXHMqKD86JHtOVU19fCR7UENUfSkpP2A7XG5jb25zdCBfQ09MT1JfRlVOQyA9IFwiKD86b2spP2woPzphYnxjaCl8Y29sb3J8aHNsYT98aHdifHJnYmE/XCI7XG5jb25zdCBfQ09MT1JfS0VZID0gXCJbYS16XSt8I1tcXFxcZGEtZl17M318I1tcXFxcZGEtZl17NH18I1tcXFxcZGEtZl17Nn18I1tcXFxcZGEtZl17OH1cIjtcbmNvbnN0IF9DU19IVUUgPSBcIig/Om9rKT9sY2h8aHNsfGh3YlwiO1xuY29uc3QgX0NTX0hVRV9BUkMgPSBcIig/OmRlfGluKWNyZWFzaW5nfGxvbmdlcnxzaG9ydGVyXCI7XG5jb25zdCBfTlVNX0FOR0xFID0gYCR7TlVNfSg/OiR7QU5HTEV9KT9gO1xuY29uc3QgX05VTV9BTkdMRV9OT05FID0gYCg/OiR7TlVNfSg/OiR7QU5HTEV9KT98JHtOT05FfSlgO1xuY29uc3QgX05VTV9QQ1RfTk9ORSA9IGAoPzoke05VTX18JHtQQ1R9fCR7Tk9ORX0pYDtcbmNvbnN0IENTX0hVRSA9IGAoPzoke19DU19IVUV9KSg/OlxcXFxzKD86JHtfQ1NfSFVFX0FSQ30pXFxcXHNodWUpP2A7XG5jb25zdCBDU19IVUVfQ0FQVCA9IGAoJHtfQ1NfSFVFfSkoPzpcXFxccygke19DU19IVUVfQVJDfSlcXFxcc2h1ZSk/YDtcbmNvbnN0IENTX0xBQiA9IFwiKD86b2spP2xhYlwiO1xuY29uc3QgQ1NfTENIID0gXCIoPzpvayk/bGNoXCI7XG5jb25zdCBDU19TUkdCID0gXCJzcmdiKD86LWxpbmVhcik/XCI7XG5jb25zdCBDU19SR0IgPSBgKD86YTk4fHByb3Bob3RvKS1yZ2J8ZGlzcGxheS1wM3xyZWMyMDIwfCR7Q1NfU1JHQn1gO1xuY29uc3QgQ1NfWFlaID0gXCJ4eXooPzotZCg/OjUwfDY1KSk/XCI7XG5jb25zdCBDU19NSVggPSBgJHtDU19IVUV9fCR7Q1NfTEFCfXwke0NTX1NSR0J9fCR7Q1NfWFlafWA7XG5jb25zdCBGTl9DT0xPUiA9IFwiY29sb3IoXCI7XG5jb25zdCBGTl9NSVggPSBcImNvbG9yLW1peChcIjtcbmNvbnN0IEZOX1JFTCA9IGAoPzoke19DT0xPUl9GVU5DfSlcXFxcKFxcXFxzKmZyb21cXFxccytgO1xuY29uc3QgRk5fUkVMX0NBUFQgPSBgKCR7X0NPTE9SX0ZVTkN9KVxcXFwoXFxcXHMqZnJvbVxcXFxzK2A7XG5jb25zdCBGTl9WQVIgPSBcInZhcihcIjtcbmNvbnN0IFNZTl9GTl9DT0xPUiA9IGAoPzoke0NTX1JHQn18JHtDU19YWVp9KSg/OlxcXFxzKyR7X05VTV9QQ1RfTk9ORX0pezN9JHtfQUxQSEF9YDtcbmNvbnN0IFNZTl9GTl9SRUwgPSBgXiR7Rk5fUkVMfXwoPzw9W1xcXFxzXSkke0ZOX1JFTH1gO1xuY29uc3QgU1lOX0hTTCA9IGAke19OVU1fQU5HTEVfTk9ORX0oPzpcXFxccyske19OVU1fUENUX05PTkV9KXsyfSR7X0FMUEhBfWA7XG5jb25zdCBTWU5fSFNMX0xWMyA9IGAke19OVU1fQU5HTEV9KD86XFxcXHMqLFxcXFxzKiR7UENUfSl7Mn0ke19BTFBIQV9MVjN9YDtcbmNvbnN0IFNZTl9MQ0ggPSBgKD86JHtfTlVNX1BDVF9OT05FfVxcXFxzKyl7Mn0ke19OVU1fQU5HTEVfTk9ORX0ke19BTFBIQX1gO1xuY29uc3QgU1lOX01PRCA9IGAke19OVU1fUENUX05PTkV9KD86XFxcXHMrJHtfTlVNX1BDVF9OT05FfSl7Mn0ke19BTFBIQX1gO1xuY29uc3QgU1lOX1JHQl9MVjMgPSBgKD86JHtOVU19KD86XFxcXHMqLFxcXFxzKiR7TlVNfSl7Mn18JHtQQ1R9KD86XFxcXHMqLFxcXFxzKiR7UENUfSl7Mn0pJHtfQUxQSEFfTFYzfWA7XG5jb25zdCBTWU5fQ09MT1JfVFlQRSA9IGAke19DT0xPUl9LRVl9fGhzbGE/XFxcXChcXFxccyoke1NZTl9IU0xfTFYzfVxcXFxzKlxcXFwpfHJnYmE/XFxcXChcXFxccyoke1NZTl9SR0JfTFYzfVxcXFxzKlxcXFwpfCg/OmhzbGE/fGh3YilcXFxcKFxcXFxzKiR7U1lOX0hTTH1cXFxccypcXFxcKXwoPzooPzpvayk/bGFifHJnYmE/KVxcXFwoXFxcXHMqJHtTWU5fTU9EfVxcXFxzKlxcXFwpfCg/Om9rKT9sY2hcXFxcKFxcXFxzKiR7U1lOX0xDSH1cXFxccypcXFxcKXxjb2xvclxcXFwoXFxcXHMqJHtTWU5fRk5fQ09MT1J9XFxcXHMqXFxcXClgO1xuY29uc3QgU1lOX01JWF9QQVJUID0gYCg/OiR7U1lOX0NPTE9SX1RZUEV9KSg/OlxcXFxzKyR7UENUfSk/YDtcbmNvbnN0IFNZTl9NSVggPSBgY29sb3ItbWl4XFxcXChcXFxccyppblxcXFxzKyg/OiR7Q1NfTUlYfSlcXFxccyosXFxcXHMqJHtTWU5fTUlYX1BBUlR9XFxcXHMqLFxcXFxzKiR7U1lOX01JWF9QQVJUfVxcXFxzKlxcXFwpYDtcbmNvbnN0IFNZTl9NSVhfQ0FQVCA9IGBjb2xvci1taXhcXFxcKFxcXFxzKmluXFxcXHMrKCR7Q1NfTUlYfSlcXFxccyosXFxcXHMqKCR7U1lOX01JWF9QQVJUfSlcXFxccyosXFxcXHMqKCR7U1lOX01JWF9QQVJUfSlcXFxccypcXFxcKWA7XG5leHBvcnRzLkFOR0xFID0gQU5HTEU7XG5leHBvcnRzLkNTX0hVRSA9IENTX0hVRTtcbmV4cG9ydHMuQ1NfSFVFX0NBUFQgPSBDU19IVUVfQ0FQVDtcbmV4cG9ydHMuQ1NfTEFCID0gQ1NfTEFCO1xuZXhwb3J0cy5DU19MQ0ggPSBDU19MQ0g7XG5leHBvcnRzLkNTX01JWCA9IENTX01JWDtcbmV4cG9ydHMuQ1NfUkdCID0gQ1NfUkdCO1xuZXhwb3J0cy5DU19TUkdCID0gQ1NfU1JHQjtcbmV4cG9ydHMuQ1NfWFlaID0gQ1NfWFlaO1xuZXhwb3J0cy5GTl9DT0xPUiA9IEZOX0NPTE9SO1xuZXhwb3J0cy5GTl9NSVggPSBGTl9NSVg7XG5leHBvcnRzLkZOX1JFTCA9IEZOX1JFTDtcbmV4cG9ydHMuRk5fUkVMX0NBUFQgPSBGTl9SRUxfQ0FQVDtcbmV4cG9ydHMuRk5fVkFSID0gRk5fVkFSO1xuZXhwb3J0cy5OT05FID0gTk9ORTtcbmV4cG9ydHMuTlVNID0gTlVNO1xuZXhwb3J0cy5QQ1QgPSBQQ1Q7XG5leHBvcnRzLlNZTl9DT0xPUl9UWVBFID0gU1lOX0NPTE9SX1RZUEU7XG5leHBvcnRzLlNZTl9GTl9DT0xPUiA9IFNZTl9GTl9DT0xPUjtcbmV4cG9ydHMuU1lOX0ZOX01BVEggPSBTWU5fRk5fTUFUSDtcbmV4cG9ydHMuU1lOX0ZOX01BVEhfQ0FMQyA9IFNZTl9GTl9NQVRIX0NBTEM7XG5leHBvcnRzLlNZTl9GTl9NQVRIX1ZBUiA9IFNZTl9GTl9NQVRIX1ZBUjtcbmV4cG9ydHMuU1lOX0ZOX1JFTCA9IFNZTl9GTl9SRUw7XG5leHBvcnRzLlNZTl9GTl9WQVIgPSBTWU5fRk5fVkFSO1xuZXhwb3J0cy5TWU5fSFNMID0gU1lOX0hTTDtcbmV4cG9ydHMuU1lOX0hTTF9MVjMgPSBTWU5fSFNMX0xWMztcbmV4cG9ydHMuU1lOX0xDSCA9IFNZTl9MQ0g7XG5leHBvcnRzLlNZTl9NSVggPSBTWU5fTUlYO1xuZXhwb3J0cy5TWU5fTUlYX0NBUFQgPSBTWU5fTUlYX0NBUFQ7XG5leHBvcnRzLlNZTl9NSVhfUEFSVCA9IFNZTl9NSVhfUEFSVDtcbmV4cG9ydHMuU1lOX01PRCA9IFNZTl9NT0Q7XG5leHBvcnRzLlNZTl9SR0JfTFYzID0gU1lOX1JHQl9MVjM7XG5leHBvcnRzLlZBTF9DT01QID0gVkFMX0NPTVA7XG5leHBvcnRzLlZBTF9TUEVDID0gVkFMX1NQRUM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudC5janMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/convert.cjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/convert.cjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst lruCache = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/commonjs/index.js\");\nconst color = __webpack_require__(/*! ./color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs\");\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst cssCalc = __webpack_require__(/*! ./css-calc.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\");\nconst cssVar = __webpack_require__(/*! ./css-var.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-var.cjs\");\nconst relativeColor = __webpack_require__(/*! ./relative-color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/relative-color.cjs\");\nconst resolve = __webpack_require__(/*! ./resolve.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst REG_FN_MATH_CALC = new RegExp(constant.SYN_FN_MATH_CALC);\nconst REG_FN_REL = new RegExp(constant.SYN_FN_REL);\nconst REG_FN_VAR = new RegExp(constant.SYN_FN_VAR);\nconst cachedResults = new lruCache.LRUCache({\n  max: 4096\n});\nconst preProcess = (value, opt = {}) => {\n  if (common.isString(value)) {\n    value = value.trim();\n    if (!value) {\n      return null;\n    }\n  } else {\n    return null;\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{preProcess:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  if (REG_FN_VAR.test(value)) {\n    const resolvedValue = cssVar.cssVar(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue;\n    } else {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, resolvedValue);\n      }\n      return null;\n    }\n  }\n  if (REG_FN_REL.test(value)) {\n    value = relativeColor.resolveRelativeColor(value, opt);\n  } else if (REG_FN_MATH_CALC.test(value)) {\n    const resolvedValue = cssCalc.cssCalc(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue;\n    } else {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, resolvedValue);\n      }\n      return null;\n    }\n  }\n  if (value.startsWith(\"color-mix\")) {\n    value = resolve.resolve(value, {\n      format: constant.VAL_COMP\n    });\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, value);\n  }\n  return value;\n};\nconst numberToHex = (value) => {\n  const cacheKey = typeof value === \"number\" && `{numberToHex:${value}}`;\n  if (cacheKey && cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const hex = color.numberToHexString(value);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, hex);\n  }\n  return hex;\n};\nconst colorToHex = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return null;\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { alpha, customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToHex:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  let hex;\n  if (alpha) {\n    opt.format = \"hexAlpha\";\n    hex = resolve.resolve(value, opt);\n  } else {\n    opt.format = \"hex\";\n    hex = resolve.resolve(value, opt);\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, hex);\n  }\n  return hex;\n};\nconst colorToHsl = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToHsl:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  opt.format = \"hsl\";\n  const hsl = color.convertColorToHsl(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, hsl);\n  }\n  return hsl;\n};\nconst colorToHwb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToHwb:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  opt.format = \"hwb\";\n  const hwb = color.convertColorToHwb(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, hwb);\n  }\n  return hwb;\n};\nconst colorToLab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToLab:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const lab = color.convertColorToLab(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, lab);\n  }\n  return lab;\n};\nconst colorToLch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToLch:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const lch = color.convertColorToLch(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, lch);\n  }\n  return lch;\n};\nconst colorToOklab = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToOklab:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const lab = color.convertColorToOklab(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, lab);\n  }\n  return lab;\n};\nconst colorToOklch = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToOklch:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const lch = color.convertColorToOklch(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, lch);\n  }\n  return lch;\n};\nconst colorToRgb = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToRgb:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const rgb = color.convertColorToRgb(value, opt);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, rgb);\n  }\n  return rgb;\n};\nconst colorToXyz = (value, opt = {}) => {\n  if (common.isString(value)) {\n    const resolvedValue = preProcess(value, opt);\n    if (resolvedValue) {\n      value = resolvedValue.toLowerCase();\n    } else {\n      return [0, 0, 0, 0];\n    }\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { customProperty } = opt;\n  let cacheKey;\n  if (typeof (customProperty == null ? void 0 : customProperty.callback) !== \"function\") {\n    cacheKey = `{colorToXyz:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  let xyz;\n  if (value.startsWith(\"color(\")) {\n    [, ...xyz] = color.parseColorFunc(value, opt);\n  } else {\n    [, ...xyz] = color.parseColorValue(value, opt);\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, xyz);\n  }\n  return xyz;\n};\nconst colorToXyzD50 = (value, opt = {}) => {\n  opt.d50 = true;\n  return colorToXyz(value, opt);\n};\nconst convert = {\n  colorToHex,\n  colorToHsl,\n  colorToHwb,\n  colorToLab,\n  colorToLch,\n  colorToOklab,\n  colorToOklch,\n  colorToRgb,\n  colorToXyz,\n  colorToXyzD50,\n  numberToHex\n};\nexports.cachedResults = cachedResults;\nexports.colorToHex = colorToHex;\nexports.colorToHsl = colorToHsl;\nexports.colorToHwb = colorToHwb;\nexports.colorToLab = colorToLab;\nexports.colorToLch = colorToLch;\nexports.colorToOklab = colorToOklab;\nexports.colorToOklch = colorToOklch;\nexports.colorToRgb = colorToRgb;\nexports.colorToXyz = colorToXyz;\nexports.colorToXyzD50 = colorToXyzD50;\nexports.convert = convert;\nexports.numberToHex = numberToHex;\nexports.preProcess = preProcess;\n//# sourceMappingURL=convert.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY29udmVydC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFLGlCQUFpQixtQkFBTyxDQUFDLDRHQUFXO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxvSUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWdCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx3SUFBZTtBQUN0QyxzQkFBc0IsbUJBQU8sQ0FBQyxzSkFBc0I7QUFDcEQsZ0JBQWdCLG1CQUFPLENBQUMsd0lBQWU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLGtJQUFZO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBJQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsTUFBTSxPQUFPLDZCQUE2QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7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Q0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyIvVXNlcnMvZnVqaWF3YW5nL0Rlc2t0b3AvY2hhdGJvdC9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY29udmVydC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgbHJ1Q2FjaGUgPSByZXF1aXJlKFwibHJ1LWNhY2hlXCIpO1xuY29uc3QgY29sb3IgPSByZXF1aXJlKFwiLi9jb2xvci5janNcIik7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKFwiLi9jb21tb24uY2pzXCIpO1xuY29uc3QgY3NzQ2FsYyA9IHJlcXVpcmUoXCIuL2Nzcy1jYWxjLmNqc1wiKTtcbmNvbnN0IGNzc1ZhciA9IHJlcXVpcmUoXCIuL2Nzcy12YXIuY2pzXCIpO1xuY29uc3QgcmVsYXRpdmVDb2xvciA9IHJlcXVpcmUoXCIuL3JlbGF0aXZlLWNvbG9yLmNqc1wiKTtcbmNvbnN0IHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmNqc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmNqc1wiKTtcbmNvbnN0IGNvbnN0YW50ID0gcmVxdWlyZShcIi4vY29uc3RhbnQuY2pzXCIpO1xuY29uc3QgUkVHX0ZOX01BVEhfQ0FMQyA9IG5ldyBSZWdFeHAoY29uc3RhbnQuU1lOX0ZOX01BVEhfQ0FMQyk7XG5jb25zdCBSRUdfRk5fUkVMID0gbmV3IFJlZ0V4cChjb25zdGFudC5TWU5fRk5fUkVMKTtcbmNvbnN0IFJFR19GTl9WQVIgPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9WQVIpO1xuY29uc3QgY2FjaGVkUmVzdWx0cyA9IG5ldyBscnVDYWNoZS5MUlVDYWNoZSh7XG4gIG1heDogNDA5NlxufSk7XG5jb25zdCBwcmVQcm9jZXNzID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IGN1c3RvbVByb3BlcnR5IH0gPSBvcHQ7XG4gIGxldCBjYWNoZUtleTtcbiAgaWYgKHR5cGVvZiAoY3VzdG9tUHJvcGVydHkgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbVByb3BlcnR5LmNhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FjaGVLZXkgPSBge3ByZVByb2Nlc3M6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICAgIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICB9XG4gIGlmIChSRUdfRk5fVkFSLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IGNzc1Zhci5jc3NWYXIodmFsdWUsIG9wdCk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCByZXNvbHZlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoUkVHX0ZOX1JFTC50ZXN0KHZhbHVlKSkge1xuICAgIHZhbHVlID0gcmVsYXRpdmVDb2xvci5yZXNvbHZlUmVsYXRpdmVDb2xvcih2YWx1ZSwgb3B0KTtcbiAgfSBlbHNlIGlmIChSRUdfRk5fTUFUSF9DQUxDLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IGNzc0NhbGMuY3NzQ2FsYyh2YWx1ZSwgb3B0KTtcbiAgICBpZiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSByZXNvbHZlZFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlc29sdmVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiY29sb3ItbWl4XCIpKSB7XG4gICAgdmFsdWUgPSByZXNvbHZlLnJlc29sdmUodmFsdWUsIHtcbiAgICAgIGZvcm1hdDogY29uc3RhbnQuVkFMX0NPTVBcbiAgICB9KTtcbiAgfVxuICBpZiAoY2FjaGVLZXkpIHtcbiAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBjYWNoZUtleSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBge251bWJlclRvSGV4OiR7dmFsdWV9fWA7XG4gIGlmIChjYWNoZUtleSAmJiBjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIGNvbnN0IGhleCA9IGNvbG9yLm51bWJlclRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn07XG5jb25zdCBjb2xvclRvSGV4ID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBwcmVQcm9jZXNzKHZhbHVlLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHJlc29sdmVkVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGFscGhhLCBjdXN0b21Qcm9wZXJ0eSB9ID0gb3B0O1xuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgKGN1c3RvbVByb3BlcnR5ID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21Qcm9wZXJ0eS5jYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjb2xvclRvSGV4OiR7dmFsdWV9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBsZXQgaGV4O1xuICBpZiAoYWxwaGEpIHtcbiAgICBvcHQuZm9ybWF0ID0gXCJoZXhBbHBoYVwiO1xuICAgIGhleCA9IHJlc29sdmUucmVzb2x2ZSh2YWx1ZSwgb3B0KTtcbiAgfSBlbHNlIHtcbiAgICBvcHQuZm9ybWF0ID0gXCJoZXhcIjtcbiAgICBoZXggPSByZXNvbHZlLnJlc29sdmUodmFsdWUsIG9wdCk7XG4gIH1cbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn07XG5jb25zdCBjb2xvclRvSHNsID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBwcmVQcm9jZXNzKHZhbHVlLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHJlc29sdmVkVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY3VzdG9tUHJvcGVydHkgfSA9IG9wdDtcbiAgbGV0IGNhY2hlS2V5O1xuICBpZiAodHlwZW9mIChjdXN0b21Qcm9wZXJ0eSA9PSBudWxsID8gdm9pZCAwIDogY3VzdG9tUHJvcGVydHkuY2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWNoZUtleSA9IGB7Y29sb3JUb0hzbDoke3ZhbHVlfSxvcHQ6JHt1dGlsLnZhbHVlVG9Kc29uU3RyaW5nKG9wdCl9fWA7XG4gICAgaWYgKGNhY2hlZFJlc3VsdHMuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdHMuZ2V0KGNhY2hlS2V5KTtcbiAgICB9XG4gIH1cbiAgb3B0LmZvcm1hdCA9IFwiaHNsXCI7XG4gIGNvbnN0IGhzbCA9IGNvbG9yLmNvbnZlcnRDb2xvclRvSHNsKHZhbHVlLCBvcHQpO1xuICBpZiAoY2FjaGVLZXkpIHtcbiAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgaHNsKTtcbiAgfVxuICByZXR1cm4gaHNsO1xufTtcbmNvbnN0IGNvbG9yVG9Id2IgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHByZVByb2Nlc3ModmFsdWUsIG9wdCk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcmVzb2x2ZWRWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBjdXN0b21Qcm9wZXJ0eSB9ID0gb3B0O1xuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgKGN1c3RvbVByb3BlcnR5ID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21Qcm9wZXJ0eS5jYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjb2xvclRvSHdiOiR7dmFsdWV9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBvcHQuZm9ybWF0ID0gXCJod2JcIjtcbiAgY29uc3QgaHdiID0gY29sb3IuY29udmVydENvbG9yVG9Id2IodmFsdWUsIG9wdCk7XG4gIGlmIChjYWNoZUtleSkge1xuICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBod2IpO1xuICB9XG4gIHJldHVybiBod2I7XG59O1xuY29uc3QgY29sb3JUb0xhYiA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gcHJlUHJvY2Vzcyh2YWx1ZSwgb3B0KTtcbiAgICBpZiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSByZXNvbHZlZFZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBjb25zdCB7IGN1c3RvbVByb3BlcnR5IH0gPSBvcHQ7XG4gIGxldCBjYWNoZUtleTtcbiAgaWYgKHR5cGVvZiAoY3VzdG9tUHJvcGVydHkgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbVByb3BlcnR5LmNhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FjaGVLZXkgPSBge2NvbG9yVG9MYWI6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICAgIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxhYiA9IGNvbG9yLmNvbnZlcnRDb2xvclRvTGFiKHZhbHVlLCBvcHQpO1xuICBpZiAoY2FjaGVLZXkpIHtcbiAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgbGFiKTtcbiAgfVxuICByZXR1cm4gbGFiO1xufTtcbmNvbnN0IGNvbG9yVG9MY2ggPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHByZVByb2Nlc3ModmFsdWUsIG9wdCk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcmVzb2x2ZWRWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBjdXN0b21Qcm9wZXJ0eSB9ID0gb3B0O1xuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgKGN1c3RvbVByb3BlcnR5ID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21Qcm9wZXJ0eS5jYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjb2xvclRvTGNoOiR7dmFsdWV9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBsY2ggPSBjb2xvci5jb252ZXJ0Q29sb3JUb0xjaCh2YWx1ZSwgb3B0KTtcbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIGxjaCk7XG4gIH1cbiAgcmV0dXJuIGxjaDtcbn07XG5jb25zdCBjb2xvclRvT2tsYWIgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHByZVByb2Nlc3ModmFsdWUsIG9wdCk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcmVzb2x2ZWRWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBjdXN0b21Qcm9wZXJ0eSB9ID0gb3B0O1xuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgKGN1c3RvbVByb3BlcnR5ID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21Qcm9wZXJ0eS5jYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjb2xvclRvT2tsYWI6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICAgIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxhYiA9IGNvbG9yLmNvbnZlcnRDb2xvclRvT2tsYWIodmFsdWUsIG9wdCk7XG4gIGlmIChjYWNoZUtleSkge1xuICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBsYWIpO1xuICB9XG4gIHJldHVybiBsYWI7XG59O1xuY29uc3QgY29sb3JUb09rbGNoID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBwcmVQcm9jZXNzKHZhbHVlLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHJlc29sdmVkVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY3VzdG9tUHJvcGVydHkgfSA9IG9wdDtcbiAgbGV0IGNhY2hlS2V5O1xuICBpZiAodHlwZW9mIChjdXN0b21Qcm9wZXJ0eSA9PSBudWxsID8gdm9pZCAwIDogY3VzdG9tUHJvcGVydHkuY2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWNoZUtleSA9IGB7Y29sb3JUb09rbGNoOiR7dmFsdWV9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBsY2ggPSBjb2xvci5jb252ZXJ0Q29sb3JUb09rbGNoKHZhbHVlLCBvcHQpO1xuICBpZiAoY2FjaGVLZXkpIHtcbiAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgbGNoKTtcbiAgfVxuICByZXR1cm4gbGNoO1xufTtcbmNvbnN0IGNvbG9yVG9SZ2IgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGlmIChjb21tb24uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHByZVByb2Nlc3ModmFsdWUsIG9wdCk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcmVzb2x2ZWRWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIH1cbiAgY29uc3QgeyBjdXN0b21Qcm9wZXJ0eSB9ID0gb3B0O1xuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgKGN1c3RvbVByb3BlcnR5ID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21Qcm9wZXJ0eS5jYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjb2xvclRvUmdiOiR7dmFsdWV9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBjb25zdCByZ2IgPSBjb2xvci5jb252ZXJ0Q29sb3JUb1JnYih2YWx1ZSwgb3B0KTtcbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJnYik7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn07XG5jb25zdCBjb2xvclRvWHl6ID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBwcmVQcm9jZXNzKHZhbHVlLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHJlc29sdmVkVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY3VzdG9tUHJvcGVydHkgfSA9IG9wdDtcbiAgbGV0IGNhY2hlS2V5O1xuICBpZiAodHlwZW9mIChjdXN0b21Qcm9wZXJ0eSA9PSBudWxsID8gdm9pZCAwIDogY3VzdG9tUHJvcGVydHkuY2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWNoZUtleSA9IGB7Y29sb3JUb1h5ejoke3ZhbHVlfSxvcHQ6JHt1dGlsLnZhbHVlVG9Kc29uU3RyaW5nKG9wdCl9fWA7XG4gICAgaWYgKGNhY2hlZFJlc3VsdHMuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdHMuZ2V0KGNhY2hlS2V5KTtcbiAgICB9XG4gIH1cbiAgbGV0IHh5ejtcbiAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJjb2xvcihcIikpIHtcbiAgICBbLCAuLi54eXpdID0gY29sb3IucGFyc2VDb2xvckZ1bmModmFsdWUsIG9wdCk7XG4gIH0gZWxzZSB7XG4gICAgWywgLi4ueHl6XSA9IGNvbG9yLnBhcnNlQ29sb3JWYWx1ZSh2YWx1ZSwgb3B0KTtcbiAgfVxuICBpZiAoY2FjaGVLZXkpIHtcbiAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgeHl6KTtcbiAgfVxuICByZXR1cm4geHl6O1xufTtcbmNvbnN0IGNvbG9yVG9YeXpENTAgPSAodmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIG9wdC5kNTAgPSB0cnVlO1xuICByZXR1cm4gY29sb3JUb1h5eih2YWx1ZSwgb3B0KTtcbn07XG5jb25zdCBjb252ZXJ0ID0ge1xuICBjb2xvclRvSGV4LFxuICBjb2xvclRvSHNsLFxuICBjb2xvclRvSHdiLFxuICBjb2xvclRvTGFiLFxuICBjb2xvclRvTGNoLFxuICBjb2xvclRvT2tsYWIsXG4gIGNvbG9yVG9Pa2xjaCxcbiAgY29sb3JUb1JnYixcbiAgY29sb3JUb1h5eixcbiAgY29sb3JUb1h5ekQ1MCxcbiAgbnVtYmVyVG9IZXhcbn07XG5leHBvcnRzLmNhY2hlZFJlc3VsdHMgPSBjYWNoZWRSZXN1bHRzO1xuZXhwb3J0cy5jb2xvclRvSGV4ID0gY29sb3JUb0hleDtcbmV4cG9ydHMuY29sb3JUb0hzbCA9IGNvbG9yVG9Ic2w7XG5leHBvcnRzLmNvbG9yVG9Id2IgPSBjb2xvclRvSHdiO1xuZXhwb3J0cy5jb2xvclRvTGFiID0gY29sb3JUb0xhYjtcbmV4cG9ydHMuY29sb3JUb0xjaCA9IGNvbG9yVG9MY2g7XG5leHBvcnRzLmNvbG9yVG9Pa2xhYiA9IGNvbG9yVG9Pa2xhYjtcbmV4cG9ydHMuY29sb3JUb09rbGNoID0gY29sb3JUb09rbGNoO1xuZXhwb3J0cy5jb2xvclRvUmdiID0gY29sb3JUb1JnYjtcbmV4cG9ydHMuY29sb3JUb1h5eiA9IGNvbG9yVG9YeXo7XG5leHBvcnRzLmNvbG9yVG9YeXpENTAgPSBjb2xvclRvWHl6RDUwO1xuZXhwb3J0cy5jb252ZXJ0ID0gY29udmVydDtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbmV4cG9ydHMucHJlUHJvY2VzcyA9IHByZVByb2Nlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0LmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/convert.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _hasNum, _numSum, _numMul, _hasPct, _pctSum, _pctMul, _hasDim, _dimSum, _dimSub, _dimMul, _dimDiv, _hasEtc, _etcSum, _etcSub, _etcMul, _etcDiv;\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst cssCalc$1 = __webpack_require__(/*! @csstools/css-calc */ \"(ssr)/./node_modules/.pnpm/@csstools+css-calc@2.1.1_@csstools+css-parser-algorithms@3.0.4_@csstools+css-tokenizer@3.0.3__vlj2ym64kb6jtc2hg2j3v45yym/node_modules/@csstools/css-calc/dist/index.cjs\");\nconst cssTokenizer = __webpack_require__(/*! @csstools/css-tokenizer */ \"(ssr)/./node_modules/.pnpm/@csstools+css-tokenizer@3.0.3/node_modules/@csstools/css-tokenizer/dist/index.cjs\");\nconst lruCache = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/commonjs/index.js\");\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  OpenParen: PAREN_OPEN,\n  Whitespace: W_SPACE\n} = cssTokenizer.TokenType;\nconst HEX = 16;\nconst MAX_PCT = 100;\nconst REG_FN_MATH_CALC = new RegExp(constant.SYN_FN_MATH_CALC);\nconst REG_FN_VAR = new RegExp(constant.SYN_FN_VAR);\nconst REG_OPERATOR = /\\s[*+/-]\\s/;\nconst REG_START_MATH = new RegExp(constant.SYN_FN_MATH);\nconst REG_START_MATH_VAR = new RegExp(constant.SYN_FN_MATH_VAR);\nconst REG_TYPE_DIM = new RegExp(`^(${constant.NUM})([a-z]+)$`);\nconst REG_TYPE_DIM_PCT = new RegExp(`^(${constant.NUM})([a-z]+|%)$`);\nconst REG_TYPE_PCT = new RegExp(`^(${constant.NUM})%$`);\nconst cachedResults = new lruCache.LRUCache({\n  max: 4096\n});\nclass Calculator {\n  /**\n   * constructor\n   */\n  constructor() {\n    /* private */\n    // number\n    __privateAdd(this, _hasNum);\n    __privateAdd(this, _numSum);\n    __privateAdd(this, _numMul);\n    // percentage\n    __privateAdd(this, _hasPct);\n    __privateAdd(this, _pctSum);\n    __privateAdd(this, _pctMul);\n    // dimension\n    __privateAdd(this, _hasDim);\n    __privateAdd(this, _dimSum);\n    __privateAdd(this, _dimSub);\n    __privateAdd(this, _dimMul);\n    __privateAdd(this, _dimDiv);\n    // et cetra\n    __privateAdd(this, _hasEtc);\n    __privateAdd(this, _etcSum);\n    __privateAdd(this, _etcSub);\n    __privateAdd(this, _etcMul);\n    __privateAdd(this, _etcDiv);\n    __privateSet(this, _hasNum, false);\n    __privateSet(this, _numSum, []);\n    __privateSet(this, _numMul, []);\n    __privateSet(this, _hasPct, false);\n    __privateSet(this, _pctSum, []);\n    __privateSet(this, _pctMul, []);\n    __privateSet(this, _hasDim, false);\n    __privateSet(this, _dimSum, []);\n    __privateSet(this, _dimSub, []);\n    __privateSet(this, _dimMul, []);\n    __privateSet(this, _dimDiv, []);\n    __privateSet(this, _hasEtc, false);\n    __privateSet(this, _etcSum, []);\n    __privateSet(this, _etcSub, []);\n    __privateSet(this, _etcMul, []);\n    __privateSet(this, _etcDiv, []);\n  }\n  get hasNum() {\n    return __privateGet(this, _hasNum);\n  }\n  set hasNum(value) {\n    __privateSet(this, _hasNum, !!value);\n  }\n  get numSum() {\n    return __privateGet(this, _numSum);\n  }\n  get numMul() {\n    return __privateGet(this, _numMul);\n  }\n  get hasPct() {\n    return __privateGet(this, _hasPct);\n  }\n  set hasPct(value) {\n    __privateSet(this, _hasPct, !!value);\n  }\n  get pctSum() {\n    return __privateGet(this, _pctSum);\n  }\n  get pctMul() {\n    return __privateGet(this, _pctMul);\n  }\n  get hasDim() {\n    return __privateGet(this, _hasDim);\n  }\n  set hasDim(value) {\n    __privateSet(this, _hasDim, !!value);\n  }\n  get dimSum() {\n    return __privateGet(this, _dimSum);\n  }\n  get dimSub() {\n    return __privateGet(this, _dimSub);\n  }\n  get dimMul() {\n    return __privateGet(this, _dimMul);\n  }\n  get dimDiv() {\n    return __privateGet(this, _dimDiv);\n  }\n  get hasEtc() {\n    return __privateGet(this, _hasEtc);\n  }\n  set hasEtc(value) {\n    __privateSet(this, _hasEtc, !!value);\n  }\n  get etcSum() {\n    return __privateGet(this, _etcSum);\n  }\n  get etcSub() {\n    return __privateGet(this, _etcSub);\n  }\n  get etcMul() {\n    return __privateGet(this, _etcMul);\n  }\n  get etcDiv() {\n    return __privateGet(this, _etcDiv);\n  }\n  /**\n   * clear values\n   * @returns {void}\n   */\n  clear() {\n    __privateSet(this, _hasNum, false);\n    __privateSet(this, _numSum, []);\n    __privateSet(this, _numMul, []);\n    __privateSet(this, _hasPct, false);\n    __privateSet(this, _pctSum, []);\n    __privateSet(this, _pctMul, []);\n    __privateSet(this, _hasDim, false);\n    __privateSet(this, _dimSum, []);\n    __privateSet(this, _dimSub, []);\n    __privateSet(this, _dimMul, []);\n    __privateSet(this, _dimDiv, []);\n    __privateSet(this, _hasEtc, false);\n    __privateSet(this, _etcSum, []);\n    __privateSet(this, _etcSub, []);\n    __privateSet(this, _etcMul, []);\n    __privateSet(this, _etcDiv, []);\n  }\n  /**\n   * sort values\n   * @param {Array} values - values\n   * @returns {Array} - sorted values\n   */\n  sort(values = []) {\n    const arr = [...values];\n    if (arr.length > 1) {\n      arr.sort((a, b) => {\n        let res;\n        if (REG_TYPE_DIM_PCT.test(a) && REG_TYPE_DIM_PCT.test(b)) {\n          const [, valA, unitA] = a.match(REG_TYPE_DIM_PCT);\n          const [, valB, unitB] = b.match(REG_TYPE_DIM_PCT);\n          if (unitA === unitB) {\n            if (Number(valA) === Number(valB)) {\n              res = 0;\n            } else if (Number(valA) > Number(valB)) {\n              res = 1;\n            } else {\n              res = -1;\n            }\n          } else if (unitA > unitB) {\n            res = 1;\n          } else {\n            res = -1;\n          }\n        } else {\n          if (a === b) {\n            res = 0;\n          } else if (a > b) {\n            res = 1;\n          } else {\n            res = -1;\n          }\n        }\n        return res;\n      });\n    }\n    return arr;\n  }\n  /**\n   * multiply values\n   * @returns {?string} - resolved value\n   */\n  multiply() {\n    const value = [];\n    let num;\n    if (__privateGet(this, _hasNum)) {\n      num = 1;\n      for (const i of __privateGet(this, _numMul)) {\n        num *= i;\n        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      if (!__privateGet(this, _hasPct) && !__privateGet(this, _hasDim) && !this.hasEtc) {\n        value.push(num);\n      }\n    }\n    if (__privateGet(this, _hasPct)) {\n      if (!__privateGet(this, _hasNum)) {\n        num = 1;\n      }\n      for (const i of __privateGet(this, _pctMul)) {\n        num *= i;\n        if (num === 0 || !Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      if (Number.isFinite(num)) {\n        num = `${num}%`;\n      }\n      if (!__privateGet(this, _hasDim) && !this.hasEtc) {\n        value.push(num);\n      }\n    }\n    if (__privateGet(this, _hasDim)) {\n      let dim, mul, div;\n      if (__privateGet(this, _dimMul).length) {\n        if (__privateGet(this, _dimMul).length === 1) {\n          [mul] = __privateGet(this, _dimMul);\n        } else {\n          mul = `${this.sort(__privateGet(this, _dimMul)).join(\" * \")}`;\n        }\n      }\n      if (__privateGet(this, _dimDiv).length) {\n        if (__privateGet(this, _dimDiv).length === 1) {\n          [div] = __privateGet(this, _dimDiv);\n        } else {\n          div = `${this.sort(__privateGet(this, _dimDiv)).join(\" * \")}`;\n        }\n      }\n      if (Number.isFinite(num)) {\n        if (mul) {\n          if (div) {\n            if (div.includes(\"*\")) {\n              dim = cssCalc$1.calc(`calc(${num} * ${mul} / (${div}))`, {\n                toCanonicalUnits: true\n              });\n            } else {\n              dim = cssCalc$1.calc(`calc(${num} * ${mul} / ${div})`, {\n                toCanonicalUnits: true\n              });\n            }\n          } else {\n            dim = cssCalc$1.calc(`calc(${num} * ${mul})`, {\n              toCanonicalUnits: true\n            });\n          }\n        } else {\n          if (div.includes(\"*\")) {\n            dim = cssCalc$1.calc(`calc(${num} / (${div}))`, {\n              toCanonicalUnits: true\n            });\n          } else {\n            dim = cssCalc$1.calc(`calc(${num} / ${div})`, {\n              toCanonicalUnits: true\n            });\n          }\n        }\n        value.push(dim.replace(/^calc/, \"\"));\n      } else {\n        if (!value.length && num !== void 0) {\n          value.push(num);\n        }\n        if (mul) {\n          if (div) {\n            if (div.includes(\"*\")) {\n              dim = cssCalc$1.calc(`calc(${mul} / (${div}))`, {\n                toCanonicalUnits: true\n              });\n            } else {\n              dim = cssCalc$1.calc(`calc(${mul} / ${div})`, {\n                toCanonicalUnits: true\n              });\n            }\n          } else {\n            dim = cssCalc$1.calc(`calc(${mul})`, {\n              toCanonicalUnits: true\n            });\n          }\n          if (value.length) {\n            value.push(\"*\", dim.replace(/^calc/, \"\"));\n          } else {\n            value.push(dim.replace(/^calc/, \"\"));\n          }\n        } else {\n          dim = cssCalc$1.calc(`calc(${div})`, {\n            toCanonicalUnits: true\n          });\n          if (value.length) {\n            value.push(\"/\", dim.replace(/^calc/, \"\"));\n          } else {\n            value.push(\"1\", \"/\", dim.replace(/^calc/, \"\"));\n          }\n        }\n      }\n    }\n    if (__privateGet(this, _hasEtc)) {\n      if (__privateGet(this, _etcMul).length) {\n        if (!value.length && num !== void 0) {\n          value.push(num);\n        }\n        const mul = this.sort(__privateGet(this, _etcMul)).join(\" * \");\n        if (value.length) {\n          value.push(`* ${mul}`);\n        } else {\n          value.push(`${mul}`);\n        }\n      }\n      if (__privateGet(this, _etcDiv).length) {\n        const div = this.sort(__privateGet(this, _etcDiv)).join(\" * \");\n        if (div.includes(\"*\")) {\n          if (value.length) {\n            value.push(`/ (${div})`);\n          } else {\n            value.push(`1 / (${div})`);\n          }\n        } else if (value.length) {\n          value.push(`/ ${div}`);\n        } else {\n          value.push(`1 / ${div}`);\n        }\n      }\n    }\n    return value.join(\" \") || null;\n  }\n  /**\n   * sum values\n   * @returns {?string} - resolved value\n   */\n  sum() {\n    const value = [];\n    if (__privateGet(this, _hasNum)) {\n      let num = 0;\n      for (const i of __privateGet(this, _numSum)) {\n        num += i;\n        if (!Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      value.push(num);\n    }\n    if (__privateGet(this, _hasPct)) {\n      let num = 0;\n      for (const i of __privateGet(this, _pctSum)) {\n        num += i;\n        if (!Number.isFinite(num) || Number.isNaN(num)) {\n          break;\n        }\n      }\n      if (Number.isFinite(num)) {\n        num = `${num}%`;\n      }\n      if (value.length) {\n        value.push(`+ ${num}`);\n      } else {\n        value.push(num);\n      }\n    }\n    if (__privateGet(this, _hasDim)) {\n      let dim, sum, sub;\n      if (__privateGet(this, _dimSum).length) {\n        sum = __privateGet(this, _dimSum).join(\" + \");\n      }\n      if (__privateGet(this, _dimSub).length) {\n        sub = __privateGet(this, _dimSub).join(\" + \");\n      }\n      if (sum) {\n        if (sub) {\n          if (sub.includes(\"-\")) {\n            dim = cssCalc$1.calc(`calc(${sum} - (${sub}))`, {\n              toCanonicalUnits: true\n            });\n          } else {\n            dim = cssCalc$1.calc(`calc(${sum} - ${sub})`, {\n              toCanonicalUnits: true\n            });\n          }\n        } else {\n          dim = cssCalc$1.calc(`calc(${sum})`, {\n            toCanonicalUnits: true\n          });\n        }\n      } else {\n        dim = cssCalc$1.calc(`calc(-1 * (${sub}))`, {\n          toCanonicalUnits: true\n        });\n      }\n      if (value.length) {\n        value.push(\"+\", dim.replace(/^calc/, \"\"));\n      } else {\n        value.push(dim.replace(/^calc/, \"\"));\n      }\n    }\n    if (__privateGet(this, _hasEtc)) {\n      if (__privateGet(this, _etcSum).length) {\n        const sum = this.sort(__privateGet(this, _etcSum)).map((item) => {\n          let res;\n          if (REG_OPERATOR.test(item) && !item.startsWith(\"(\") && !item.endsWith(\")\")) {\n            res = `(${item})`;\n          } else {\n            res = item;\n          }\n          return res;\n        }).join(\" + \");\n        if (value.length) {\n          if (__privateGet(this, _etcSum).length > 1) {\n            value.push(`+ (${sum})`);\n          } else {\n            value.push(`+ ${sum}`);\n          }\n        } else {\n          value.push(`${sum}`);\n        }\n      }\n      if (__privateGet(this, _etcSub).length) {\n        const sub = this.sort(__privateGet(this, _etcSub)).map((item) => {\n          let res;\n          if (REG_OPERATOR.test(item) && !item.startsWith(\"(\") && !item.endsWith(\")\")) {\n            res = `(${item})`;\n          } else {\n            res = item;\n          }\n          return res;\n        }).join(\" + \");\n        if (value.length) {\n          if (__privateGet(this, _etcSub).length > 1) {\n            value.push(`- (${sub})`);\n          } else {\n            value.push(`- ${sub}`);\n          }\n        } else if (__privateGet(this, _etcSub).length > 1) {\n          value.push(`-1 * (${sub})`);\n        } else {\n          value.push(`-1 * ${sub}`);\n        }\n      }\n    }\n    return value.join(\" \") || null;\n  }\n}\n_hasNum = new WeakMap();\n_numSum = new WeakMap();\n_numMul = new WeakMap();\n_hasPct = new WeakMap();\n_pctSum = new WeakMap();\n_pctMul = new WeakMap();\n_hasDim = new WeakMap();\n_dimSum = new WeakMap();\n_dimSub = new WeakMap();\n_dimMul = new WeakMap();\n_dimDiv = new WeakMap();\n_hasEtc = new WeakMap();\n_etcSum = new WeakMap();\n_etcSub = new WeakMap();\n_etcMul = new WeakMap();\n_etcDiv = new WeakMap();\nconst sortCalcValues = (values = [], finalize = false) => {\n  if (values.length < 3) {\n    return null;\n  }\n  const start = values.shift();\n  const end = values.pop();\n  if (values.length === 1) {\n    const [value] = values;\n    return `${start}${value}${end}`;\n  }\n  const sortedValues = [];\n  const cal = new Calculator();\n  let operator;\n  for (let i = 0, l = values.length; i < l; i++) {\n    const value = values[i];\n    if (value === \"*\" || value === \"/\") {\n      operator = value;\n    } else if (value === \"+\" || value === \"-\") {\n      const sortedValue = cal.multiply();\n      sortedValues.push(sortedValue, value);\n      cal.clear();\n      operator = null;\n    } else {\n      switch (operator) {\n        case \"/\": {\n          const numValue = Number(value);\n          if (Number.isFinite(numValue)) {\n            cal.hasNum = true;\n            cal.numMul.push(1 / numValue);\n          } else if (REG_TYPE_PCT.test(value)) {\n            const [, val] = value.match(REG_TYPE_PCT);\n            cal.hasPct = true;\n            cal.pctMul.push(MAX_PCT * MAX_PCT / Number(val));\n          } else if (REG_TYPE_DIM.test(value)) {\n            cal.hasDim = true;\n            cal.dimDiv.push(value);\n          } else {\n            cal.hasEtc = true;\n            cal.etcDiv.push(value);\n          }\n          break;\n        }\n        case \"*\":\n        default: {\n          const numValue = Number(value);\n          if (Number.isFinite(numValue)) {\n            cal.hasNum = true;\n            cal.numMul.push(numValue);\n          } else if (REG_TYPE_PCT.test(value)) {\n            const [, val] = value.match(REG_TYPE_PCT);\n            cal.hasPct = true;\n            cal.pctMul.push(Number(val));\n          } else if (REG_TYPE_DIM.test(value)) {\n            cal.hasDim = true;\n            cal.dimMul.push(value);\n          } else {\n            cal.hasEtc = true;\n            cal.etcMul.push(value);\n          }\n        }\n      }\n      if (i === l - 1) {\n        const sortedValue = cal.multiply();\n        sortedValues.push(sortedValue);\n        cal.clear();\n        operator = null;\n      }\n    }\n  }\n  let resolvedValue;\n  if (finalize && (sortedValues.includes(\"+\") || sortedValues.includes(\"-\"))) {\n    const finalizedValues = [];\n    cal.clear();\n    operator = null;\n    for (let i = 0, l = sortedValues.length; i < l; i++) {\n      const value = sortedValues[i];\n      if (value === \"+\" || value === \"-\") {\n        operator = value;\n      } else {\n        switch (operator) {\n          case \"-\": {\n            const numValue = Number(value);\n            if (Number.isFinite(numValue)) {\n              cal.hasNum = true;\n              cal.numSum.push(-1 * numValue);\n            } else if (REG_TYPE_PCT.test(value)) {\n              const [, val] = value.match(REG_TYPE_PCT);\n              cal.hasPct = true;\n              cal.pctSum.push(-1 * Number(val));\n            } else if (REG_TYPE_DIM.test(value)) {\n              cal.hasDim = true;\n              cal.dimSub.push(value);\n            } else {\n              cal.hasEtc = true;\n              cal.etcSub.push(value);\n            }\n            break;\n          }\n          case \"+\":\n          default: {\n            const numValue = Number(value);\n            if (Number.isFinite(numValue)) {\n              cal.hasNum = true;\n              cal.numSum.push(numValue);\n            } else if (REG_TYPE_PCT.test(value)) {\n              const [, val] = value.match(REG_TYPE_PCT);\n              cal.hasPct = true;\n              cal.pctSum.push(Number(val));\n            } else if (REG_TYPE_DIM.test(value)) {\n              cal.hasDim = true;\n              cal.dimSum.push(value);\n            } else {\n              cal.hasEtc = true;\n              cal.etcSum.push(value);\n            }\n          }\n        }\n        if (i === l - 1) {\n          const sortedValue = cal.sum();\n          finalizedValues.push(sortedValue);\n          cal.clear();\n          operator = null;\n        }\n      }\n    }\n    resolvedValue = finalizedValues.join(\" \");\n  } else {\n    resolvedValue = sortedValues.join(\" \");\n  }\n  return `${start}${resolvedValue}${end}`;\n};\nconst serializeCalc = (value, opt = {}) => {\n  const { format } = opt;\n  if (common.isString(value)) {\n    if (!REG_START_MATH_VAR.test(value) || format !== constant.VAL_SPEC) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string`);\n  }\n  const cacheKey = `{serializeCalc:${value},opt:${util.valueToJsonString(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const items = cssTokenizer.tokenize({ css: value }).map((token) => {\n    const [type, value2] = token;\n    let res;\n    if (type !== W_SPACE && type !== COMMENT) {\n      res = value2;\n    }\n    return res;\n  }).filter((v) => v);\n  let startIndex = items.findLastIndex((item) => /\\($/.test(item));\n  while (startIndex) {\n    const endIndex = items.findIndex((item, index) => {\n      return item === \")\" && index > startIndex;\n    });\n    const slicedValues = items.slice(startIndex, endIndex + 1);\n    let serializedValue = sortCalcValues(slicedValues);\n    if (REG_START_MATH_VAR.test(serializedValue)) {\n      serializedValue = cssCalc$1.calc(serializedValue, {\n        toCanonicalUnits: true\n      });\n    }\n    items.splice(startIndex, endIndex - startIndex + 1, serializedValue);\n    startIndex = items.findLastIndex((item) => /\\($/.test(item));\n  }\n  const serializedCalc = sortCalcValues(items, true);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, serializedCalc);\n  }\n  return serializedCalc;\n};\nconst resolveDimension = (token, opt = {}) => {\n  if (!Array.isArray(token)) {\n    throw new TypeError(`${token} is not an array.`);\n  }\n  const [, value, , , detail = {}] = token;\n  const { unit, value: relativeValue } = detail;\n  const { dimension = {} } = opt;\n  if (unit === \"px\") {\n    return value;\n  }\n  let res;\n  if (unit && Number.isFinite(relativeValue)) {\n    let pixelValue;\n    if (Object.hasOwnProperty.call(dimension, unit)) {\n      pixelValue = dimension[unit];\n    } else if (typeof dimension.callback === \"function\") {\n      pixelValue = dimension.callback(unit);\n    }\n    pixelValue = Number(pixelValue);\n    if (Number.isFinite(pixelValue)) {\n      res = `${relativeValue * pixelValue}px`;\n    }\n  }\n  return res ?? null;\n};\nconst parseTokens = (tokens, opt = {}) => {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { format } = opt;\n  const mathFunc = /* @__PURE__ */ new Set();\n  let nest = 0;\n  const res = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value] = token;\n    switch (type) {\n      case DIM: {\n        let resolvedValue;\n        if (format === constant.VAL_SPEC && !mathFunc.has(nest)) {\n          resolvedValue = value;\n        } else {\n          resolvedValue = resolveDimension(token, opt);\n          if (!resolvedValue) {\n            resolvedValue = value;\n          }\n        }\n        res.push(resolvedValue);\n        break;\n      }\n      case FUNC:\n      case PAREN_OPEN: {\n        res.push(value);\n        nest++;\n        if (REG_START_MATH.test(value)) {\n          mathFunc.add(nest);\n        }\n        break;\n      }\n      case PAREN_CLOSE: {\n        if (res.length) {\n          const lastValue = res[res.length - 1];\n          if (lastValue === \" \") {\n            res.splice(-1, 1, value);\n          } else {\n            res.push(value);\n          }\n        } else {\n          res.push(value);\n        }\n        if (mathFunc.has(nest)) {\n          mathFunc.delete(nest);\n        }\n        nest--;\n        break;\n      }\n      case W_SPACE: {\n        if (res.length) {\n          const lastValue = res[res.length - 1];\n          if (!lastValue.endsWith(\"(\") && lastValue !== \" \") {\n            res.push(value);\n          }\n        }\n        break;\n      }\n      default: {\n        if (type !== COMMENT && type !== EOF) {\n          res.push(value);\n        }\n      }\n    }\n  }\n  return res;\n};\nconst cssCalc = (value, opt = {}) => {\n  const { format, dimension = {} } = opt;\n  if (common.isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === constant.VAL_SPEC) {\n        return value;\n      } else {\n        throw new SyntaxError(`Unexpected token ${constant.FN_VAR} found.`);\n      }\n    } else if (!REG_FN_MATH_CALC.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string`);\n  }\n  let cacheKey;\n  if (typeof dimension.callback !== \"function\") {\n    cacheKey = `{cssCalc:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  let resolvedValue;\n  if (dimension) {\n    const tokens = cssTokenizer.tokenize({ css: value });\n    const values = parseTokens(tokens, opt);\n    resolvedValue = cssCalc$1.calc(values.join(\"\"), {\n      toCanonicalUnits: true\n    });\n  } else {\n    resolvedValue = cssCalc$1.calc(value, {\n      toCanonicalUnits: true\n    });\n  }\n  if (REG_START_MATH_VAR.test(value)) {\n    if (REG_TYPE_DIM_PCT.test(resolvedValue)) {\n      const [, val, unit] = resolvedValue.match(REG_TYPE_DIM_PCT);\n      resolvedValue = `${util.roundToPrecision(Number(val), HEX)}${unit}`;\n    }\n    if (resolvedValue && !REG_START_MATH_VAR.test(resolvedValue) && format === constant.VAL_SPEC) {\n      resolvedValue = `calc(${resolvedValue})`;\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, resolvedValue);\n  }\n  return resolvedValue;\n};\nexports.Calculator = Calculator;\nexports.cachedResults = cachedResults;\nexports.cssCalc = cssCalc;\nexports.parseTokens = parseTokens;\nexports.resolveDimension = resolveDimension;\nexports.serializeCalc = serializeCalc;\nexports.sortCalcValues = sortCalcValues;\n//# sourceMappingURL=css-calc.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY3NzLWNhbGMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEUsa0JBQWtCLG1CQUFPLENBQUMsOE5BQW9CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLDZJQUF5QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBVztBQUNwQyxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtJQUFZO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBJQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQseUNBQXlDLGFBQWE7QUFDdEQscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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bkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsTUFBTSxPQUFPLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDLEVBQUUsS0FBSztBQUN4RTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9jc3MtY2FsYy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xudmFyIF9oYXNOdW0sIF9udW1TdW0sIF9udW1NdWwsIF9oYXNQY3QsIF9wY3RTdW0sIF9wY3RNdWwsIF9oYXNEaW0sIF9kaW1TdW0sIF9kaW1TdWIsIF9kaW1NdWwsIF9kaW1EaXYsIF9oYXNFdGMsIF9ldGNTdW0sIF9ldGNTdWIsIF9ldGNNdWwsIF9ldGNEaXY7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgY3NzQ2FsYyQxID0gcmVxdWlyZShcIkBjc3N0b29scy9jc3MtY2FsY1wiKTtcbmNvbnN0IGNzc1Rva2VuaXplciA9IHJlcXVpcmUoXCJAY3NzdG9vbHMvY3NzLXRva2VuaXplclwiKTtcbmNvbnN0IGxydUNhY2hlID0gcmVxdWlyZShcImxydS1jYWNoZVwiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuL2NvbW1vbi5janNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC5janNcIik7XG5jb25zdCBjb25zdGFudCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50LmNqc1wiKTtcbmNvbnN0IHtcbiAgQ2xvc2VQYXJlbjogUEFSRU5fQ0xPU0UsXG4gIENvbW1lbnQ6IENPTU1FTlQsXG4gIERpbWVuc2lvbjogRElNLFxuICBFT0YsXG4gIEZ1bmN0aW9uOiBGVU5DLFxuICBPcGVuUGFyZW46IFBBUkVOX09QRU4sXG4gIFdoaXRlc3BhY2U6IFdfU1BBQ0Vcbn0gPSBjc3NUb2tlbml6ZXIuVG9rZW5UeXBlO1xuY29uc3QgSEVYID0gMTY7XG5jb25zdCBNQVhfUENUID0gMTAwO1xuY29uc3QgUkVHX0ZOX01BVEhfQ0FMQyA9IG5ldyBSZWdFeHAoY29uc3RhbnQuU1lOX0ZOX01BVEhfQ0FMQyk7XG5jb25zdCBSRUdfRk5fVkFSID0gbmV3IFJlZ0V4cChjb25zdGFudC5TWU5fRk5fVkFSKTtcbmNvbnN0IFJFR19PUEVSQVRPUiA9IC9cXHNbKisvLV1cXHMvO1xuY29uc3QgUkVHX1NUQVJUX01BVEggPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9NQVRIKTtcbmNvbnN0IFJFR19TVEFSVF9NQVRIX1ZBUiA9IG5ldyBSZWdFeHAoY29uc3RhbnQuU1lOX0ZOX01BVEhfVkFSKTtcbmNvbnN0IFJFR19UWVBFX0RJTSA9IG5ldyBSZWdFeHAoYF4oJHtjb25zdGFudC5OVU19KShbYS16XSspJGApO1xuY29uc3QgUkVHX1RZUEVfRElNX1BDVCA9IG5ldyBSZWdFeHAoYF4oJHtjb25zdGFudC5OVU19KShbYS16XSt8JSkkYCk7XG5jb25zdCBSRUdfVFlQRV9QQ1QgPSBuZXcgUmVnRXhwKGBeKCR7Y29uc3RhbnQuTlVNfSklJGApO1xuY29uc3QgY2FjaGVkUmVzdWx0cyA9IG5ldyBscnVDYWNoZS5MUlVDYWNoZSh7XG4gIG1heDogNDA5NlxufSk7XG5jbGFzcyBDYWxjdWxhdG9yIHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiBwcml2YXRlICovXG4gICAgLy8gbnVtYmVyXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYXNOdW0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbnVtU3VtKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX251bU11bCk7XG4gICAgLy8gcGVyY2VudGFnZVxuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFzUGN0KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3BjdFN1bSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wY3RNdWwpO1xuICAgIC8vIGRpbWVuc2lvblxuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFzRGltKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RpbVN1bSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kaW1TdWIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGltTXVsKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2RpbURpdik7XG4gICAgLy8gZXQgY2V0cmFcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhc0V0Yyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ldGNTdW0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZXRjU3ViKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2V0Y011bCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ldGNEaXYpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzTnVtLCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9udW1TdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX251bU11bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzUGN0LCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wY3RTdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BjdE11bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzRGltLCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9kaW1TdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RpbVN1YiwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZGltTXVsLCBbXSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9kaW1EaXYsIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2hhc0V0YywgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXRjU3VtLCBbXSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9ldGNTdWIsIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2V0Y011bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXRjRGl2LCBbXSk7XG4gIH1cbiAgZ2V0IGhhc051bSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9oYXNOdW0pO1xuICB9XG4gIHNldCBoYXNOdW0odmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2hhc051bSwgISF2YWx1ZSk7XG4gIH1cbiAgZ2V0IG51bVN1bSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9udW1TdW0pO1xuICB9XG4gIGdldCBudW1NdWwoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbnVtTXVsKTtcbiAgfVxuICBnZXQgaGFzUGN0KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2hhc1BjdCk7XG4gIH1cbiAgc2V0IGhhc1BjdCh2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzUGN0LCAhIXZhbHVlKTtcbiAgfVxuICBnZXQgcGN0U3VtKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3BjdFN1bSk7XG4gIH1cbiAgZ2V0IHBjdE11bCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wY3RNdWwpO1xuICB9XG4gIGdldCBoYXNEaW0oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzRGltKTtcbiAgfVxuICBzZXQgaGFzRGltKHZhbHVlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9oYXNEaW0sICEhdmFsdWUpO1xuICB9XG4gIGdldCBkaW1TdW0oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGltU3VtKTtcbiAgfVxuICBnZXQgZGltU3ViKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2RpbVN1Yik7XG4gIH1cbiAgZ2V0IGRpbU11bCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9kaW1NdWwpO1xuICB9XG4gIGdldCBkaW1EaXYoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGltRGl2KTtcbiAgfVxuICBnZXQgaGFzRXRjKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2hhc0V0Yyk7XG4gIH1cbiAgc2V0IGhhc0V0Yyh2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzRXRjLCAhIXZhbHVlKTtcbiAgfVxuICBnZXQgZXRjU3VtKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2V0Y1N1bSk7XG4gIH1cbiAgZ2V0IGV0Y1N1YigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9ldGNTdWIpO1xuICB9XG4gIGdldCBldGNNdWwoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjTXVsKTtcbiAgfVxuICBnZXQgZXRjRGl2KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2V0Y0Rpdik7XG4gIH1cbiAgLyoqXG4gICAqIGNsZWFyIHZhbHVlc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzTnVtLCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9udW1TdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX251bU11bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzUGN0LCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wY3RTdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BjdE11bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzRGltLCBmYWxzZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9kaW1TdW0sIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2RpbVN1YiwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZGltTXVsLCBbXSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9kaW1EaXYsIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2hhc0V0YywgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXRjU3VtLCBbXSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9ldGNTdWIsIFtdKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2V0Y011bCwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXRjRGl2LCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIHNvcnQgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIHZhbHVlc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gc29ydGVkIHZhbHVlc1xuICAgKi9cbiAgc29ydCh2YWx1ZXMgPSBbXSkge1xuICAgIGNvbnN0IGFyciA9IFsuLi52YWx1ZXNdO1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgYXJyLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgaWYgKFJFR19UWVBFX0RJTV9QQ1QudGVzdChhKSAmJiBSRUdfVFlQRV9ESU1fUENULnRlc3QoYikpIHtcbiAgICAgICAgICBjb25zdCBbLCB2YWxBLCB1bml0QV0gPSBhLm1hdGNoKFJFR19UWVBFX0RJTV9QQ1QpO1xuICAgICAgICAgIGNvbnN0IFssIHZhbEIsIHVuaXRCXSA9IGIubWF0Y2goUkVHX1RZUEVfRElNX1BDVCk7XG4gICAgICAgICAgaWYgKHVuaXRBID09PSB1bml0Qikge1xuICAgICAgICAgICAgaWYgKE51bWJlcih2YWxBKSA9PT0gTnVtYmVyKHZhbEIpKSB7XG4gICAgICAgICAgICAgIHJlcyA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE51bWJlcih2YWxBKSA+IE51bWJlcih2YWxCKSkge1xuICAgICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1bml0QSA+IHVuaXRCKSB7XG4gICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJlcyA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmVzID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICAvKipcbiAgICogbXVsdGlwbHkgdmFsdWVzXG4gICAqIEByZXR1cm5zIHs/c3RyaW5nfSAtIHJlc29sdmVkIHZhbHVlXG4gICAqL1xuICBtdWx0aXBseSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGxldCBudW07XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzTnVtKSkge1xuICAgICAgbnVtID0gMTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX251bU11bCkpIHtcbiAgICAgICAgbnVtICo9IGk7XG4gICAgICAgIGlmIChudW0gPT09IDAgfHwgIU51bWJlci5pc0Zpbml0ZShudW0pIHx8IE51bWJlci5pc05hTihudW0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9oYXNQY3QpICYmICFfX3ByaXZhdGVHZXQodGhpcywgX2hhc0RpbSkgJiYgIXRoaXMuaGFzRXRjKSB7XG4gICAgICAgIHZhbHVlLnB1c2gobnVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzUGN0KSkge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2hhc051bSkpIHtcbiAgICAgICAgbnVtID0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX3BjdE11bCkpIHtcbiAgICAgICAgbnVtICo9IGk7XG4gICAgICAgIGlmIChudW0gPT09IDAgfHwgIU51bWJlci5pc0Zpbml0ZShudW0pIHx8IE51bWJlci5pc05hTihudW0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgICAgICBudW0gPSBgJHtudW19JWA7XG4gICAgICB9XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzRGltKSAmJiAhdGhpcy5oYXNFdGMpIHtcbiAgICAgICAgdmFsdWUucHVzaChudW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9oYXNEaW0pKSB7XG4gICAgICBsZXQgZGltLCBtdWwsIGRpdjtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2RpbU11bCkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2RpbU11bCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgW211bF0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2RpbU11bCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsID0gYCR7dGhpcy5zb3J0KF9fcHJpdmF0ZUdldCh0aGlzLCBfZGltTXVsKSkuam9pbihcIiAqIFwiKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9kaW1EaXYpLmxlbmd0aCkge1xuICAgICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9kaW1EaXYpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIFtkaXZdID0gX19wcml2YXRlR2V0KHRoaXMsIF9kaW1EaXYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdiA9IGAke3RoaXMuc29ydChfX3ByaXZhdGVHZXQodGhpcywgX2RpbURpdikpLmpvaW4oXCIgKiBcIil9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgICAgIGlmIChtdWwpIHtcbiAgICAgICAgICBpZiAoZGl2KSB7XG4gICAgICAgICAgICBpZiAoZGl2LmluY2x1ZGVzKFwiKlwiKSkge1xuICAgICAgICAgICAgICBkaW0gPSBjc3NDYWxjJDEuY2FsYyhgY2FsYygke251bX0gKiAke211bH0gLyAoJHtkaXZ9KSlgLCB7XG4gICAgICAgICAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpbSA9IGNzc0NhbGMkMS5jYWxjKGBjYWxjKCR7bnVtfSAqICR7bXVsfSAvICR7ZGl2fSlgLCB7XG4gICAgICAgICAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGltID0gY3NzQ2FsYyQxLmNhbGMoYGNhbGMoJHtudW19ICogJHttdWx9KWAsIHtcbiAgICAgICAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkaXYuaW5jbHVkZXMoXCIqXCIpKSB7XG4gICAgICAgICAgICBkaW0gPSBjc3NDYWxjJDEuY2FsYyhgY2FsYygke251bX0gLyAoJHtkaXZ9KSlgLCB7XG4gICAgICAgICAgICAgIHRvQ2Fub25pY2FsVW5pdHM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW0gPSBjc3NDYWxjJDEuY2FsYyhgY2FsYygke251bX0gLyAke2Rpdn0pYCwge1xuICAgICAgICAgICAgICB0b0Nhbm9uaWNhbFVuaXRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUucHVzaChkaW0ucmVwbGFjZSgvXmNhbGMvLCBcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhbHVlLmxlbmd0aCAmJiBudW0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhbHVlLnB1c2gobnVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsKSB7XG4gICAgICAgICAgaWYgKGRpdikge1xuICAgICAgICAgICAgaWYgKGRpdi5pbmNsdWRlcyhcIipcIikpIHtcbiAgICAgICAgICAgICAgZGltID0gY3NzQ2FsYyQxLmNhbGMoYGNhbGMoJHttdWx9IC8gKCR7ZGl2fSkpYCwge1xuICAgICAgICAgICAgICAgIHRvQ2Fub25pY2FsVW5pdHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaW0gPSBjc3NDYWxjJDEuY2FsYyhgY2FsYygke211bH0gLyAke2Rpdn0pYCwge1xuICAgICAgICAgICAgICAgIHRvQ2Fub25pY2FsVW5pdHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbSA9IGNzc0NhbGMkMS5jYWxjKGBjYWxjKCR7bXVsfSlgLCB7XG4gICAgICAgICAgICAgIHRvQ2Fub25pY2FsVW5pdHM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKFwiKlwiLCBkaW0ucmVwbGFjZSgvXmNhbGMvLCBcIlwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGltLnJlcGxhY2UoL15jYWxjLywgXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaW0gPSBjc3NDYWxjJDEuY2FsYyhgY2FsYygke2Rpdn0pYCwge1xuICAgICAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goXCIvXCIsIGRpbS5yZXBsYWNlKC9eY2FsYy8sIFwiXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUucHVzaChcIjFcIiwgXCIvXCIsIGRpbS5yZXBsYWNlKC9eY2FsYy8sIFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzRXRjKSkge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjTXVsKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5sZW5ndGggJiYgbnVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YWx1ZS5wdXNoKG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXVsID0gdGhpcy5zb3J0KF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjTXVsKSkuam9pbihcIiAqIFwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlLnB1c2goYCogJHttdWx9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUucHVzaChgJHttdWx9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2V0Y0RpdikubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuc29ydChfX3ByaXZhdGVHZXQodGhpcywgX2V0Y0RpdikpLmpvaW4oXCIgKiBcIik7XG4gICAgICAgIGlmIChkaXYuaW5jbHVkZXMoXCIqXCIpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUucHVzaChgLyAoJHtkaXZ9KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGAxIC8gKCR7ZGl2fSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsdWUucHVzaChgLyAke2Rpdn1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZS5wdXNoKGAxIC8gJHtkaXZ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmpvaW4oXCIgXCIpIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIHN1bSB2YWx1ZXNcbiAgICogQHJldHVybnMgez9zdHJpbmd9IC0gcmVzb2x2ZWQgdmFsdWVcbiAgICovXG4gIHN1bSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2hhc051bSkpIHtcbiAgICAgIGxldCBudW0gPSAwO1xuICAgICAgZm9yIChjb25zdCBpIG9mIF9fcHJpdmF0ZUdldCh0aGlzLCBfbnVtU3VtKSkge1xuICAgICAgICBudW0gKz0gaTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtKSB8fCBOdW1iZXIuaXNOYU4obnVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZS5wdXNoKG51bSk7XG4gICAgfVxuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2hhc1BjdCkpIHtcbiAgICAgIGxldCBudW0gPSAwO1xuICAgICAgZm9yIChjb25zdCBpIG9mIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGN0U3VtKSkge1xuICAgICAgICBudW0gKz0gaTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtKSB8fCBOdW1iZXIuaXNOYU4obnVtKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcbiAgICAgICAgbnVtID0gYCR7bnVtfSVgO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZS5wdXNoKGArICR7bnVtfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUucHVzaChudW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9oYXNEaW0pKSB7XG4gICAgICBsZXQgZGltLCBzdW0sIHN1YjtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2RpbVN1bSkubGVuZ3RoKSB7XG4gICAgICAgIHN1bSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZGltU3VtKS5qb2luKFwiICsgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZGltU3ViKS5sZW5ndGgpIHtcbiAgICAgICAgc3ViID0gX19wcml2YXRlR2V0KHRoaXMsIF9kaW1TdWIpLmpvaW4oXCIgKyBcIik7XG4gICAgICB9XG4gICAgICBpZiAoc3VtKSB7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICBpZiAoc3ViLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICAgICAgZGltID0gY3NzQ2FsYyQxLmNhbGMoYGNhbGMoJHtzdW19IC0gKCR7c3VifSkpYCwge1xuICAgICAgICAgICAgICB0b0Nhbm9uaWNhbFVuaXRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGltID0gY3NzQ2FsYyQxLmNhbGMoYGNhbGMoJHtzdW19IC0gJHtzdWJ9KWAsIHtcbiAgICAgICAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpbSA9IGNzc0NhbGMkMS5jYWxjKGBjYWxjKCR7c3VtfSlgLCB7XG4gICAgICAgICAgICB0b0Nhbm9uaWNhbFVuaXRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpbSA9IGNzc0NhbGMkMS5jYWxjKGBjYWxjKC0xICogKCR7c3VifSkpYCwge1xuICAgICAgICAgIHRvQ2Fub25pY2FsVW5pdHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlLnB1c2goXCIrXCIsIGRpbS5yZXBsYWNlKC9eY2FsYy8sIFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLnB1c2goZGltLnJlcGxhY2UoL15jYWxjLywgXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9oYXNFdGMpKSB7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9ldGNTdW0pLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdW0gPSB0aGlzLnNvcnQoX19wcml2YXRlR2V0KHRoaXMsIF9ldGNTdW0pKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgIGlmIChSRUdfT1BFUkFUT1IudGVzdChpdGVtKSAmJiAhaXRlbS5zdGFydHNXaXRoKFwiKFwiKSAmJiAhaXRlbS5lbmRzV2l0aChcIilcIikpIHtcbiAgICAgICAgICAgIHJlcyA9IGAoJHtpdGVtfSlgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KS5qb2luKFwiICsgXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjU3VtKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGArICgke3N1bX0pYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goYCsgJHtzdW19YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLnB1c2goYCR7c3VtfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9ldGNTdWIpLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnNvcnQoX19wcml2YXRlR2V0KHRoaXMsIF9ldGNTdWIpKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgIGlmIChSRUdfT1BFUkFUT1IudGVzdChpdGVtKSAmJiAhaXRlbS5zdGFydHNXaXRoKFwiKFwiKSAmJiAhaXRlbS5lbmRzV2l0aChcIilcIikpIHtcbiAgICAgICAgICAgIHJlcyA9IGAoJHtpdGVtfSlgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KS5qb2luKFwiICsgXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjU3ViKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGAtICgke3N1Yn0pYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goYC0gJHtzdWJ9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfZXRjU3ViKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFsdWUucHVzaChgLTEgKiAoJHtzdWJ9KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlLnB1c2goYC0xICogJHtzdWJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmpvaW4oXCIgXCIpIHx8IG51bGw7XG4gIH1cbn1cbl9oYXNOdW0gPSBuZXcgV2Vha01hcCgpO1xuX251bVN1bSA9IG5ldyBXZWFrTWFwKCk7XG5fbnVtTXVsID0gbmV3IFdlYWtNYXAoKTtcbl9oYXNQY3QgPSBuZXcgV2Vha01hcCgpO1xuX3BjdFN1bSA9IG5ldyBXZWFrTWFwKCk7XG5fcGN0TXVsID0gbmV3IFdlYWtNYXAoKTtcbl9oYXNEaW0gPSBuZXcgV2Vha01hcCgpO1xuX2RpbVN1bSA9IG5ldyBXZWFrTWFwKCk7XG5fZGltU3ViID0gbmV3IFdlYWtNYXAoKTtcbl9kaW1NdWwgPSBuZXcgV2Vha01hcCgpO1xuX2RpbURpdiA9IG5ldyBXZWFrTWFwKCk7XG5faGFzRXRjID0gbmV3IFdlYWtNYXAoKTtcbl9ldGNTdW0gPSBuZXcgV2Vha01hcCgpO1xuX2V0Y1N1YiA9IG5ldyBXZWFrTWFwKCk7XG5fZXRjTXVsID0gbmV3IFdlYWtNYXAoKTtcbl9ldGNEaXYgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc29ydENhbGNWYWx1ZXMgPSAodmFsdWVzID0gW10sIGZpbmFsaXplID0gZmFsc2UpID0+IHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZXMuc2hpZnQoKTtcbiAgY29uc3QgZW5kID0gdmFsdWVzLnBvcCgpO1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IFt2YWx1ZV0gPSB2YWx1ZXM7XG4gICAgcmV0dXJuIGAke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YDtcbiAgfVxuICBjb25zdCBzb3J0ZWRWYWx1ZXMgPSBbXTtcbiAgY29uc3QgY2FsID0gbmV3IENhbGN1bGF0b3IoKTtcbiAgbGV0IG9wZXJhdG9yO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodmFsdWUgPT09IFwiKlwiIHx8IHZhbHVlID09PSBcIi9cIikge1xuICAgICAgb3BlcmF0b3IgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIitcIiB8fCB2YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgIGNvbnN0IHNvcnRlZFZhbHVlID0gY2FsLm11bHRpcGx5KCk7XG4gICAgICBzb3J0ZWRWYWx1ZXMucHVzaChzb3J0ZWRWYWx1ZSwgdmFsdWUpO1xuICAgICAgY2FsLmNsZWFyKCk7XG4gICAgICBvcGVyYXRvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bVZhbHVlKSkge1xuICAgICAgICAgICAgY2FsLmhhc051bSA9IHRydWU7XG4gICAgICAgICAgICBjYWwubnVtTXVsLnB1c2goMSAvIG51bVZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX1BDVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19UWVBFX1BDVCk7XG4gICAgICAgICAgICBjYWwuaGFzUGN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbC5wY3RNdWwucHVzaChNQVhfUENUICogTUFYX1BDVCAvIE51bWJlcih2YWwpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX0RJTS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgY2FsLmhhc0RpbSA9IHRydWU7XG4gICAgICAgICAgICBjYWwuZGltRGl2LnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWwuaGFzRXRjID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbC5ldGNEaXYucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShudW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIGNhbC5oYXNOdW0gPSB0cnVlO1xuICAgICAgICAgICAgY2FsLm51bU11bC5wdXNoKG51bVZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX1BDVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19UWVBFX1BDVCk7XG4gICAgICAgICAgICBjYWwuaGFzUGN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbC5wY3RNdWwucHVzaChOdW1iZXIodmFsKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChSRUdfVFlQRV9ESU0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNhbC5oYXNEaW0gPSB0cnVlO1xuICAgICAgICAgICAgY2FsLmRpbU11bC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsLmhhc0V0YyA9IHRydWU7XG4gICAgICAgICAgICBjYWwuZXRjTXVsLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgIGNvbnN0IHNvcnRlZFZhbHVlID0gY2FsLm11bHRpcGx5KCk7XG4gICAgICAgIHNvcnRlZFZhbHVlcy5wdXNoKHNvcnRlZFZhbHVlKTtcbiAgICAgICAgY2FsLmNsZWFyKCk7XG4gICAgICAgIG9wZXJhdG9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGlmIChmaW5hbGl6ZSAmJiAoc29ydGVkVmFsdWVzLmluY2x1ZGVzKFwiK1wiKSB8fCBzb3J0ZWRWYWx1ZXMuaW5jbHVkZXMoXCItXCIpKSkge1xuICAgIGNvbnN0IGZpbmFsaXplZFZhbHVlcyA9IFtdO1xuICAgIGNhbC5jbGVhcigpO1xuICAgIG9wZXJhdG9yID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvcnRlZFZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc29ydGVkVmFsdWVzW2ldO1xuICAgICAgaWYgKHZhbHVlID09PSBcIitcIiB8fCB2YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgb3BlcmF0b3IgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bVZhbHVlKSkge1xuICAgICAgICAgICAgICBjYWwuaGFzTnVtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FsLm51bVN1bS5wdXNoKC0xICogbnVtVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChSRUdfVFlQRV9QQ1QudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgWywgdmFsXSA9IHZhbHVlLm1hdGNoKFJFR19UWVBFX1BDVCk7XG4gICAgICAgICAgICAgIGNhbC5oYXNQY3QgPSB0cnVlO1xuICAgICAgICAgICAgICBjYWwucGN0U3VtLnB1c2goLTEgKiBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX0RJTS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICBjYWwuaGFzRGltID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FsLmRpbVN1Yi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbC5oYXNFdGMgPSB0cnVlO1xuICAgICAgICAgICAgICBjYWwuZXRjU3ViLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShudW1WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgY2FsLmhhc051bSA9IHRydWU7XG4gICAgICAgICAgICAgIGNhbC5udW1TdW0ucHVzaChudW1WYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX1BDVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICBjb25zdCBbLCB2YWxdID0gdmFsdWUubWF0Y2goUkVHX1RZUEVfUENUKTtcbiAgICAgICAgICAgICAgY2FsLmhhc1BjdCA9IHRydWU7XG4gICAgICAgICAgICAgIGNhbC5wY3RTdW0ucHVzaChOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFJFR19UWVBFX0RJTS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICBjYWwuaGFzRGltID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FsLmRpbVN1bS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbC5oYXNFdGMgPSB0cnVlO1xuICAgICAgICAgICAgICBjYWwuZXRjU3VtLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBzb3J0ZWRWYWx1ZSA9IGNhbC5zdW0oKTtcbiAgICAgICAgICBmaW5hbGl6ZWRWYWx1ZXMucHVzaChzb3J0ZWRWYWx1ZSk7XG4gICAgICAgICAgY2FsLmNsZWFyKCk7XG4gICAgICAgICAgb3BlcmF0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVkVmFsdWUgPSBmaW5hbGl6ZWRWYWx1ZXMuam9pbihcIiBcIik7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWRWYWx1ZSA9IHNvcnRlZFZhbHVlcy5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gYCR7c3RhcnR9JHtyZXNvbHZlZFZhbHVlfSR7ZW5kfWA7XG59O1xuY29uc3Qgc2VyaWFsaXplQ2FsYyA9ICh2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAoIVJFR19TVEFSVF9NQVRIX1ZBUi50ZXN0KHZhbHVlKSB8fCBmb3JtYXQgIT09IGNvbnN0YW50LlZBTF9TUEVDKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBge3NlcmlhbGl6ZUNhbGM6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdHMuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICBjb25zdCBpdGVtcyA9IGNzc1Rva2VuaXplci50b2tlbml6ZSh7IGNzczogdmFsdWUgfSkubWFwKCh0b2tlbikgPT4ge1xuICAgIGNvbnN0IFt0eXBlLCB2YWx1ZTJdID0gdG9rZW47XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZSAhPT0gV19TUEFDRSAmJiB0eXBlICE9PSBDT01NRU5UKSB7XG4gICAgICByZXMgPSB2YWx1ZTI7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0pLmZpbHRlcigodikgPT4gdik7XG4gIGxldCBzdGFydEluZGV4ID0gaXRlbXMuZmluZExhc3RJbmRleCgoaXRlbSkgPT4gL1xcKCQvLnRlc3QoaXRlbSkpO1xuICB3aGlsZSAoc3RhcnRJbmRleCkge1xuICAgIGNvbnN0IGVuZEluZGV4ID0gaXRlbXMuZmluZEluZGV4KChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGl0ZW0gPT09IFwiKVwiICYmIGluZGV4ID4gc3RhcnRJbmRleDtcbiAgICB9KTtcbiAgICBjb25zdCBzbGljZWRWYWx1ZXMgPSBpdGVtcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpO1xuICAgIGxldCBzZXJpYWxpemVkVmFsdWUgPSBzb3J0Q2FsY1ZhbHVlcyhzbGljZWRWYWx1ZXMpO1xuICAgIGlmIChSRUdfU1RBUlRfTUFUSF9WQVIudGVzdChzZXJpYWxpemVkVmFsdWUpKSB7XG4gICAgICBzZXJpYWxpemVkVmFsdWUgPSBjc3NDYWxjJDEuY2FsYyhzZXJpYWxpemVkVmFsdWUsIHtcbiAgICAgICAgdG9DYW5vbmljYWxVbml0czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGl0ZW1zLnNwbGljZShzdGFydEluZGV4LCBlbmRJbmRleCAtIHN0YXJ0SW5kZXggKyAxLCBzZXJpYWxpemVkVmFsdWUpO1xuICAgIHN0YXJ0SW5kZXggPSBpdGVtcy5maW5kTGFzdEluZGV4KChpdGVtKSA9PiAvXFwoJC8udGVzdChpdGVtKSk7XG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplZENhbGMgPSBzb3J0Q2FsY1ZhbHVlcyhpdGVtcywgdHJ1ZSk7XG4gIGlmIChjYWNoZUtleSkge1xuICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBzZXJpYWxpemVkQ2FsYyk7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWRDYWxjO1xufTtcbmNvbnN0IHJlc29sdmVEaW1lbnNpb24gPSAodG9rZW4sIG9wdCA9IHt9KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3Rva2VufSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gIH1cbiAgY29uc3QgWywgdmFsdWUsICwgLCBkZXRhaWwgPSB7fV0gPSB0b2tlbjtcbiAgY29uc3QgeyB1bml0LCB2YWx1ZTogcmVsYXRpdmVWYWx1ZSB9ID0gZGV0YWlsO1xuICBjb25zdCB7IGRpbWVuc2lvbiA9IHt9IH0gPSBvcHQ7XG4gIGlmICh1bml0ID09PSBcInB4XCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IHJlcztcbiAgaWYgKHVuaXQgJiYgTnVtYmVyLmlzRmluaXRlKHJlbGF0aXZlVmFsdWUpKSB7XG4gICAgbGV0IHBpeGVsVmFsdWU7XG4gICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpbWVuc2lvbiwgdW5pdCkpIHtcbiAgICAgIHBpeGVsVmFsdWUgPSBkaW1lbnNpb25bdW5pdF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGltZW5zaW9uLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHBpeGVsVmFsdWUgPSBkaW1lbnNpb24uY2FsbGJhY2sodW5pdCk7XG4gICAgfVxuICAgIHBpeGVsVmFsdWUgPSBOdW1iZXIocGl4ZWxWYWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShwaXhlbFZhbHVlKSkge1xuICAgICAgcmVzID0gYCR7cmVsYXRpdmVWYWx1ZSAqIHBpeGVsVmFsdWV9cHhgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzID8/IG51bGw7XG59O1xuY29uc3QgcGFyc2VUb2tlbnMgPSAodG9rZW5zLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dG9rZW5zfSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gIH1cbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgY29uc3QgbWF0aEZ1bmMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgbmVzdCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0b2tlbn0gaXMgbm90IGFuIGFycmF5LmApO1xuICAgIH1cbiAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gdG9rZW47XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIERJTToge1xuICAgICAgICBsZXQgcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMgJiYgIW1hdGhGdW5jLmhhcyhuZXN0KSkge1xuICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlZFZhbHVlID0gcmVzb2x2ZURpbWVuc2lvbih0b2tlbiwgb3B0KTtcbiAgICAgICAgICBpZiAoIXJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2gocmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBGVU5DOlxuICAgICAgY2FzZSBQQVJFTl9PUEVOOiB7XG4gICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgbmVzdCsrO1xuICAgICAgICBpZiAoUkVHX1NUQVJUX01BVEgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBtYXRoRnVuYy5hZGQobmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFBBUkVOX0NMT1NFOiB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdFZhbHVlID09PSBcIiBcIikge1xuICAgICAgICAgICAgcmVzLnNwbGljZSgtMSwgMSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0aEZ1bmMuaGFzKG5lc3QpKSB7XG4gICAgICAgICAgbWF0aEZ1bmMuZGVsZXRlKG5lc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5lc3QtLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFdfU1BBQ0U6IHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmICghbGFzdFZhbHVlLmVuZHNXaXRoKFwiKFwiKSAmJiBsYXN0VmFsdWUgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICByZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodHlwZSAhPT0gQ09NTUVOVCAmJiB0eXBlICE9PSBFT0YpIHtcbiAgICAgICAgICByZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjc3NDYWxjID0gKHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBjb25zdCB7IGZvcm1hdCwgZGltZW5zaW9uID0ge30gfSA9IG9wdDtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAoUkVHX0ZOX1ZBUi50ZXN0KHZhbHVlKSkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRva2VuICR7Y29uc3RhbnQuRk5fVkFSfSBmb3VuZC5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFSRUdfRk5fTUFUSF9DQUxDLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gIH1cbiAgbGV0IGNhY2hlS2V5O1xuICBpZiAodHlwZW9mIGRpbWVuc2lvbi5jYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FjaGVLZXkgPSBge2Nzc0NhbGM6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICAgIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICB9XG4gIGxldCByZXNvbHZlZFZhbHVlO1xuICBpZiAoZGltZW5zaW9uKSB7XG4gICAgY29uc3QgdG9rZW5zID0gY3NzVG9rZW5pemVyLnRva2VuaXplKHsgY3NzOiB2YWx1ZSB9KTtcbiAgICBjb25zdCB2YWx1ZXMgPSBwYXJzZVRva2Vucyh0b2tlbnMsIG9wdCk7XG4gICAgcmVzb2x2ZWRWYWx1ZSA9IGNzc0NhbGMkMS5jYWxjKHZhbHVlcy5qb2luKFwiXCIpLCB7XG4gICAgICB0b0Nhbm9uaWNhbFVuaXRzOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWRWYWx1ZSA9IGNzc0NhbGMkMS5jYWxjKHZhbHVlLCB7XG4gICAgICB0b0Nhbm9uaWNhbFVuaXRzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaWYgKFJFR19TVEFSVF9NQVRIX1ZBUi50ZXN0KHZhbHVlKSkge1xuICAgIGlmIChSRUdfVFlQRV9ESU1fUENULnRlc3QocmVzb2x2ZWRWYWx1ZSkpIHtcbiAgICAgIGNvbnN0IFssIHZhbCwgdW5pdF0gPSByZXNvbHZlZFZhbHVlLm1hdGNoKFJFR19UWVBFX0RJTV9QQ1QpO1xuICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGAke3V0aWwucm91bmRUb1ByZWNpc2lvbihOdW1iZXIodmFsKSwgSEVYKX0ke3VuaXR9YDtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkVmFsdWUgJiYgIVJFR19TVEFSVF9NQVRIX1ZBUi50ZXN0KHJlc29sdmVkVmFsdWUpICYmIGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgIHJlc29sdmVkVmFsdWUgPSBgY2FsYygke3Jlc29sdmVkVmFsdWV9KWA7XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZUtleSkge1xuICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCByZXNvbHZlZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRWYWx1ZTtcbn07XG5leHBvcnRzLkNhbGN1bGF0b3IgPSBDYWxjdWxhdG9yO1xuZXhwb3J0cy5jYWNoZWRSZXN1bHRzID0gY2FjaGVkUmVzdWx0cztcbmV4cG9ydHMuY3NzQ2FsYyA9IGNzc0NhbGM7XG5leHBvcnRzLnBhcnNlVG9rZW5zID0gcGFyc2VUb2tlbnM7XG5leHBvcnRzLnJlc29sdmVEaW1lbnNpb24gPSByZXNvbHZlRGltZW5zaW9uO1xuZXhwb3J0cy5zZXJpYWxpemVDYWxjID0gc2VyaWFsaXplQ2FsYztcbmV4cG9ydHMuc29ydENhbGNWYWx1ZXMgPSBzb3J0Q2FsY1ZhbHVlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy1jYWxjLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-var.cjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-var.cjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst cssTokenizer = __webpack_require__(/*! @csstools/css-tokenizer */ \"(ssr)/./node_modules/.pnpm/@csstools+css-tokenizer@3.0.3/node_modules/@csstools/css-tokenizer/dist/index.cjs\");\nconst lruCache = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/commonjs/index.js\");\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst cssCalc = __webpack_require__(/*! ./css-calc.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  EOF,\n  Ident: IDENT,\n  Whitespace: W_SPACE\n} = cssTokenizer.TokenType;\nconst REG_FN_MATH_CALC = new RegExp(constant.SYN_FN_MATH_CALC);\nconst REG_FN_VAR = new RegExp(constant.SYN_FN_VAR);\nconst cachedResults = new lruCache.LRUCache({\n  max: 4096\n});\nfunction resolveCustomProperty(tokens, opt = {}) {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { customProperty = {} } = opt;\n  const items = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value] = token;\n    if (type === PAREN_CLOSE) {\n      break;\n    }\n    if (value === constant.FN_VAR) {\n      const [restTokens, item] = resolveCustomProperty(tokens, opt);\n      tokens = restTokens;\n      if (item) {\n        items.push(item);\n      }\n    } else if (type === IDENT) {\n      if (value.startsWith(\"--\")) {\n        if (Object.hasOwnProperty.call(customProperty, value)) {\n          items.push(customProperty[value]);\n        } else if (typeof customProperty.callback === \"function\") {\n          const item = customProperty.callback(value);\n          if (item) {\n            items.push(item);\n          }\n        }\n      } else if (value) {\n        items.push(value);\n      }\n    }\n  }\n  let resolveAsColor;\n  if (items.length > 1) {\n    const lastValue = items[items.length - 1];\n    resolveAsColor = util.isColor(lastValue);\n  }\n  let resolvedValue;\n  for (let item of items) {\n    item = item.trim();\n    if (REG_FN_VAR.test(item)) {\n      item = cssVar(item, opt);\n      if (item) {\n        if (resolveAsColor) {\n          if (util.isColor(item)) {\n            resolvedValue = item;\n          }\n        } else {\n          resolvedValue = item;\n        }\n      }\n    } else if (REG_FN_MATH_CALC.test(item)) {\n      item = cssCalc.cssCalc(item, opt);\n      if (resolveAsColor) {\n        if (util.isColor(item)) {\n          resolvedValue = item;\n        }\n      } else {\n        resolvedValue = item;\n      }\n    } else if (item && !/^(?:inherit|initial|revert(?:-layer)?|unset)$/.test(item)) {\n      if (resolveAsColor) {\n        if (util.isColor(item)) {\n          resolvedValue = item;\n        }\n      } else {\n        resolvedValue = item;\n      }\n    }\n    if (resolvedValue) {\n      break;\n    }\n  }\n  return [tokens, resolvedValue];\n}\nfunction parseTokens(tokens, opt = {}) {\n  const res = [];\n  while (tokens.length) {\n    const token = tokens.shift();\n    const [type, value] = token;\n    if (value === constant.FN_VAR) {\n      const [restTokens, resolvedValue] = resolveCustomProperty(tokens, opt);\n      if (!resolvedValue) {\n        return null;\n      }\n      tokens = restTokens;\n      res.push(resolvedValue);\n    } else {\n      switch (type) {\n        case PAREN_CLOSE: {\n          if (res.length) {\n            const lastValue = res[res.length - 1];\n            if (lastValue === \" \") {\n              res.splice(-1, 1, value);\n            } else {\n              res.push(value);\n            }\n          } else {\n            res.push(value);\n          }\n          break;\n        }\n        case W_SPACE: {\n          if (res.length) {\n            const lastValue = res[res.length - 1];\n            if (!lastValue.endsWith(\"(\") && lastValue !== \" \") {\n              res.push(value);\n            }\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF) {\n            res.push(value);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\nfunction cssVar(value, opt = {}) {\n  const { customProperty = {}, format } = opt;\n  if (common.isString(value)) {\n    if (!REG_FN_VAR.test(value) || format === constant.VAL_SPEC) {\n      return value;\n    }\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  let cacheKey;\n  if (typeof customProperty.callback !== \"function\") {\n    cacheKey = `{cssVar:${value},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  const tokens = cssTokenizer.tokenize({ css: value });\n  const values = parseTokens(tokens, opt);\n  if (Array.isArray(values)) {\n    let color = values.join(\"\");\n    if (REG_FN_MATH_CALC.test(color)) {\n      color = cssCalc.cssCalc(color, opt);\n    }\n    if (cacheKey) {\n      cachedResults.set(cacheKey, color);\n    }\n    return color;\n  } else {\n    if (cacheKey) {\n      cachedResults.set(cacheKey, null);\n    }\n    return null;\n  }\n}\nexports.cachedResults = cachedResults;\nexports.cssVar = cssVar;\nexports.parseTokens = parseTokens;\nexports.resolveCustomProperty = resolveCustomProperty;\n//# sourceMappingURL=css-var.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvY3NzLXZhci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFLHFCQUFxQixtQkFBTyxDQUFDLDZJQUF5QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBVztBQUNwQyxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWdCO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxrSUFBWTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywwSUFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQztBQUMvQztBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixVQUFVLG1CQUFtQixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsTUFBTSxPQUFPLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2Z1amlhd2FuZy9EZXNrdG9wL2NoYXRib3Qvbm9kZV9tb2R1bGVzLy5wbnBtL0Bhc2FtdXpha2pwK2Nzcy1jb2xvckAyLjguMy9ub2RlX21vZHVsZXMvQGFzYW11emFranAvY3NzLWNvbG9yL2Rpc3QvY2pzL2pzL2Nzcy12YXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KTtcbmNvbnN0IGNzc1Rva2VuaXplciA9IHJlcXVpcmUoXCJAY3NzdG9vbHMvY3NzLXRva2VuaXplclwiKTtcbmNvbnN0IGxydUNhY2hlID0gcmVxdWlyZShcImxydS1jYWNoZVwiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuL2NvbW1vbi5janNcIik7XG5jb25zdCBjc3NDYWxjID0gcmVxdWlyZShcIi4vY3NzLWNhbGMuY2pzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuY2pzXCIpO1xuY29uc3QgY29uc3RhbnQgPSByZXF1aXJlKFwiLi9jb25zdGFudC5janNcIik7XG5jb25zdCB7XG4gIENsb3NlUGFyZW46IFBBUkVOX0NMT1NFLFxuICBDb21tZW50OiBDT01NRU5ULFxuICBFT0YsXG4gIElkZW50OiBJREVOVCxcbiAgV2hpdGVzcGFjZTogV19TUEFDRVxufSA9IGNzc1Rva2VuaXplci5Ub2tlblR5cGU7XG5jb25zdCBSRUdfRk5fTUFUSF9DQUxDID0gbmV3IFJlZ0V4cChjb25zdGFudC5TWU5fRk5fTUFUSF9DQUxDKTtcbmNvbnN0IFJFR19GTl9WQVIgPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9WQVIpO1xuY29uc3QgY2FjaGVkUmVzdWx0cyA9IG5ldyBscnVDYWNoZS5MUlVDYWNoZSh7XG4gIG1heDogNDA5NlxufSk7XG5mdW5jdGlvbiByZXNvbHZlQ3VzdG9tUHJvcGVydHkodG9rZW5zLCBvcHQgPSB7fSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dG9rZW5zfSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gIH1cbiAgY29uc3QgeyBjdXN0b21Qcm9wZXJ0eSA9IHt9IH0gPSBvcHQ7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3Rva2VufSBpcyBub3QgYW4gYXJyYXkuYCk7XG4gICAgfVxuICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSB0b2tlbjtcbiAgICBpZiAodHlwZSA9PT0gUEFSRU5fQ0xPU0UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IGNvbnN0YW50LkZOX1ZBUikge1xuICAgICAgY29uc3QgW3Jlc3RUb2tlbnMsIGl0ZW1dID0gcmVzb2x2ZUN1c3RvbVByb3BlcnR5KHRva2Vucywgb3B0KTtcbiAgICAgIHRva2VucyA9IHJlc3RUb2tlbnM7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gSURFTlQpIHtcbiAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1c3RvbVByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGN1c3RvbVByb3BlcnR5W3ZhbHVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1c3RvbVByb3BlcnR5LmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gY3VzdG9tUHJvcGVydHkuY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc29sdmVBc0NvbG9yO1xuICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIHJlc29sdmVBc0NvbG9yID0gdXRpbC5pc0NvbG9yKGxhc3RWYWx1ZSk7XG4gIH1cbiAgbGV0IHJlc29sdmVkVmFsdWU7XG4gIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICBpdGVtID0gaXRlbS50cmltKCk7XG4gICAgaWYgKFJFR19GTl9WQVIudGVzdChpdGVtKSkge1xuICAgICAgaXRlbSA9IGNzc1ZhcihpdGVtLCBvcHQpO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgaWYgKHJlc29sdmVBc0NvbG9yKSB7XG4gICAgICAgICAgaWYgKHV0aWwuaXNDb2xvcihpdGVtKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChSRUdfRk5fTUFUSF9DQUxDLnRlc3QoaXRlbSkpIHtcbiAgICAgIGl0ZW0gPSBjc3NDYWxjLmNzc0NhbGMoaXRlbSwgb3B0KTtcbiAgICAgIGlmIChyZXNvbHZlQXNDb2xvcikge1xuICAgICAgICBpZiAodXRpbC5pc0NvbG9yKGl0ZW0pKSB7XG4gICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmVkVmFsdWUgPSBpdGVtO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbSAmJiAhL14oPzppbmhlcml0fGluaXRpYWx8cmV2ZXJ0KD86LWxheWVyKT98dW5zZXQpJC8udGVzdChpdGVtKSkge1xuICAgICAgaWYgKHJlc29sdmVBc0NvbG9yKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQ29sb3IoaXRlbSkpIHtcbiAgICAgICAgICByZXNvbHZlZFZhbHVlID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0b2tlbnMsIHJlc29sdmVkVmFsdWVdO1xufVxuZnVuY3Rpb24gcGFyc2VUb2tlbnModG9rZW5zLCBvcHQgPSB7fSkge1xuICBjb25zdCByZXMgPSBbXTtcbiAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSB0b2tlbjtcbiAgICBpZiAodmFsdWUgPT09IGNvbnN0YW50LkZOX1ZBUikge1xuICAgICAgY29uc3QgW3Jlc3RUb2tlbnMsIHJlc29sdmVkVmFsdWVdID0gcmVzb2x2ZUN1c3RvbVByb3BlcnR5KHRva2Vucywgb3B0KTtcbiAgICAgIGlmICghcmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRva2VucyA9IHJlc3RUb2tlbnM7XG4gICAgICByZXMucHVzaChyZXNvbHZlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUEFSRU5fQ0xPU0U6IHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0VmFsdWUgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgIHJlcy5zcGxpY2UoLTEsIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFdfU1BBQ0U6IHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghbGFzdFZhbHVlLmVuZHNXaXRoKFwiKFwiKSAmJiBsYXN0VmFsdWUgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSBDT01NRU5UICYmIHR5cGUgIT09IEVPRikge1xuICAgICAgICAgICAgcmVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3NzVmFyKHZhbHVlLCBvcHQgPSB7fSkge1xuICBjb25zdCB7IGN1c3RvbVByb3BlcnR5ID0ge30sIGZvcm1hdCB9ID0gb3B0O1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGlmICghUkVHX0ZOX1ZBUi50ZXN0KHZhbHVlKSB8fCBmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9TUEVDKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIHN0cmluZy5gKTtcbiAgfVxuICBsZXQgY2FjaGVLZXk7XG4gIGlmICh0eXBlb2YgY3VzdG9tUHJvcGVydHkuY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhY2hlS2V5ID0gYHtjc3NWYXI6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICAgIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHRzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRva2VucyA9IGNzc1Rva2VuaXplci50b2tlbml6ZSh7IGNzczogdmFsdWUgfSk7XG4gIGNvbnN0IHZhbHVlcyA9IHBhcnNlVG9rZW5zKHRva2Vucywgb3B0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGxldCBjb2xvciA9IHZhbHVlcy5qb2luKFwiXCIpO1xuICAgIGlmIChSRUdfRk5fTUFUSF9DQUxDLnRlc3QoY29sb3IpKSB7XG4gICAgICBjb2xvciA9IGNzc0NhbGMuY3NzQ2FsYyhjb2xvciwgb3B0KTtcbiAgICB9XG4gICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLmNhY2hlZFJlc3VsdHMgPSBjYWNoZWRSZXN1bHRzO1xuZXhwb3J0cy5jc3NWYXIgPSBjc3NWYXI7XG5leHBvcnRzLnBhcnNlVG9rZW5zID0gcGFyc2VUb2tlbnM7XG5leHBvcnRzLnJlc29sdmVDdXN0b21Qcm9wZXJ0eSA9IHJlc29sdmVDdXN0b21Qcm9wZXJ0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy12YXIuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-var.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/relative-color.cjs":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/relative-color.cjs ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst cssColorParser = __webpack_require__(/*! @csstools/css-color-parser */ \"(ssr)/./node_modules/.pnpm/@csstools+css-color-parser@3.0.7_@csstools+css-parser-algorithms@3.0.4_@csstools+css-tokenize_ibxja5du4eckqjiltqinzz6xve/node_modules/@csstools/css-color-parser/dist/index.cjs\");\nconst cssParserAlgorithms = __webpack_require__(/*! @csstools/css-parser-algorithms */ \"(ssr)/./node_modules/.pnpm/@csstools+css-parser-algorithms@3.0.4_@csstools+css-tokenizer@3.0.3/node_modules/@csstools/css-parser-algorithms/dist/index.cjs\");\nconst cssTokenizer = __webpack_require__(/*! @csstools/css-tokenizer */ \"(ssr)/./node_modules/.pnpm/@csstools+css-tokenizer@3.0.3/node_modules/@csstools/css-tokenizer/dist/index.cjs\");\nconst lruCache = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/commonjs/index.js\");\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst convert = __webpack_require__(/*! ./convert.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/convert.cjs\");\nconst cssCalc = __webpack_require__(/*! ./css-calc.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\");\nconst resolve = __webpack_require__(/*! ./resolve.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst color = __webpack_require__(/*! ./color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs\");\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  Number: NUM,\n  OpenParen: PAREN_OPEN,\n  Percentage: PCT,\n  Whitespace: W_SPACE\n} = cssTokenizer.TokenType;\nconst {\n  HasNoneKeywords: NONE_KEY\n} = cssColorParser.SyntaxFlag;\nconst OCT = 8;\nconst DEC = 10;\nconst HEX = 16;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\nconst REG_COLOR_CAPT = new RegExp(\n  `^${constant.FN_REL}(${constant.SYN_COLOR_TYPE}|${constant.SYN_MIX})\\\\s+`\n);\nconst REG_CS_HSL = /(?:hsla?|hwb)$/;\nconst REG_CS_CIE = new RegExp(`^(?:${constant.CS_LAB}|${constant.CS_LCH})$`);\nconst REG_FN_VAR = new RegExp(constant.SYN_FN_VAR);\nconst REG_REL = new RegExp(constant.FN_REL);\nconst REG_REL_CAPT = new RegExp(`^${constant.FN_REL_CAPT}`);\nconst REG_START_MATH = new RegExp(constant.SYN_FN_MATH);\nconst REG_START_REL = new RegExp(`^${constant.FN_REL}`);\nconst cachedResults = new lruCache.LRUCache({\n  max: 4096\n});\nfunction resolveColorChannels(tokens, opt = {}) {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { colorSpace, format } = opt;\n  const colorChannels = /* @__PURE__ */ new Map([\n    [\"color\", [\"r\", \"g\", \"b\", \"alpha\"]],\n    [\"hsl\", [\"h\", \"s\", \"l\", \"alpha\"]],\n    [\"hsla\", [\"h\", \"s\", \"l\", \"alpha\"]],\n    [\"hwb\", [\"h\", \"w\", \"b\", \"alpha\"]],\n    [\"lab\", [\"l\", \"a\", \"b\", \"alpha\"]],\n    [\"lch\", [\"l\", \"c\", \"h\", \"alpha\"]],\n    [\"oklab\", [\"l\", \"a\", \"b\", \"alpha\"]],\n    [\"oklch\", [\"l\", \"c\", \"h\", \"alpha\"]],\n    [\"rgb\", [\"r\", \"g\", \"b\", \"alpha\"]],\n    [\"rgba\", [\"r\", \"g\", \"b\", \"alpha\"]]\n  ]);\n  const colorChannel = colorChannels.get(colorSpace);\n  const mathFunc = /* @__PURE__ */ new Set();\n  const channels = [[], [], [], []];\n  let i = 0;\n  let nest = 0;\n  let func = false;\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value, , , detail = {}] = token;\n    const numValue = detail == null ? void 0 : detail.value;\n    const channel = channels[i];\n    switch (type) {\n      case DIM: {\n        let resolvedValue = cssCalc.resolveDimension(token, opt);\n        if (!resolvedValue) {\n          resolvedValue = value;\n        }\n        channel.push(resolvedValue);\n        break;\n      }\n      case FUNC: {\n        channel.push(value);\n        func = true;\n        nest++;\n        if (REG_START_MATH.test(value)) {\n          mathFunc.add(nest);\n        }\n        break;\n      }\n      case IDENT: {\n        if (!colorChannel || !colorChannel.includes(value)) {\n          return null;\n        }\n        channel.push(value);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case NUM: {\n        const n = numValue ?? parseFloat(value);\n        channel.push(n);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case PAREN_OPEN: {\n        channel.push(value);\n        nest++;\n        break;\n      }\n      case PAREN_CLOSE: {\n        if (func) {\n          const lastValue = channel[channel.length - 1];\n          if (lastValue === \" \") {\n            channel.splice(-1, 1, value);\n          } else {\n            channel.push(value);\n          }\n          if (mathFunc.has(nest)) {\n            mathFunc.delete(nest);\n          }\n          nest--;\n          if (nest === 0) {\n            func = false;\n            i++;\n          }\n        }\n        break;\n      }\n      case PCT: {\n        const n = numValue ?? parseFloat(value);\n        channel.push(n / MAX_PCT);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case W_SPACE: {\n        if (channel.length && func) {\n          const lastValue = channel[channel.length - 1];\n          if (typeof lastValue === \"number\") {\n            channel.push(value);\n          } else if (common.isString(lastValue) && !lastValue.endsWith(\"(\") && lastValue !== \" \") {\n            channel.push(value);\n          }\n        }\n        break;\n      }\n      default: {\n        if (type !== COMMENT && type !== EOF && func) {\n          channel.push(value);\n        }\n      }\n    }\n  }\n  const channelValues = [];\n  for (const channel of channels) {\n    if (channel.length === 1) {\n      const [resolvedValue] = channel;\n      channelValues.push(resolvedValue);\n    } else if (channel.length) {\n      const resolvedValue = cssCalc.serializeCalc(channel.join(\"\"), {\n        format\n      });\n      if (resolvedValue) {\n        channelValues.push(resolvedValue);\n      } else {\n        return null;\n      }\n    }\n  }\n  return channelValues;\n}\nfunction extractOriginColor(value, opt = {}) {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n    if (!value) {\n      return null;\n    }\n    if (!REG_START_REL.test(value)) {\n      return value;\n    }\n  } else {\n    return null;\n  }\n  const { currentColor, format } = opt;\n  const cacheKey = `{preProcess:${value},opt:${util.valueToJsonString(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  if (/currentcolor/.test(value)) {\n    if (currentColor) {\n      value = value.replace(/currentcolor/g, currentColor);\n    } else {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, null);\n      }\n      return null;\n    }\n  }\n  const cs = value.match(REG_REL_CAPT);\n  let colorSpace;\n  if (cs) {\n    [, colorSpace] = cs;\n  } else {\n    return null;\n  }\n  opt.colorSpace = colorSpace;\n  if (REG_COLOR_CAPT.test(value)) {\n    const [, originColor] = value.match(REG_COLOR_CAPT);\n    const [, restValue] = value.split(originColor);\n    if (/^[a-z]+$/.test(originColor)) {\n      if (!/^transparent$/.test(originColor) && !Object.prototype.hasOwnProperty.call(color.NAMED_COLORS, originColor)) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null);\n        }\n        return null;\n      }\n    } else if (format === constant.VAL_SPEC) {\n      const resolvedOriginColor = resolve.resolve(originColor, opt);\n      value = value.replace(originColor, resolvedOriginColor);\n    }\n    if (format === constant.VAL_SPEC) {\n      const tokens = cssTokenizer.tokenize({ css: restValue });\n      const channelValues = resolveColorChannels(tokens, opt);\n      if (!Array.isArray(channelValues)) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null);\n        }\n        return null;\n      }\n      let channelValue;\n      if (channelValues.length === 3) {\n        channelValue = ` ${channelValues.join(\" \")})`;\n      } else {\n        const [v1, v2, v3, v4] = channelValues;\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      }\n      value = value.replace(restValue, channelValue);\n    }\n  } else {\n    const [, restValue] = value.split(REG_START_REL);\n    if (REG_START_REL.test(restValue)) {\n      const tokens = cssTokenizer.tokenize({ css: restValue });\n      const originColor = [];\n      let nest = 0;\n      while (tokens.length) {\n        const token = tokens.shift();\n        const [type, tokenValue] = token;\n        switch (type) {\n          case FUNC:\n          case PAREN_OPEN: {\n            originColor.push(tokenValue);\n            nest++;\n            break;\n          }\n          case PAREN_CLOSE: {\n            const lastValue = originColor[originColor.length - 1];\n            if (lastValue === \" \") {\n              originColor.splice(-1, 1, tokenValue);\n            } else {\n              originColor.push(tokenValue);\n            }\n            nest--;\n            break;\n          }\n          case W_SPACE: {\n            const lastValue = originColor[originColor.length - 1];\n            if (!lastValue.endsWith(\"(\") && lastValue !== \" \") {\n              originColor.push(tokenValue);\n            }\n            break;\n          }\n          default: {\n            if (type !== COMMENT && type !== EOF) {\n              originColor.push(tokenValue);\n            }\n          }\n        }\n        if (nest === 0) {\n          break;\n        }\n      }\n      const resolvedOriginColor = resolveRelativeColor(\n        originColor.join(\"\").trim(),\n        opt\n      );\n      if (!resolvedOriginColor) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null);\n        }\n        return null;\n      }\n      const channelValues = resolveColorChannels(tokens, opt);\n      if (!Array.isArray(channelValues)) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null);\n        }\n        return null;\n      }\n      let channelValue;\n      if (channelValues.length === 3) {\n        channelValue = ` ${channelValues.join(\" \")})`;\n      } else {\n        const [v1, v2, v3, v4] = channelValues;\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      }\n      value = value.replace(restValue, `${resolvedOriginColor}${channelValue}`);\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, value);\n  }\n  return value;\n}\nfunction resolveRelativeColor(value, opt = {}) {\n  const { format } = opt;\n  if (common.isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === constant.VAL_SPEC) {\n        return value;\n      } else {\n        throw new SyntaxError(`Unexpected token ${constant.FN_VAR} found.`);\n      }\n    } else if (!REG_REL.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string`);\n  }\n  const cacheKey = `{relativeColor:${value},opt:${util.valueToJsonString(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const originColor = extractOriginColor(value, opt);\n  if (originColor) {\n    value = originColor;\n  } else {\n    if (cacheKey) {\n      cachedResults.set(cacheKey, null);\n    }\n    return null;\n  }\n  if (format === constant.VAL_SPEC) {\n    if (value.startsWith(\"rgba(\")) {\n      value = value.replace(/^rgba\\(/, \"rgb(\");\n    } else if (value.startsWith(\"hsla(\")) {\n      value = value.replace(/^hsla\\(/, \"hsl(\");\n    }\n    return value;\n  }\n  const tokens = cssTokenizer.tokenize({ css: value });\n  const components = cssParserAlgorithms.parseComponentValue(tokens);\n  const parsedComponents = cssColorParser.color(components);\n  if (!parsedComponents) {\n    if (cacheKey) {\n      cachedResults.set(cacheKey, null);\n    }\n    return null;\n  }\n  const {\n    alpha: alphaComponent,\n    channels: channelsComponent,\n    colorNotation,\n    syntaxFlags\n  } = parsedComponents;\n  let alpha;\n  if (Number.isNaN(Number(alphaComponent))) {\n    if (syntaxFlags instanceof Set && syntaxFlags.has(NONE_KEY)) {\n      alpha = constant.NONE;\n    } else {\n      alpha = 0;\n    }\n  } else {\n    alpha = util.roundToPrecision(alphaComponent, OCT);\n  }\n  let v1;\n  let v2;\n  let v3;\n  [v1, v2, v3] = channelsComponent;\n  let resolvedValue;\n  if (REG_CS_CIE.test(colorNotation)) {\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(NONE_KEY);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = constant.NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = util.roundToPrecision(v1, HEX);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = constant.NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = util.roundToPrecision(v2, HEX);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = constant.NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = util.roundToPrecision(v3, HEX);\n    }\n    if (alpha === 1) {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  } else if (REG_CS_HSL.test(colorNotation)) {\n    if (Number.isNaN(v1)) {\n      v1 = 0;\n    }\n    if (Number.isNaN(v2)) {\n      v2 = 0;\n    }\n    if (Number.isNaN(v3)) {\n      v3 = 0;\n    }\n    let [r, g, b] = convert.colorToRgb(\n      `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`\n    );\n    r = util.roundToPrecision(r / MAX_RGB, DEC);\n    g = util.roundToPrecision(g / MAX_RGB, DEC);\n    b = util.roundToPrecision(b / MAX_RGB, DEC);\n    if (alpha === 1) {\n      resolvedValue = `color(srgb ${r} ${g} ${b})`;\n    } else {\n      resolvedValue = `color(srgb ${r} ${g} ${b} / ${alpha})`;\n    }\n  } else {\n    const cs = colorNotation === \"rgb\" ? \"srgb\" : colorNotation;\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(NONE_KEY);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = constant.NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = util.roundToPrecision(v1, DEC);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = constant.NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = util.roundToPrecision(v2, DEC);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = constant.NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = util.roundToPrecision(v3, DEC);\n    }\n    if (alpha === 1) {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, resolvedValue);\n  }\n  return resolvedValue;\n}\nexports.cachedResults = cachedResults;\nexports.extractOriginColor = extractOriginColor;\nexports.resolveColorChannels = resolveColorChannels;\nexports.resolveRelativeColor = resolveRelativeColor;\n//# sourceMappingURL=relative-color.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvcmVsYXRpdmUtY29sb3IuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscURBQXFELGlCQUFpQjtBQUN0RSx1QkFBdUIsbUJBQU8sQ0FBQyw4T0FBNEI7QUFDM0QsNEJBQTRCLG1CQUFPLENBQUMsbU1BQWlDO0FBQ3JFLHFCQUFxQixtQkFBTyxDQUFDLDZJQUF5QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyw0R0FBVztBQUNwQyxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsd0lBQWU7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLHdJQUFlO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxrSUFBWTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywwSUFBZ0I7QUFDekMsY0FBYyxtQkFBTyxDQUFDLG9JQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixHQUFHLGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEM7QUFDOUM7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHO0FBQ3BELE1BQU07QUFDTiwrQkFBK0IsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxJQUFJLE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9yZWxhdGl2ZS1jb2xvci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgY3NzQ29sb3JQYXJzZXIgPSByZXF1aXJlKFwiQGNzc3Rvb2xzL2Nzcy1jb2xvci1wYXJzZXJcIik7XG5jb25zdCBjc3NQYXJzZXJBbGdvcml0aG1zID0gcmVxdWlyZShcIkBjc3N0b29scy9jc3MtcGFyc2VyLWFsZ29yaXRobXNcIik7XG5jb25zdCBjc3NUb2tlbml6ZXIgPSByZXF1aXJlKFwiQGNzc3Rvb2xzL2Nzcy10b2tlbml6ZXJcIik7XG5jb25zdCBscnVDYWNoZSA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7XG5jb25zdCBjb21tb24gPSByZXF1aXJlKFwiLi9jb21tb24uY2pzXCIpO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoXCIuL2NvbnZlcnQuY2pzXCIpO1xuY29uc3QgY3NzQ2FsYyA9IHJlcXVpcmUoXCIuL2Nzcy1jYWxjLmNqc1wiKTtcbmNvbnN0IHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmNqc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmNqc1wiKTtcbmNvbnN0IGNvbnN0YW50ID0gcmVxdWlyZShcIi4vY29uc3RhbnQuY2pzXCIpO1xuY29uc3QgY29sb3IgPSByZXF1aXJlKFwiLi9jb2xvci5janNcIik7XG5jb25zdCB7XG4gIENsb3NlUGFyZW46IFBBUkVOX0NMT1NFLFxuICBDb21tZW50OiBDT01NRU5ULFxuICBEaW1lbnNpb246IERJTSxcbiAgRU9GLFxuICBGdW5jdGlvbjogRlVOQyxcbiAgSWRlbnQ6IElERU5ULFxuICBOdW1iZXI6IE5VTSxcbiAgT3BlblBhcmVuOiBQQVJFTl9PUEVOLFxuICBQZXJjZW50YWdlOiBQQ1QsXG4gIFdoaXRlc3BhY2U6IFdfU1BBQ0Vcbn0gPSBjc3NUb2tlbml6ZXIuVG9rZW5UeXBlO1xuY29uc3Qge1xuICBIYXNOb25lS2V5d29yZHM6IE5PTkVfS0VZXG59ID0gY3NzQ29sb3JQYXJzZXIuU3ludGF4RmxhZztcbmNvbnN0IE9DVCA9IDg7XG5jb25zdCBERUMgPSAxMDtcbmNvbnN0IEhFWCA9IDE2O1xuY29uc3QgTUFYX1BDVCA9IDEwMDtcbmNvbnN0IE1BWF9SR0IgPSAyNTU7XG5jb25zdCBSRUdfQ09MT1JfQ0FQVCA9IG5ldyBSZWdFeHAoXG4gIGBeJHtjb25zdGFudC5GTl9SRUx9KCR7Y29uc3RhbnQuU1lOX0NPTE9SX1RZUEV9fCR7Y29uc3RhbnQuU1lOX01JWH0pXFxcXHMrYFxuKTtcbmNvbnN0IFJFR19DU19IU0wgPSAvKD86aHNsYT98aHdiKSQvO1xuY29uc3QgUkVHX0NTX0NJRSA9IG5ldyBSZWdFeHAoYF4oPzoke2NvbnN0YW50LkNTX0xBQn18JHtjb25zdGFudC5DU19MQ0h9KSRgKTtcbmNvbnN0IFJFR19GTl9WQVIgPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9WQVIpO1xuY29uc3QgUkVHX1JFTCA9IG5ldyBSZWdFeHAoY29uc3RhbnQuRk5fUkVMKTtcbmNvbnN0IFJFR19SRUxfQ0FQVCA9IG5ldyBSZWdFeHAoYF4ke2NvbnN0YW50LkZOX1JFTF9DQVBUfWApO1xuY29uc3QgUkVHX1NUQVJUX01BVEggPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9NQVRIKTtcbmNvbnN0IFJFR19TVEFSVF9SRUwgPSBuZXcgUmVnRXhwKGBeJHtjb25zdGFudC5GTl9SRUx9YCk7XG5jb25zdCBjYWNoZWRSZXN1bHRzID0gbmV3IGxydUNhY2hlLkxSVUNhY2hlKHtcbiAgbWF4OiA0MDk2XG59KTtcbmZ1bmN0aW9uIHJlc29sdmVDb2xvckNoYW5uZWxzKHRva2Vucywgb3B0ID0ge30pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3Rva2Vuc30gaXMgbm90IGFuIGFycmF5LmApO1xuICB9XG4gIGNvbnN0IHsgY29sb3JTcGFjZSwgZm9ybWF0IH0gPSBvcHQ7XG4gIGNvbnN0IGNvbG9yQ2hhbm5lbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgW1wiY29sb3JcIiwgW1wiclwiLCBcImdcIiwgXCJiXCIsIFwiYWxwaGFcIl1dLFxuICAgIFtcImhzbFwiLCBbXCJoXCIsIFwic1wiLCBcImxcIiwgXCJhbHBoYVwiXV0sXG4gICAgW1wiaHNsYVwiLCBbXCJoXCIsIFwic1wiLCBcImxcIiwgXCJhbHBoYVwiXV0sXG4gICAgW1wiaHdiXCIsIFtcImhcIiwgXCJ3XCIsIFwiYlwiLCBcImFscGhhXCJdXSxcbiAgICBbXCJsYWJcIiwgW1wibFwiLCBcImFcIiwgXCJiXCIsIFwiYWxwaGFcIl1dLFxuICAgIFtcImxjaFwiLCBbXCJsXCIsIFwiY1wiLCBcImhcIiwgXCJhbHBoYVwiXV0sXG4gICAgW1wib2tsYWJcIiwgW1wibFwiLCBcImFcIiwgXCJiXCIsIFwiYWxwaGFcIl1dLFxuICAgIFtcIm9rbGNoXCIsIFtcImxcIiwgXCJjXCIsIFwiaFwiLCBcImFscGhhXCJdXSxcbiAgICBbXCJyZ2JcIiwgW1wiclwiLCBcImdcIiwgXCJiXCIsIFwiYWxwaGFcIl1dLFxuICAgIFtcInJnYmFcIiwgW1wiclwiLCBcImdcIiwgXCJiXCIsIFwiYWxwaGFcIl1dXG4gIF0pO1xuICBjb25zdCBjb2xvckNoYW5uZWwgPSBjb2xvckNoYW5uZWxzLmdldChjb2xvclNwYWNlKTtcbiAgY29uc3QgbWF0aEZ1bmMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBjaGFubmVscyA9IFtbXSwgW10sIFtdLCBbXV07XG4gIGxldCBpID0gMDtcbiAgbGV0IG5lc3QgPSAwO1xuICBsZXQgZnVuYyA9IGZhbHNlO1xuICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0b2tlbn0gaXMgbm90IGFuIGFycmF5LmApO1xuICAgIH1cbiAgICBjb25zdCBbdHlwZSwgdmFsdWUsICwgLCBkZXRhaWwgPSB7fV0gPSB0b2tlbjtcbiAgICBjb25zdCBudW1WYWx1ZSA9IGRldGFpbCA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlsLnZhbHVlO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgRElNOiB7XG4gICAgICAgIGxldCByZXNvbHZlZFZhbHVlID0gY3NzQ2FsYy5yZXNvbHZlRGltZW5zaW9uKHRva2VuLCBvcHQpO1xuICAgICAgICBpZiAoIXJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbC5wdXNoKHJlc29sdmVkVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgRlVOQzoge1xuICAgICAgICBjaGFubmVsLnB1c2godmFsdWUpO1xuICAgICAgICBmdW5jID0gdHJ1ZTtcbiAgICAgICAgbmVzdCsrO1xuICAgICAgICBpZiAoUkVHX1NUQVJUX01BVEgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBtYXRoRnVuYy5hZGQobmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIElERU5UOiB7XG4gICAgICAgIGlmICghY29sb3JDaGFubmVsIHx8ICFjb2xvckNoYW5uZWwuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBOVU06IHtcbiAgICAgICAgY29uc3QgbiA9IG51bVZhbHVlID8/IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBjaGFubmVsLnB1c2gobik7XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUEFSRU5fT1BFTjoge1xuICAgICAgICBjaGFubmVsLnB1c2godmFsdWUpO1xuICAgICAgICBuZXN0Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBQQVJFTl9DTE9TRToge1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdFZhbHVlID09PSBcIiBcIikge1xuICAgICAgICAgICAgY2hhbm5lbC5zcGxpY2UoLTEsIDEsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhbm5lbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGhGdW5jLmhhcyhuZXN0KSkge1xuICAgICAgICAgICAgbWF0aEZ1bmMuZGVsZXRlKG5lc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXN0LS07XG4gICAgICAgICAgaWYgKG5lc3QgPT09IDApIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFBDVDoge1xuICAgICAgICBjb25zdCBuID0gbnVtVmFsdWUgPz8gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGNoYW5uZWwucHVzaChuIC8gTUFYX1BDVCk7XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgV19TUEFDRToge1xuICAgICAgICBpZiAoY2hhbm5lbC5sZW5ndGggJiYgZnVuYykge1xuICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY2hhbm5lbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1N0cmluZyhsYXN0VmFsdWUpICYmICFsYXN0VmFsdWUuZW5kc1dpdGgoXCIoXCIpICYmIGxhc3RWYWx1ZSAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodHlwZSAhPT0gQ09NTUVOVCAmJiB0eXBlICE9PSBFT0YgJiYgZnVuYykge1xuICAgICAgICAgIGNoYW5uZWwucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY2hhbm5lbFZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICBpZiAoY2hhbm5lbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IFtyZXNvbHZlZFZhbHVlXSA9IGNoYW5uZWw7XG4gICAgICBjaGFubmVsVmFsdWVzLnB1c2gocmVzb2x2ZWRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IGNzc0NhbGMuc2VyaWFsaXplQ2FsYyhjaGFubmVsLmpvaW4oXCJcIiksIHtcbiAgICAgICAgZm9ybWF0XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgIGNoYW5uZWxWYWx1ZXMucHVzaChyZXNvbHZlZFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbm5lbFZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW5Db2xvcih2YWx1ZSwgb3B0ID0ge30pIHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIVJFR19TVEFSVF9SRUwudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgeyBjdXJyZW50Q29sb3IsIGZvcm1hdCB9ID0gb3B0O1xuICBjb25zdCBjYWNoZUtleSA9IGB7cHJlUHJvY2Vzczoke3ZhbHVlfSxvcHQ6JHt1dGlsLnZhbHVlVG9Kc29uU3RyaW5nKG9wdCl9fWA7XG4gIGlmIChjYWNoZWRSZXN1bHRzLmhhcyhjYWNoZUtleSkpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIGlmICgvY3VycmVudGNvbG9yLy50ZXN0KHZhbHVlKSkge1xuICAgIGlmIChjdXJyZW50Q29sb3IpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvY3VycmVudGNvbG9yL2csIGN1cnJlbnRDb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY3MgPSB2YWx1ZS5tYXRjaChSRUdfUkVMX0NBUFQpO1xuICBsZXQgY29sb3JTcGFjZTtcbiAgaWYgKGNzKSB7XG4gICAgWywgY29sb3JTcGFjZV0gPSBjcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBvcHQuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG4gIGlmIChSRUdfQ09MT1JfQ0FQVC50ZXN0KHZhbHVlKSkge1xuICAgIGNvbnN0IFssIG9yaWdpbkNvbG9yXSA9IHZhbHVlLm1hdGNoKFJFR19DT0xPUl9DQVBUKTtcbiAgICBjb25zdCBbLCByZXN0VmFsdWVdID0gdmFsdWUuc3BsaXQob3JpZ2luQ29sb3IpO1xuICAgIGlmICgvXlthLXpdKyQvLnRlc3Qob3JpZ2luQ29sb3IpKSB7XG4gICAgICBpZiAoIS9edHJhbnNwYXJlbnQkLy50ZXN0KG9yaWdpbkNvbG9yKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbG9yLk5BTUVEX0NPTE9SUywgb3JpZ2luQ29sb3IpKSB7XG4gICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkT3JpZ2luQ29sb3IgPSByZXNvbHZlLnJlc29sdmUob3JpZ2luQ29sb3IsIG9wdCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2Uob3JpZ2luQ29sb3IsIHJlc29sdmVkT3JpZ2luQ29sb3IpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3NzVG9rZW5pemVyLnRva2VuaXplKHsgY3NzOiByZXN0VmFsdWUgfSk7XG4gICAgICBjb25zdCBjaGFubmVsVmFsdWVzID0gcmVzb2x2ZUNvbG9yQ2hhbm5lbHModG9rZW5zLCBvcHQpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5uZWxWYWx1ZXMpKSB7XG4gICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxldCBjaGFubmVsVmFsdWU7XG4gICAgICBpZiAoY2hhbm5lbFZhbHVlcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgY2hhbm5lbFZhbHVlID0gYCAke2NoYW5uZWxWYWx1ZXMuam9pbihcIiBcIil9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdjEsIHYyLCB2MywgdjRdID0gY2hhbm5lbFZhbHVlcztcbiAgICAgICAgY2hhbm5lbFZhbHVlID0gYCAke3YxfSAke3YyfSAke3YzfSAvICR7djR9KWA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVzdFZhbHVlLCBjaGFubmVsVmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbLCByZXN0VmFsdWVdID0gdmFsdWUuc3BsaXQoUkVHX1NUQVJUX1JFTCk7XG4gICAgaWYgKFJFR19TVEFSVF9SRUwudGVzdChyZXN0VmFsdWUpKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjc3NUb2tlbml6ZXIudG9rZW5pemUoeyBjc3M6IHJlc3RWYWx1ZSB9KTtcbiAgICAgIGNvbnN0IG9yaWdpbkNvbG9yID0gW107XG4gICAgICBsZXQgbmVzdCA9IDA7XG4gICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgICBjb25zdCBbdHlwZSwgdG9rZW5WYWx1ZV0gPSB0b2tlbjtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBGVU5DOlxuICAgICAgICAgIGNhc2UgUEFSRU5fT1BFTjoge1xuICAgICAgICAgICAgb3JpZ2luQ29sb3IucHVzaCh0b2tlblZhbHVlKTtcbiAgICAgICAgICAgIG5lc3QrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFBBUkVOX0NMT1NFOiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSBvcmlnaW5Db2xvcltvcmlnaW5Db2xvci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0VmFsdWUgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgIG9yaWdpbkNvbG9yLnNwbGljZSgtMSwgMSwgdG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcmlnaW5Db2xvci5wdXNoKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVzdC0tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgV19TUEFDRToge1xuICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gb3JpZ2luQ29sb3Jbb3JpZ2luQ29sb3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoIWxhc3RWYWx1ZS5lbmRzV2l0aChcIihcIikgJiYgbGFzdFZhbHVlICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICBvcmlnaW5Db2xvci5wdXNoKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBDT01NRU5UICYmIHR5cGUgIT09IEVPRikge1xuICAgICAgICAgICAgICBvcmlnaW5Db2xvci5wdXNoKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVzdCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZE9yaWdpbkNvbG9yID0gcmVzb2x2ZVJlbGF0aXZlQ29sb3IoXG4gICAgICAgIG9yaWdpbkNvbG9yLmpvaW4oXCJcIikudHJpbSgpLFxuICAgICAgICBvcHRcbiAgICAgICk7XG4gICAgICBpZiAoIXJlc29sdmVkT3JpZ2luQ29sb3IpIHtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbm5lbFZhbHVlcyA9IHJlc29sdmVDb2xvckNoYW5uZWxzKHRva2Vucywgb3B0KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGFubmVsVmFsdWVzKSkge1xuICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgY2hhbm5lbFZhbHVlO1xuICAgICAgaWYgKGNoYW5uZWxWYWx1ZXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNoYW5uZWxWYWx1ZSA9IGAgJHtjaGFubmVsVmFsdWVzLmpvaW4oXCIgXCIpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgW3YxLCB2MiwgdjMsIHY0XSA9IGNoYW5uZWxWYWx1ZXM7XG4gICAgICAgIGNoYW5uZWxWYWx1ZSA9IGAgJHt2MX0gJHt2Mn0gJHt2M30gLyAke3Y0fSlgO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlc3RWYWx1ZSwgYCR7cmVzb2x2ZWRPcmlnaW5Db2xvcn0ke2NoYW5uZWxWYWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVDb2xvcih2YWx1ZSwgb3B0ID0ge30pIHtcbiAgY29uc3QgeyBmb3JtYXQgfSA9IG9wdDtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBpZiAoUkVHX0ZOX1ZBUi50ZXN0KHZhbHVlKSkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRva2VuICR7Y29uc3RhbnQuRk5fVkFSfSBmb3VuZC5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFSRUdfUkVMLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBge3JlbGF0aXZlQ29sb3I6JHt2YWx1ZX0sb3B0OiR7dXRpbC52YWx1ZVRvSnNvblN0cmluZyhvcHQpfX1gO1xuICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdHMuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICBjb25zdCBvcmlnaW5Db2xvciA9IGV4dHJhY3RPcmlnaW5Db2xvcih2YWx1ZSwgb3B0KTtcbiAgaWYgKG9yaWdpbkNvbG9yKSB7XG4gICAgdmFsdWUgPSBvcmlnaW5Db2xvcjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15yZ2JhXFwoLywgXCJyZ2IoXCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChcImhzbGEoXCIpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15oc2xhXFwoLywgXCJoc2woXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gY3NzVG9rZW5pemVyLnRva2VuaXplKHsgY3NzOiB2YWx1ZSB9KTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGNzc1BhcnNlckFsZ29yaXRobXMucGFyc2VDb21wb25lbnRWYWx1ZSh0b2tlbnMpO1xuICBjb25zdCBwYXJzZWRDb21wb25lbnRzID0gY3NzQ29sb3JQYXJzZXIuY29sb3IoY29tcG9uZW50cyk7XG4gIGlmICghcGFyc2VkQ29tcG9uZW50cykge1xuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7XG4gICAgYWxwaGE6IGFscGhhQ29tcG9uZW50LFxuICAgIGNoYW5uZWxzOiBjaGFubmVsc0NvbXBvbmVudCxcbiAgICBjb2xvck5vdGF0aW9uLFxuICAgIHN5bnRheEZsYWdzXG4gIH0gPSBwYXJzZWRDb21wb25lbnRzO1xuICBsZXQgYWxwaGE7XG4gIGlmIChOdW1iZXIuaXNOYU4oTnVtYmVyKGFscGhhQ29tcG9uZW50KSkpIHtcbiAgICBpZiAoc3ludGF4RmxhZ3MgaW5zdGFuY2VvZiBTZXQgJiYgc3ludGF4RmxhZ3MuaGFzKE5PTkVfS0VZKSkge1xuICAgICAgYWxwaGEgPSBjb25zdGFudC5OT05FO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFscGhhID0gdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGFscGhhQ29tcG9uZW50LCBPQ1QpO1xuICB9XG4gIGxldCB2MTtcbiAgbGV0IHYyO1xuICBsZXQgdjM7XG4gIFt2MSwgdjIsIHYzXSA9IGNoYW5uZWxzQ29tcG9uZW50O1xuICBsZXQgcmVzb2x2ZWRWYWx1ZTtcbiAgaWYgKFJFR19DU19DSUUudGVzdChjb2xvck5vdGF0aW9uKSkge1xuICAgIGNvbnN0IGhhc05vbmUgPSBzeW50YXhGbGFncyBpbnN0YW5jZW9mIFNldCAmJiBzeW50YXhGbGFncy5oYXMoTk9ORV9LRVkpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odjEpKSB7XG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICB2MSA9IGNvbnN0YW50Lk5PTkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHYxID0gdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHYxLCBIRVgpO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHYyKSkge1xuICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgdjIgPSBjb25zdGFudC5OT05FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdjIgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2MiA9IHV0aWwucm91bmRUb1ByZWNpc2lvbih2MiwgSEVYKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc05hTih2MykpIHtcbiAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgIHYzID0gY29uc3RhbnQuTk9ORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYzID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdjMgPSB1dGlsLnJvdW5kVG9QcmVjaXNpb24odjMsIEhFWCk7XG4gICAgfVxuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGAke2NvbG9yTm90YXRpb259KCR7djF9ICR7djJ9ICR7djN9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkVmFsdWUgPSBgJHtjb2xvck5vdGF0aW9ufSgke3YxfSAke3YyfSAke3YzfSAvICR7YWxwaGF9KWA7XG4gICAgfVxuICB9IGVsc2UgaWYgKFJFR19DU19IU0wudGVzdChjb2xvck5vdGF0aW9uKSkge1xuICAgIGlmIChOdW1iZXIuaXNOYU4odjEpKSB7XG4gICAgICB2MSA9IDA7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4odjIpKSB7XG4gICAgICB2MiA9IDA7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4odjMpKSB7XG4gICAgICB2MyA9IDA7XG4gICAgfVxuICAgIGxldCBbciwgZywgYl0gPSBjb252ZXJ0LmNvbG9yVG9SZ2IoXG4gICAgICBgJHtjb2xvck5vdGF0aW9ufSgke3YxfSAke3YyfSAke3YzfSAvICR7YWxwaGF9KWBcbiAgICApO1xuICAgIHIgPSB1dGlsLnJvdW5kVG9QcmVjaXNpb24ociAvIE1BWF9SR0IsIERFQyk7XG4gICAgZyA9IHV0aWwucm91bmRUb1ByZWNpc2lvbihnIC8gTUFYX1JHQiwgREVDKTtcbiAgICBiID0gdXRpbC5yb3VuZFRvUHJlY2lzaW9uKGIgLyBNQVhfUkdCLCBERUMpO1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGBjb2xvcihzcmdiICR7cn0gJHtnfSAke2J9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkVmFsdWUgPSBgY29sb3Ioc3JnYiAke3J9ICR7Z30gJHtifSAvICR7YWxwaGF9KWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNzID0gY29sb3JOb3RhdGlvbiA9PT0gXCJyZ2JcIiA/IFwic3JnYlwiIDogY29sb3JOb3RhdGlvbjtcbiAgICBjb25zdCBoYXNOb25lID0gc3ludGF4RmxhZ3MgaW5zdGFuY2VvZiBTZXQgJiYgc3ludGF4RmxhZ3MuaGFzKE5PTkVfS0VZKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHYxKSkge1xuICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgdjEgPSBjb25zdGFudC5OT05FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdjEgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2MSA9IHV0aWwucm91bmRUb1ByZWNpc2lvbih2MSwgREVDKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc05hTih2MikpIHtcbiAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgIHYyID0gY29uc3RhbnQuTk9ORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYyID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdjIgPSB1dGlsLnJvdW5kVG9QcmVjaXNpb24odjIsIERFQyk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4odjMpKSB7XG4gICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICB2MyA9IGNvbnN0YW50Lk5PTkU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MyA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHYzID0gdXRpbC5yb3VuZFRvUHJlY2lzaW9uKHYzLCBERUMpO1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDEpIHtcbiAgICAgIHJlc29sdmVkVmFsdWUgPSBgY29sb3IoJHtjc30gJHt2MX0gJHt2Mn0gJHt2M30pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGBjb2xvcigke2NzfSAke3YxfSAke3YyfSAke3YzfSAvICR7YWxwaGF9KWA7XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZUtleSkge1xuICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCByZXNvbHZlZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRWYWx1ZTtcbn1cbmV4cG9ydHMuY2FjaGVkUmVzdWx0cyA9IGNhY2hlZFJlc3VsdHM7XG5leHBvcnRzLmV4dHJhY3RPcmlnaW5Db2xvciA9IGV4dHJhY3RPcmlnaW5Db2xvcjtcbmV4cG9ydHMucmVzb2x2ZUNvbG9yQ2hhbm5lbHMgPSByZXNvbHZlQ29sb3JDaGFubmVscztcbmV4cG9ydHMucmVzb2x2ZVJlbGF0aXZlQ29sb3IgPSByZXNvbHZlUmVsYXRpdmVDb2xvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbGF0aXZlLWNvbG9yLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/relative-color.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst lruCache = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/.pnpm/lru-cache@10.4.3/node_modules/lru-cache/dist/commonjs/index.js\");\nconst color = __webpack_require__(/*! ./color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs\");\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst cssCalc = __webpack_require__(/*! ./css-calc.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-calc.cjs\");\nconst cssVar = __webpack_require__(/*! ./css-var.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/css-var.cjs\");\nconst relativeColor = __webpack_require__(/*! ./relative-color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/relative-color.cjs\");\nconst util = __webpack_require__(/*! ./util.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst RGB_TRANSPARENT = \"rgba(0, 0, 0, 0)\";\nconst REG_FN_MATH_CALC = new RegExp(constant.SYN_FN_MATH_CALC);\nconst REG_FN_REL = new RegExp(constant.SYN_FN_REL);\nconst REG_FN_VAR = new RegExp(constant.SYN_FN_VAR);\nconst cachedResults = new lruCache.LRUCache({\n  max: 4096\n});\nconst resolve = (color$1, opt = {}) => {\n  if (common.isString(color$1)) {\n    color$1 = color$1.trim();\n  } else {\n    throw new TypeError(`${color$1} is not a string.`);\n  }\n  const { currentColor, customProperty = {}, format = constant.VAL_COMP, key } = opt;\n  let cacheKey;\n  if (!REG_FN_VAR.test(color$1) || typeof customProperty.callback === \"function\") {\n    cacheKey = `{resolve:${color$1},opt:${util.valueToJsonString(opt)}}`;\n    if (cachedResults.has(cacheKey)) {\n      return cachedResults.get(cacheKey);\n    }\n  }\n  let res, cs, r, g, b, alpha;\n  if (REG_FN_VAR.test(color$1)) {\n    if (format === constant.VAL_SPEC) {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, color$1);\n      }\n      return color$1;\n    }\n    const resolvedColor = cssVar.cssVar(color$1, opt);\n    if (resolvedColor) {\n      color$1 = resolvedColor;\n    } else {\n      switch (format) {\n        case \"hex\":\n        case \"hexAlpha\": {\n          if (cacheKey) {\n            cachedResults.set(cacheKey, null);\n          }\n          return null;\n        }\n        default: {\n          res = RGB_TRANSPARENT;\n          if (cacheKey) {\n            cachedResults.set(cacheKey, res);\n          }\n          return res;\n        }\n      }\n    }\n  }\n  if (opt.format !== format) {\n    opt.format = format;\n  }\n  color$1 = color$1.toLowerCase();\n  if (REG_FN_REL.test(color$1)) {\n    const resolvedColor = relativeColor.resolveRelativeColor(color$1, opt);\n    if (format === constant.VAL_COMP) {\n      if (resolvedColor) {\n        res = resolvedColor;\n      } else {\n        res = RGB_TRANSPARENT;\n      }\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    }\n    if (format === constant.VAL_SPEC) {\n      if (resolvedColor) {\n        res = resolvedColor;\n      } else {\n        res = \"\";\n      }\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    }\n    if (resolvedColor) {\n      color$1 = resolvedColor;\n    } else {\n      color$1 = \"\";\n    }\n  }\n  if (REG_FN_MATH_CALC.test(color$1)) {\n    const resolvedColor = cssCalc.cssCalc(color$1, opt);\n    if (resolvedColor) {\n      color$1 = resolvedColor;\n    } else {\n      color$1 = \"\";\n    }\n  }\n  if (color$1 === \"transparent\") {\n    switch (format) {\n      case constant.VAL_SPEC: {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, color$1);\n        }\n        return color$1;\n      }\n      case \"hex\": {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null);\n        }\n        return null;\n      }\n      case \"hexAlpha\": {\n        res = \"#00000000\";\n        if (cacheKey) {\n          cachedResults.set(cacheKey, res);\n        }\n        return res;\n      }\n      case constant.VAL_COMP:\n      default: {\n        res = RGB_TRANSPARENT;\n        if (cacheKey) {\n          cachedResults.set(cacheKey, res);\n        }\n        return res;\n      }\n    }\n  } else if (color$1 === \"currentcolor\") {\n    if (format === constant.VAL_SPEC) {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, color$1);\n      }\n      return color$1;\n    }\n    if (currentColor) {\n      if (currentColor.startsWith(constant.FN_MIX)) {\n        [cs, r, g, b, alpha] = color.resolveColorMix(currentColor, opt);\n      } else if (currentColor.startsWith(constant.FN_COLOR)) {\n        [cs, r, g, b, alpha] = color.resolveColorFunc(currentColor, opt);\n      } else {\n        [cs, r, g, b, alpha] = color.resolveColorValue(currentColor, opt);\n      }\n    } else if (format === constant.VAL_COMP) {\n      res = RGB_TRANSPARENT;\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    }\n  } else if (format === constant.VAL_SPEC) {\n    if (color$1.startsWith(constant.FN_MIX)) {\n      res = color.resolveColorMix(color$1, opt);\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    } else if (color$1.startsWith(constant.FN_COLOR)) {\n      [cs, r, g, b, alpha] = color.resolveColorFunc(color$1, opt);\n      if (alpha === 1) {\n        res = `color(${cs} ${r} ${g} ${b})`;\n      } else {\n        res = `color(${cs} ${r} ${g} ${b} / ${alpha})`;\n      }\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    } else {\n      const rgb = color.resolveColorValue(color$1, opt);\n      if (!rgb) {\n        res = \"\";\n        if (cacheKey) {\n          cachedResults.set(cacheKey, res);\n        }\n        return res;\n      }\n      [cs, r, g, b, alpha] = rgb;\n      if (cs === \"rgb\") {\n        if (alpha === 1) {\n          res = `${cs}(${r}, ${g}, ${b})`;\n        } else {\n          res = `${cs}a(${r}, ${g}, ${b}, ${alpha})`;\n        }\n        if (cacheKey) {\n          cachedResults.set(cacheKey, res);\n        }\n        return res;\n      }\n      if (alpha === 1) {\n        res = `${cs}(${r} ${g} ${b})`;\n      } else {\n        res = `${cs}(${r} ${g} ${b} / ${alpha})`;\n      }\n      if (cacheKey) {\n        cachedResults.set(cacheKey, res);\n      }\n      return res;\n    }\n  } else if (/currentcolor/.test(color$1)) {\n    if (currentColor) {\n      color$1 = color$1.replace(/currentcolor/g, currentColor);\n    }\n    if (/transparent/.test(color$1)) {\n      color$1 = color$1.replace(/transparent/g, RGB_TRANSPARENT);\n    }\n    if (color$1.startsWith(constant.FN_MIX)) {\n      [cs, r, g, b, alpha] = color.resolveColorMix(color$1, opt);\n    }\n  } else if (/transparent/.test(color$1)) {\n    color$1 = color$1.replace(/transparent/g, RGB_TRANSPARENT);\n    if (color$1.startsWith(constant.FN_MIX)) {\n      [cs, r, g, b, alpha] = color.resolveColorMix(color$1, opt);\n    }\n  } else if (color$1.startsWith(constant.FN_MIX)) {\n    [cs, r, g, b, alpha] = color.resolveColorMix(color$1, opt);\n  } else if (color$1.startsWith(constant.FN_COLOR)) {\n    [cs, r, g, b, alpha] = color.resolveColorFunc(color$1, opt);\n  } else if (color$1) {\n    [cs, r, g, b, alpha] = color.resolveColorValue(color$1, opt);\n  }\n  switch (format) {\n    case \"hex\": {\n      let hex;\n      if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(alpha) || alpha === 0) {\n        hex = null;\n      } else {\n        hex = color.convertRgbToHex([r, g, b]);\n      }\n      if (key) {\n        res = [key, hex];\n      } else {\n        res = hex;\n      }\n      break;\n    }\n    case \"hexAlpha\": {\n      let hex;\n      if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(alpha)) {\n        hex = null;\n      } else {\n        hex = color.convertRgbToHex([\n          r,\n          g,\n          b,\n          alpha\n        ]);\n      }\n      if (key) {\n        res = [key, hex];\n      } else {\n        res = hex;\n      }\n      break;\n    }\n    case constant.VAL_COMP:\n    default: {\n      let value;\n      switch (cs) {\n        case \"rgb\": {\n          if (alpha === 1) {\n            value = `${cs}(${r}, ${g}, ${b})`;\n          } else {\n            value = `${cs}a(${r}, ${g}, ${b}, ${alpha})`;\n          }\n          break;\n        }\n        case \"lab\":\n        case \"lch\":\n        case \"oklab\":\n        case \"oklch\": {\n          if (alpha === 1) {\n            value = `${cs}(${r} ${g} ${b})`;\n          } else {\n            value = `${cs}(${r} ${g} ${b} / ${alpha})`;\n          }\n          break;\n        }\n        // color()\n        default: {\n          if (alpha === 1) {\n            value = `color(${cs} ${r} ${g} ${b})`;\n          } else {\n            value = `color(${cs} ${r} ${g} ${b} / ${alpha})`;\n          }\n        }\n      }\n      if (key) {\n        res = [key, value];\n      } else {\n        res = value;\n      }\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, res);\n  }\n  return res;\n};\nexports.cachedResults = cachedResults;\nexports.resolve = resolve;\n//# sourceMappingURL=resolve.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvcmVzb2x2ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFLGlCQUFpQixtQkFBTyxDQUFDLDRHQUFXO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxvSUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsc0lBQWM7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsMElBQWdCO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx3SUFBZTtBQUN0QyxzQkFBc0IsbUJBQU8sQ0FBQyxzSkFBc0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLGtJQUFZO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBJQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSxVQUFVLGlDQUFpQyxvQ0FBb0M7QUFDL0U7QUFDQTtBQUNBLGlCQUFpQixVQUFVLFFBQVEsT0FBTyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVCQUF1QixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3pDLFFBQVE7QUFDUix1QkFBdUIsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDdkMsVUFBVTtBQUNWLG1CQUFtQixHQUFHLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ25DLFFBQVE7QUFDUixpQkFBaUIsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzNDLFlBQVk7QUFDWix1QkFBdUIsR0FBRyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3pDLFlBQVk7QUFDWix1QkFBdUIsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDL0MsWUFBWTtBQUNaLDZCQUE2QixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AYXNhbXV6YWtqcCtjc3MtY29sb3JAMi44LjMvbm9kZV9tb2R1bGVzL0Bhc2FtdXpha2pwL2Nzcy1jb2xvci9kaXN0L2Nqcy9qcy9yZXNvbHZlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSk7XG5jb25zdCBscnVDYWNoZSA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7XG5jb25zdCBjb2xvciA9IHJlcXVpcmUoXCIuL2NvbG9yLmNqc1wiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuL2NvbW1vbi5janNcIik7XG5jb25zdCBjc3NDYWxjID0gcmVxdWlyZShcIi4vY3NzLWNhbGMuY2pzXCIpO1xuY29uc3QgY3NzVmFyID0gcmVxdWlyZShcIi4vY3NzLXZhci5janNcIik7XG5jb25zdCByZWxhdGl2ZUNvbG9yID0gcmVxdWlyZShcIi4vcmVsYXRpdmUtY29sb3IuY2pzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuY2pzXCIpO1xuY29uc3QgY29uc3RhbnQgPSByZXF1aXJlKFwiLi9jb25zdGFudC5janNcIik7XG5jb25zdCBSR0JfVFJBTlNQQVJFTlQgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbmNvbnN0IFJFR19GTl9NQVRIX0NBTEMgPSBuZXcgUmVnRXhwKGNvbnN0YW50LlNZTl9GTl9NQVRIX0NBTEMpO1xuY29uc3QgUkVHX0ZOX1JFTCA9IG5ldyBSZWdFeHAoY29uc3RhbnQuU1lOX0ZOX1JFTCk7XG5jb25zdCBSRUdfRk5fVkFSID0gbmV3IFJlZ0V4cChjb25zdGFudC5TWU5fRk5fVkFSKTtcbmNvbnN0IGNhY2hlZFJlc3VsdHMgPSBuZXcgbHJ1Q2FjaGUuTFJVQ2FjaGUoe1xuICBtYXg6IDQwOTZcbn0pO1xuY29uc3QgcmVzb2x2ZSA9IChjb2xvciQxLCBvcHQgPSB7fSkgPT4ge1xuICBpZiAoY29tbW9uLmlzU3RyaW5nKGNvbG9yJDEpKSB7XG4gICAgY29sb3IkMSA9IGNvbG9yJDEudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29sb3IkMX0gaXMgbm90IGEgc3RyaW5nLmApO1xuICB9XG4gIGNvbnN0IHsgY3VycmVudENvbG9yLCBjdXN0b21Qcm9wZXJ0eSA9IHt9LCBmb3JtYXQgPSBjb25zdGFudC5WQUxfQ09NUCwga2V5IH0gPSBvcHQ7XG4gIGxldCBjYWNoZUtleTtcbiAgaWYgKCFSRUdfRk5fVkFSLnRlc3QoY29sb3IkMSkgfHwgdHlwZW9mIGN1c3RvbVByb3BlcnR5LmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjYWNoZUtleSA9IGB7cmVzb2x2ZToke2NvbG9yJDF9LG9wdDoke3V0aWwudmFsdWVUb0pzb25TdHJpbmcob3B0KX19YDtcbiAgICBpZiAoY2FjaGVkUmVzdWx0cy5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cy5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgfVxuICBsZXQgcmVzLCBjcywgciwgZywgYiwgYWxwaGE7XG4gIGlmIChSRUdfRk5fVkFSLnRlc3QoY29sb3IkMSkpIHtcbiAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCBjb2xvciQxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xvciQxO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZENvbG9yID0gY3NzVmFyLmNzc1Zhcihjb2xvciQxLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZENvbG9yKSB7XG4gICAgICBjb2xvciQxID0gcmVzb2x2ZWRDb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICBjYXNlIFwiaGV4QWxwaGFcIjoge1xuICAgICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgcmVzID0gUkdCX1RSQU5TUEFSRU5UO1xuICAgICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdC5mb3JtYXQgIT09IGZvcm1hdCkge1xuICAgIG9wdC5mb3JtYXQgPSBmb3JtYXQ7XG4gIH1cbiAgY29sb3IkMSA9IGNvbG9yJDEudG9Mb3dlckNhc2UoKTtcbiAgaWYgKFJFR19GTl9SRUwudGVzdChjb2xvciQxKSkge1xuICAgIGNvbnN0IHJlc29sdmVkQ29sb3IgPSByZWxhdGl2ZUNvbG9yLnJlc29sdmVSZWxhdGl2ZUNvbG9yKGNvbG9yJDEsIG9wdCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX0NPTVApIHtcbiAgICAgIGlmIChyZXNvbHZlZENvbG9yKSB7XG4gICAgICAgIHJlcyA9IHJlc29sdmVkQ29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBSR0JfVFJBTlNQQVJFTlQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSBjb25zdGFudC5WQUxfU1BFQykge1xuICAgICAgaWYgKHJlc29sdmVkQ29sb3IpIHtcbiAgICAgICAgcmVzID0gcmVzb2x2ZWRDb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWRDb2xvcikge1xuICAgICAgY29sb3IkMSA9IHJlc29sdmVkQ29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yJDEgPSBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoUkVHX0ZOX01BVEhfQ0FMQy50ZXN0KGNvbG9yJDEpKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRDb2xvciA9IGNzc0NhbGMuY3NzQ2FsYyhjb2xvciQxLCBvcHQpO1xuICAgIGlmIChyZXNvbHZlZENvbG9yKSB7XG4gICAgICBjb2xvciQxID0gcmVzb2x2ZWRDb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IkMSA9IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmIChjb2xvciQxID09PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBjb25zdGFudC5WQUxfU1BFQzoge1xuICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgY29sb3IkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yJDE7XG4gICAgICB9XG4gICAgICBjYXNlIFwiaGV4XCI6IHtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBcImhleEFscGhhXCI6IHtcbiAgICAgICAgcmVzID0gXCIjMDAwMDAwMDBcIjtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNhc2UgY29uc3RhbnQuVkFMX0NPTVA6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJlcyA9IFJHQl9UUkFOU1BBUkVOVDtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3IkMSA9PT0gXCJjdXJyZW50Y29sb3JcIikge1xuICAgIGlmIChmb3JtYXQgPT09IGNvbnN0YW50LlZBTF9TUEVDKSB7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIGNvbG9yJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbG9yJDE7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q29sb3IpIHtcbiAgICAgIGlmIChjdXJyZW50Q29sb3Iuc3RhcnRzV2l0aChjb25zdGFudC5GTl9NSVgpKSB7XG4gICAgICAgIFtjcywgciwgZywgYiwgYWxwaGFdID0gY29sb3IucmVzb2x2ZUNvbG9yTWl4KGN1cnJlbnRDb2xvciwgb3B0KTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbG9yLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgICAgIFtjcywgciwgZywgYiwgYWxwaGFdID0gY29sb3IucmVzb2x2ZUNvbG9yRnVuYyhjdXJyZW50Q29sb3IsIG9wdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbY3MsIHIsIGcsIGIsIGFscGhhXSA9IGNvbG9yLnJlc29sdmVDb2xvclZhbHVlKGN1cnJlbnRDb2xvciwgb3B0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX0NPTVApIHtcbiAgICAgIHJlcyA9IFJHQl9UUkFOU1BBUkVOVDtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gY29uc3RhbnQuVkFMX1NQRUMpIHtcbiAgICBpZiAoY29sb3IkMS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX01JWCkpIHtcbiAgICAgIHJlcyA9IGNvbG9yLnJlc29sdmVDb2xvck1peChjb2xvciQxLCBvcHQpO1xuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdHMuc2V0KGNhY2hlS2V5LCByZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKGNvbG9yJDEuc3RhcnRzV2l0aChjb25zdGFudC5GTl9DT0xPUikpIHtcbiAgICAgIFtjcywgciwgZywgYiwgYWxwaGFdID0gY29sb3IucmVzb2x2ZUNvbG9yRnVuYyhjb2xvciQxLCBvcHQpO1xuICAgICAgaWYgKGFscGhhID09PSAxKSB7XG4gICAgICAgIHJlcyA9IGBjb2xvcigke2NzfSAke3J9ICR7Z30gJHtifSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gYGNvbG9yKCR7Y3N9ICR7cn0gJHtnfSAke2J9IC8gJHthbHBoYX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJnYiA9IGNvbG9yLnJlc29sdmVDb2xvclZhbHVlKGNvbG9yJDEsIG9wdCk7XG4gICAgICBpZiAoIXJnYikge1xuICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICBjYWNoZWRSZXN1bHRzLnNldChjYWNoZUtleSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgW2NzLCByLCBnLCBiLCBhbHBoYV0gPSByZ2I7XG4gICAgICBpZiAoY3MgPT09IFwicmdiXCIpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSAxKSB7XG4gICAgICAgICAgcmVzID0gYCR7Y3N9KCR7cn0sICR7Z30sICR7Yn0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBgJHtjc31hKCR7cn0sICR7Z30sICR7Yn0sICR7YWxwaGF9KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgICByZXMgPSBgJHtjc30oJHtyfSAke2d9ICR7Yn0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IGAke2NzfSgke3J9ICR7Z30gJHtifSAvICR7YWxwaGF9KWA7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBlbHNlIGlmICgvY3VycmVudGNvbG9yLy50ZXN0KGNvbG9yJDEpKSB7XG4gICAgaWYgKGN1cnJlbnRDb2xvcikge1xuICAgICAgY29sb3IkMSA9IGNvbG9yJDEucmVwbGFjZSgvY3VycmVudGNvbG9yL2csIGN1cnJlbnRDb2xvcik7XG4gICAgfVxuICAgIGlmICgvdHJhbnNwYXJlbnQvLnRlc3QoY29sb3IkMSkpIHtcbiAgICAgIGNvbG9yJDEgPSBjb2xvciQxLnJlcGxhY2UoL3RyYW5zcGFyZW50L2csIFJHQl9UUkFOU1BBUkVOVCk7XG4gICAgfVxuICAgIGlmIChjb2xvciQxLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fTUlYKSkge1xuICAgICAgW2NzLCByLCBnLCBiLCBhbHBoYV0gPSBjb2xvci5yZXNvbHZlQ29sb3JNaXgoY29sb3IkMSwgb3B0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoL3RyYW5zcGFyZW50Ly50ZXN0KGNvbG9yJDEpKSB7XG4gICAgY29sb3IkMSA9IGNvbG9yJDEucmVwbGFjZSgvdHJhbnNwYXJlbnQvZywgUkdCX1RSQU5TUEFSRU5UKTtcbiAgICBpZiAoY29sb3IkMS5zdGFydHNXaXRoKGNvbnN0YW50LkZOX01JWCkpIHtcbiAgICAgIFtjcywgciwgZywgYiwgYWxwaGFdID0gY29sb3IucmVzb2x2ZUNvbG9yTWl4KGNvbG9yJDEsIG9wdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbG9yJDEuc3RhcnRzV2l0aChjb25zdGFudC5GTl9NSVgpKSB7XG4gICAgW2NzLCByLCBnLCBiLCBhbHBoYV0gPSBjb2xvci5yZXNvbHZlQ29sb3JNaXgoY29sb3IkMSwgb3B0KTtcbiAgfSBlbHNlIGlmIChjb2xvciQxLnN0YXJ0c1dpdGgoY29uc3RhbnQuRk5fQ09MT1IpKSB7XG4gICAgW2NzLCByLCBnLCBiLCBhbHBoYV0gPSBjb2xvci5yZXNvbHZlQ29sb3JGdW5jKGNvbG9yJDEsIG9wdCk7XG4gIH0gZWxzZSBpZiAoY29sb3IkMSkge1xuICAgIFtjcywgciwgZywgYiwgYWxwaGFdID0gY29sb3IucmVzb2x2ZUNvbG9yVmFsdWUoY29sb3IkMSwgb3B0KTtcbiAgfVxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJoZXhcIjoge1xuICAgICAgbGV0IGhleDtcbiAgICAgIGlmIChpc05hTihyKSB8fCBpc05hTihnKSB8fCBpc05hTihiKSB8fCBpc05hTihhbHBoYSkgfHwgYWxwaGEgPT09IDApIHtcbiAgICAgICAgaGV4ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhleCA9IGNvbG9yLmNvbnZlcnRSZ2JUb0hleChbciwgZywgYl0pO1xuICAgICAgfVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICByZXMgPSBba2V5LCBoZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gaGV4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJoZXhBbHBoYVwiOiB7XG4gICAgICBsZXQgaGV4O1xuICAgICAgaWYgKGlzTmFOKHIpIHx8IGlzTmFOKGcpIHx8IGlzTmFOKGIpIHx8IGlzTmFOKGFscGhhKSkge1xuICAgICAgICBoZXggPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGV4ID0gY29sb3IuY29udmVydFJnYlRvSGV4KFtcbiAgICAgICAgICByLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgYixcbiAgICAgICAgICBhbHBoYVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmVzID0gW2tleSwgaGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IGhleDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIGNvbnN0YW50LlZBTF9DT01QOlxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIHN3aXRjaCAoY3MpIHtcbiAgICAgICAgY2FzZSBcInJnYlwiOiB7XG4gICAgICAgICAgaWYgKGFscGhhID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGAke2NzfSgke3J9LCAke2d9LCAke2J9KWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7Y3N9YSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibGFiXCI6XG4gICAgICAgIGNhc2UgXCJsY2hcIjpcbiAgICAgICAgY2FzZSBcIm9rbGFiXCI6XG4gICAgICAgIGNhc2UgXCJva2xjaFwiOiB7XG4gICAgICAgICAgaWYgKGFscGhhID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGAke2NzfSgke3J9ICR7Z30gJHtifSlgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGAke2NzfSgke3J9ICR7Z30gJHtifSAvICR7YWxwaGF9KWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbG9yKClcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSBgY29sb3IoJHtjc30gJHtyfSAke2d9ICR7Yn0pYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBgY29sb3IoJHtjc30gJHtyfSAke2d9ICR7Yn0gLyAke2FscGhhfSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICByZXMgPSBba2V5LCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlS2V5KSB7XG4gICAgY2FjaGVkUmVzdWx0cy5zZXQoY2FjaGVLZXksIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5leHBvcnRzLmNhY2hlZFJlc3VsdHMgPSBjYWNoZWRSZXN1bHRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nconst common = __webpack_require__(/*! ./common.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/common.cjs\");\nconst resolve = __webpack_require__(/*! ./resolve.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/resolve.cjs\");\nconst color = __webpack_require__(/*! ./color.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/color.cjs\");\nconst constant = __webpack_require__(/*! ./constant.cjs */ \"(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/constant.cjs\");\nconst DEC = 10;\nconst HEX = 16;\nconst DEG = 360;\nconst DEG_HALF = 180;\nconst REG_COLOR = new RegExp(`^(?:${constant.SYN_COLOR_TYPE})$`);\nconst REG_MIX = new RegExp(`${constant.SYN_MIX}`);\nconst isColor = (value) => {\n  if (common.isString(value)) {\n    value = value.toLowerCase().trim();\n    if (value) {\n      if (/^[a-z]+$/.test(value)) {\n        if (/^(?:currentcolor|transparent)$/.test(value) || Object.prototype.hasOwnProperty.call(color.NAMED_COLORS, value)) {\n          return true;\n        }\n      } else if (REG_COLOR.test(value) || REG_MIX.test(value)) {\n        return true;\n      } else {\n        const resolvedValue = resolve.resolve(value, {\n          format: constant.VAL_SPEC\n        });\n        if (resolvedValue) {\n          return true;\n        }\n        return false;\n      }\n    }\n  }\n  return false;\n};\nconst valueToJsonString = (value, func = false) => {\n  if (typeof value === \"undefined\") {\n    return \"\";\n  }\n  const res = JSON.stringify(value, (_key, val) => {\n    let replacedValue;\n    if (typeof val === \"undefined\") {\n      replacedValue = null;\n    } else if (typeof val === \"function\") {\n      if (func) {\n        replacedValue = val.toString();\n      } else {\n        replacedValue = val.name;\n      }\n    } else if (val instanceof Map || val instanceof Set) {\n      replacedValue = [...val];\n    } else if (typeof val === \"bigint\") {\n      replacedValue = val.toString();\n    } else {\n      replacedValue = val;\n    }\n    return replacedValue;\n  });\n  return res;\n};\nconst roundToPrecision = (value, bit = 0) => {\n  if (!Number.isFinite(value)) {\n    throw new TypeError(`${value} is not a number.`);\n  }\n  if (!Number.isFinite(bit)) {\n    throw new TypeError(`${bit} is not a number.`);\n  } else if (bit < 0 || bit > HEX) {\n    throw new RangeError(`${bit} is not between 0 and ${HEX}.`);\n  }\n  if (bit === 0) {\n    return Math.round(value);\n  }\n  let val;\n  if (bit === HEX) {\n    val = value.toPrecision(6);\n  } else if (bit < DEC) {\n    val = value.toPrecision(4);\n  } else {\n    val = value.toPrecision(5);\n  }\n  return parseFloat(val);\n};\nconst interpolateHue = (hueA, hueB, arc = \"shorter\") => {\n  if (!Number.isFinite(hueA)) {\n    throw new TypeError(`${hueA} is not a number.`);\n  }\n  if (!Number.isFinite(hueB)) {\n    throw new TypeError(`${hueB} is not a number.`);\n  }\n  switch (arc) {\n    case \"decreasing\": {\n      if (hueB > hueA) {\n        hueA += DEG;\n      }\n      break;\n    }\n    case \"increasing\": {\n      if (hueB < hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case \"longer\": {\n      if (hueB > hueA && hueB < hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB > hueA + DEG_HALF * -1 && hueB <= hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case \"shorter\":\n    default: {\n      if (hueB > hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB < hueA + DEG_HALF * -1) {\n        hueB += DEG;\n      }\n    }\n  }\n  return [hueA, hueB];\n};\nexports.interpolateHue = interpolateHue;\nexports.isColor = isColor;\nexports.roundToPrecision = roundToPrecision;\nexports.valueToJsonString = valueToJsonString;\n//# sourceMappingURL=util.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvdXRpbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFLGVBQWUsbUJBQU8sQ0FBQyxzSUFBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3SUFBZTtBQUN2QyxjQUFjLG1CQUFPLENBQUMsb0lBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsMElBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RCw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEMsSUFBSTtBQUNKLDRCQUE0QixLQUFLLHVCQUF1QixJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvZnVqaWF3YW5nL0Rlc2t0b3AvY2hhdGJvdC9ub2RlX21vZHVsZXMvLnBucG0vQGFzYW11emFranArY3NzLWNvbG9yQDIuOC4zL25vZGVfbW9kdWxlcy9AYXNhbXV6YWtqcC9jc3MtY29sb3IvZGlzdC9janMvanMvdXRpbC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pO1xuY29uc3QgY29tbW9uID0gcmVxdWlyZShcIi4vY29tbW9uLmNqc1wiKTtcbmNvbnN0IHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmNqc1wiKTtcbmNvbnN0IGNvbG9yID0gcmVxdWlyZShcIi4vY29sb3IuY2pzXCIpO1xuY29uc3QgY29uc3RhbnQgPSByZXF1aXJlKFwiLi9jb25zdGFudC5janNcIik7XG5jb25zdCBERUMgPSAxMDtcbmNvbnN0IEhFWCA9IDE2O1xuY29uc3QgREVHID0gMzYwO1xuY29uc3QgREVHX0hBTEYgPSAxODA7XG5jb25zdCBSRUdfQ09MT1IgPSBuZXcgUmVnRXhwKGBeKD86JHtjb25zdGFudC5TWU5fQ09MT1JfVFlQRX0pJGApO1xuY29uc3QgUkVHX01JWCA9IG5ldyBSZWdFeHAoYCR7Y29uc3RhbnQuU1lOX01JWH1gKTtcbmNvbnN0IGlzQ29sb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKGNvbW1vbi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKC9eW2Etel0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKC9eKD86Y3VycmVudGNvbG9yfHRyYW5zcGFyZW50KSQvLnRlc3QodmFsdWUpIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb2xvci5OQU1FRF9DT0xPUlMsIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFJFR19DT0xPUi50ZXN0KHZhbHVlKSB8fCBSRUdfTUlYLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmUucmVzb2x2ZSh2YWx1ZSwge1xuICAgICAgICAgIGZvcm1hdDogY29uc3RhbnQuVkFMX1NQRUNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgdmFsdWVUb0pzb25TdHJpbmcgPSAodmFsdWUsIGZ1bmMgPSBmYWxzZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgcmVzID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChfa2V5LCB2YWwpID0+IHtcbiAgICBsZXQgcmVwbGFjZWRWYWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmVwbGFjZWRWYWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHJlcGxhY2VkVmFsdWUgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VkVmFsdWUgPSB2YWwubmFtZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCB8fCB2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIHJlcGxhY2VkVmFsdWUgPSBbLi4udmFsXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHJlcGxhY2VkVmFsdWUgPSB2YWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZWRWYWx1ZSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VkVmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IHJvdW5kVG9QcmVjaXNpb24gPSAodmFsdWUsIGJpdCA9IDApID0+IHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGJpdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2JpdH0gaXMgbm90IGEgbnVtYmVyLmApO1xuICB9IGVsc2UgaWYgKGJpdCA8IDAgfHwgYml0ID4gSEVYKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7Yml0fSBpcyBub3QgYmV0d2VlbiAwIGFuZCAke0hFWH0uYCk7XG4gIH1cbiAgaWYgKGJpdCA9PT0gMCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgfVxuICBsZXQgdmFsO1xuICBpZiAoYml0ID09PSBIRVgpIHtcbiAgICB2YWwgPSB2YWx1ZS50b1ByZWNpc2lvbig2KTtcbiAgfSBlbHNlIGlmIChiaXQgPCBERUMpIHtcbiAgICB2YWwgPSB2YWx1ZS50b1ByZWNpc2lvbig0KTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB2YWx1ZS50b1ByZWNpc2lvbig1KTtcbiAgfVxuICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xufTtcbmNvbnN0IGludGVycG9sYXRlSHVlID0gKGh1ZUEsIGh1ZUIsIGFyYyA9IFwic2hvcnRlclwiKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGh1ZUEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtodWVBfSBpcyBub3QgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaHVlQikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2h1ZUJ9IGlzIG5vdCBhIG51bWJlci5gKTtcbiAgfVxuICBzd2l0Y2ggKGFyYykge1xuICAgIGNhc2UgXCJkZWNyZWFzaW5nXCI6IHtcbiAgICAgIGlmIChodWVCID4gaHVlQSkge1xuICAgICAgICBodWVBICs9IERFRztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5jcmVhc2luZ1wiOiB7XG4gICAgICBpZiAoaHVlQiA8IGh1ZUEpIHtcbiAgICAgICAgaHVlQiArPSBERUc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxvbmdlclwiOiB7XG4gICAgICBpZiAoaHVlQiA+IGh1ZUEgJiYgaHVlQiA8IGh1ZUEgKyBERUdfSEFMRikge1xuICAgICAgICBodWVBICs9IERFRztcbiAgICAgIH0gZWxzZSBpZiAoaHVlQiA+IGh1ZUEgKyBERUdfSEFMRiAqIC0xICYmIGh1ZUIgPD0gaHVlQSkge1xuICAgICAgICBodWVCICs9IERFRztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2hvcnRlclwiOlxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChodWVCID4gaHVlQSArIERFR19IQUxGKSB7XG4gICAgICAgIGh1ZUEgKz0gREVHO1xuICAgICAgfSBlbHNlIGlmIChodWVCIDwgaHVlQSArIERFR19IQUxGICogLTEpIHtcbiAgICAgICAgaHVlQiArPSBERUc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbaHVlQSwgaHVlQl07XG59O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUh1ZSA9IGludGVycG9sYXRlSHVlO1xuZXhwb3J0cy5pc0NvbG9yID0gaXNDb2xvcjtcbmV4cG9ydHMucm91bmRUb1ByZWNpc2lvbiA9IHJvdW5kVG9QcmVjaXNpb247XG5leHBvcnRzLnZhbHVlVG9Kc29uU3RyaW5nID0gdmFsdWVUb0pzb25TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@asamuzakjp+css-color@2.8.3/node_modules/@asamuzakjp/css-color/dist/cjs/js/util.cjs\n");

/***/ })

};
;