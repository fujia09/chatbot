"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pythnetwork+price-service-sdk@1.8.0";
exports.ids = ["vendor-chunks/@pythnetwork+price-service-sdk@1.8.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAccumulatorUpdateData = exports.sliceAccumulatorUpdateData = exports.parseTwapMessage = exports.parsePriceFeedMessage = exports.isAccumulatorUpdateData = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst ACCUMULATOR_MAGIC = \"504e4155\";\nconst MAJOR_VERSION = 1;\nconst MINOR_VERSION = 0;\nconst KECCAK160_HASH_SIZE = 20;\nconst PRICE_FEED_MESSAGE_VARIANT = 0;\nconst TWAP_MESSAGE_VARIANT = 1;\nfunction isAccumulatorUpdateData(updateBytes) {\n    return (updateBytes.toString(\"hex\").slice(0, 8) === ACCUMULATOR_MAGIC &&\n        updateBytes[4] === MAJOR_VERSION &&\n        updateBytes[5] === MINOR_VERSION);\n}\nexports.isAccumulatorUpdateData = isAccumulatorUpdateData;\nfunction parsePriceFeedMessage(message) {\n    let cursor = 0;\n    const variant = message.readUInt8(cursor);\n    if (variant !== PRICE_FEED_MESSAGE_VARIANT) {\n        throw new Error(\"Not a price feed message\");\n    }\n    cursor += 1;\n    const feedId = message.subarray(cursor, cursor + 32);\n    cursor += 32;\n    const price = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const confidence = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const exponent = message.readInt32BE(cursor);\n    cursor += 4;\n    const publishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const prevPublishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const emaPrice = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const emaConf = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    return {\n        feedId,\n        price,\n        confidence,\n        exponent,\n        publishTime,\n        prevPublishTime,\n        emaPrice,\n        emaConf,\n    };\n}\nexports.parsePriceFeedMessage = parsePriceFeedMessage;\nfunction parseTwapMessage(message) {\n    let cursor = 0;\n    const variant = message.readUInt8(cursor);\n    if (variant !== TWAP_MESSAGE_VARIANT) {\n        throw new Error(\"Not a twap message\");\n    }\n    cursor += 1;\n    const feedId = message.subarray(cursor, cursor + 32);\n    cursor += 32;\n    const cumulativePrice = new bn_js_1.default(message.subarray(cursor, cursor + 16), \"be\");\n    cursor += 16;\n    const cumulativeConf = new bn_js_1.default(message.subarray(cursor, cursor + 16), \"be\");\n    cursor += 16;\n    const numDownSlots = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const exponent = message.readInt32BE(cursor);\n    cursor += 4;\n    const publishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const prevPublishTime = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    const publishSlot = new bn_js_1.default(message.subarray(cursor, cursor + 8), \"be\");\n    cursor += 8;\n    return {\n        feedId,\n        cumulativePrice,\n        cumulativeConf,\n        numDownSlots,\n        exponent,\n        publishTime,\n        prevPublishTime,\n        publishSlot,\n    };\n}\nexports.parseTwapMessage = parseTwapMessage;\n/**\n * An AccumulatorUpdateData contains a VAA and a list of updates. This function returns a new serialized AccumulatorUpdateData with only the updates in the range [start, end).\n */\nfunction sliceAccumulatorUpdateData(data, start, end) {\n    if (!isAccumulatorUpdateData(data)) {\n        throw new Error(\"Invalid accumulator message\");\n    }\n    let cursor = 6;\n    const trailingPayloadSize = data.readUint8(cursor);\n    cursor += 1 + trailingPayloadSize;\n    // const proofType = data.readUint8(cursor);\n    cursor += 1;\n    const vaaSize = data.readUint16BE(cursor);\n    cursor += 2;\n    cursor += vaaSize;\n    const endOfVaa = cursor;\n    const updates = [];\n    const numUpdates = data.readUInt8(cursor);\n    cursor += 1;\n    for (let i = 0; i < numUpdates; i++) {\n        const updateStart = cursor;\n        const messageSize = data.readUint16BE(cursor);\n        cursor += 2;\n        cursor += messageSize;\n        const numProofs = data.readUInt8(cursor);\n        cursor += 1;\n        cursor += KECCAK160_HASH_SIZE * numProofs;\n        updates.push(data.subarray(updateStart, cursor));\n    }\n    if (cursor !== data.length) {\n        throw new Error(\"Didn't reach the end of the message\");\n    }\n    const sliceUpdates = updates.slice(start, end);\n    return Buffer.concat([\n        data.subarray(0, endOfVaa),\n        Buffer.from([sliceUpdates.length]),\n        ...updates.slice(start, end),\n    ]);\n}\nexports.sliceAccumulatorUpdateData = sliceAccumulatorUpdateData;\nfunction parseAccumulatorUpdateData(data) {\n    if (!isAccumulatorUpdateData(data)) {\n        throw new Error(\"Invalid accumulator message\");\n    }\n    let cursor = 6;\n    const trailingPayloadSize = data.readUint8(cursor);\n    cursor += 1 + trailingPayloadSize;\n    // const proofType = data.readUint8(cursor);\n    cursor += 1;\n    const vaaSize = data.readUint16BE(cursor);\n    cursor += 2;\n    const vaa = data.subarray(cursor, cursor + vaaSize);\n    cursor += vaaSize;\n    const numUpdates = data.readUInt8(cursor);\n    const updates = [];\n    cursor += 1;\n    for (let i = 0; i < numUpdates; i++) {\n        const messageSize = data.readUint16BE(cursor);\n        cursor += 2;\n        const message = data.subarray(cursor, cursor + messageSize);\n        cursor += messageSize;\n        const numProofs = data.readUInt8(cursor);\n        cursor += 1;\n        const proof = [];\n        for (let j = 0; j < numProofs; j++) {\n            proof.push(Array.from(data.subarray(cursor, cursor + KECCAK160_HASH_SIZE)));\n            cursor += KECCAK160_HASH_SIZE;\n        }\n        updates.push({ message, proof });\n    }\n    if (cursor !== data.length) {\n        throw new Error(\"Didn't reach the end of the message\");\n    }\n    return { vaa, updates };\n}\nexports.parseAccumulatorUpdateData = parseAccumulatorUpdateData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHB5dGhuZXR3b3JrK3ByaWNlLXNlcnZpY2Utc2RrQDEuOC4wL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvcHJpY2Utc2VydmljZS1zZGsvbGliL0FjY3VtdWxhdG9yVXBkYXRlRGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLHdCQUF3QixHQUFHLDZCQUE2QixHQUFHLCtCQUErQjtBQUNwSyxnQ0FBZ0MsbUJBQU8sQ0FBQyxrRkFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0NBQWtDIiwic291cmNlcyI6WyIvVXNlcnMvZnVqaWF3YW5nL0Rlc2t0b3AvY2hhdGJvdC9ub2RlX21vZHVsZXMvLnBucG0vQHB5dGhuZXR3b3JrK3ByaWNlLXNlcnZpY2Utc2RrQDEuOC4wL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvcHJpY2Utc2VydmljZS1zZGsvbGliL0FjY3VtdWxhdG9yVXBkYXRlRGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VBY2N1bXVsYXRvclVwZGF0ZURhdGEgPSBleHBvcnRzLnNsaWNlQWNjdW11bGF0b3JVcGRhdGVEYXRhID0gZXhwb3J0cy5wYXJzZVR3YXBNZXNzYWdlID0gZXhwb3J0cy5wYXJzZVByaWNlRmVlZE1lc3NhZ2UgPSBleHBvcnRzLmlzQWNjdW11bGF0b3JVcGRhdGVEYXRhID0gdm9pZCAwO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgQUNDVU1VTEFUT1JfTUFHSUMgPSBcIjUwNGU0MTU1XCI7XG5jb25zdCBNQUpPUl9WRVJTSU9OID0gMTtcbmNvbnN0IE1JTk9SX1ZFUlNJT04gPSAwO1xuY29uc3QgS0VDQ0FLMTYwX0hBU0hfU0laRSA9IDIwO1xuY29uc3QgUFJJQ0VfRkVFRF9NRVNTQUdFX1ZBUklBTlQgPSAwO1xuY29uc3QgVFdBUF9NRVNTQUdFX1ZBUklBTlQgPSAxO1xuZnVuY3Rpb24gaXNBY2N1bXVsYXRvclVwZGF0ZURhdGEodXBkYXRlQnl0ZXMpIHtcbiAgICByZXR1cm4gKHVwZGF0ZUJ5dGVzLnRvU3RyaW5nKFwiaGV4XCIpLnNsaWNlKDAsIDgpID09PSBBQ0NVTVVMQVRPUl9NQUdJQyAmJlxuICAgICAgICB1cGRhdGVCeXRlc1s0XSA9PT0gTUFKT1JfVkVSU0lPTiAmJlxuICAgICAgICB1cGRhdGVCeXRlc1s1XSA9PT0gTUlOT1JfVkVSU0lPTik7XG59XG5leHBvcnRzLmlzQWNjdW11bGF0b3JVcGRhdGVEYXRhID0gaXNBY2N1bXVsYXRvclVwZGF0ZURhdGE7XG5mdW5jdGlvbiBwYXJzZVByaWNlRmVlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGxldCBjdXJzb3IgPSAwO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBtZXNzYWdlLnJlYWRVSW50OChjdXJzb3IpO1xuICAgIGlmICh2YXJpYW50ICE9PSBQUklDRV9GRUVEX01FU1NBR0VfVkFSSUFOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBwcmljZSBmZWVkIG1lc3NhZ2VcIik7XG4gICAgfVxuICAgIGN1cnNvciArPSAxO1xuICAgIGNvbnN0IGZlZWRJZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoY3Vyc29yLCBjdXJzb3IgKyAzMik7XG4gICAgY3Vyc29yICs9IDMyO1xuICAgIGNvbnN0IHByaWNlID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgY29uc3QgY29uZmlkZW5jZSA9IG5ldyBibl9qc18xLmRlZmF1bHQobWVzc2FnZS5zdWJhcnJheShjdXJzb3IsIGN1cnNvciArIDgpLCBcImJlXCIpO1xuICAgIGN1cnNvciArPSA4O1xuICAgIGNvbnN0IGV4cG9uZW50ID0gbWVzc2FnZS5yZWFkSW50MzJCRShjdXJzb3IpO1xuICAgIGN1cnNvciArPSA0O1xuICAgIGNvbnN0IHB1Ymxpc2hUaW1lID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgY29uc3QgcHJldlB1Ymxpc2hUaW1lID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgY29uc3QgZW1hUHJpY2UgPSBuZXcgYm5fanNfMS5kZWZhdWx0KG1lc3NhZ2Uuc3ViYXJyYXkoY3Vyc29yLCBjdXJzb3IgKyA4KSwgXCJiZVwiKTtcbiAgICBjdXJzb3IgKz0gODtcbiAgICBjb25zdCBlbWFDb25mID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVlZElkLFxuICAgICAgICBwcmljZSxcbiAgICAgICAgY29uZmlkZW5jZSxcbiAgICAgICAgZXhwb25lbnQsXG4gICAgICAgIHB1Ymxpc2hUaW1lLFxuICAgICAgICBwcmV2UHVibGlzaFRpbWUsXG4gICAgICAgIGVtYVByaWNlLFxuICAgICAgICBlbWFDb25mLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlUHJpY2VGZWVkTWVzc2FnZSA9IHBhcnNlUHJpY2VGZWVkTWVzc2FnZTtcbmZ1bmN0aW9uIHBhcnNlVHdhcE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGxldCBjdXJzb3IgPSAwO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBtZXNzYWdlLnJlYWRVSW50OChjdXJzb3IpO1xuICAgIGlmICh2YXJpYW50ICE9PSBUV0FQX01FU1NBR0VfVkFSSUFOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB0d2FwIG1lc3NhZ2VcIik7XG4gICAgfVxuICAgIGN1cnNvciArPSAxO1xuICAgIGNvbnN0IGZlZWRJZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoY3Vyc29yLCBjdXJzb3IgKyAzMik7XG4gICAgY3Vyc29yICs9IDMyO1xuICAgIGNvbnN0IGN1bXVsYXRpdmVQcmljZSA9IG5ldyBibl9qc18xLmRlZmF1bHQobWVzc2FnZS5zdWJhcnJheShjdXJzb3IsIGN1cnNvciArIDE2KSwgXCJiZVwiKTtcbiAgICBjdXJzb3IgKz0gMTY7XG4gICAgY29uc3QgY3VtdWxhdGl2ZUNvbmYgPSBuZXcgYm5fanNfMS5kZWZhdWx0KG1lc3NhZ2Uuc3ViYXJyYXkoY3Vyc29yLCBjdXJzb3IgKyAxNiksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDE2O1xuICAgIGNvbnN0IG51bURvd25TbG90cyA9IG5ldyBibl9qc18xLmRlZmF1bHQobWVzc2FnZS5zdWJhcnJheShjdXJzb3IsIGN1cnNvciArIDgpLCBcImJlXCIpO1xuICAgIGN1cnNvciArPSA4O1xuICAgIGNvbnN0IGV4cG9uZW50ID0gbWVzc2FnZS5yZWFkSW50MzJCRShjdXJzb3IpO1xuICAgIGN1cnNvciArPSA0O1xuICAgIGNvbnN0IHB1Ymxpc2hUaW1lID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgY29uc3QgcHJldlB1Ymxpc2hUaW1lID0gbmV3IGJuX2pzXzEuZGVmYXVsdChtZXNzYWdlLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgOCksIFwiYmVcIik7XG4gICAgY3Vyc29yICs9IDg7XG4gICAgY29uc3QgcHVibGlzaFNsb3QgPSBuZXcgYm5fanNfMS5kZWZhdWx0KG1lc3NhZ2Uuc3ViYXJyYXkoY3Vyc29yLCBjdXJzb3IgKyA4KSwgXCJiZVwiKTtcbiAgICBjdXJzb3IgKz0gODtcbiAgICByZXR1cm4ge1xuICAgICAgICBmZWVkSWQsXG4gICAgICAgIGN1bXVsYXRpdmVQcmljZSxcbiAgICAgICAgY3VtdWxhdGl2ZUNvbmYsXG4gICAgICAgIG51bURvd25TbG90cyxcbiAgICAgICAgZXhwb25lbnQsXG4gICAgICAgIHB1Ymxpc2hUaW1lLFxuICAgICAgICBwcmV2UHVibGlzaFRpbWUsXG4gICAgICAgIHB1Ymxpc2hTbG90LFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlVHdhcE1lc3NhZ2UgPSBwYXJzZVR3YXBNZXNzYWdlO1xuLyoqXG4gKiBBbiBBY2N1bXVsYXRvclVwZGF0ZURhdGEgY29udGFpbnMgYSBWQUEgYW5kIGEgbGlzdCBvZiB1cGRhdGVzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc2VyaWFsaXplZCBBY2N1bXVsYXRvclVwZGF0ZURhdGEgd2l0aCBvbmx5IHRoZSB1cGRhdGVzIGluIHRoZSByYW5nZSBbc3RhcnQsIGVuZCkuXG4gKi9cbmZ1bmN0aW9uIHNsaWNlQWNjdW11bGF0b3JVcGRhdGVEYXRhKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIWlzQWNjdW11bGF0b3JVcGRhdGVEYXRhKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWNjdW11bGF0b3IgbWVzc2FnZVwiKTtcbiAgICB9XG4gICAgbGV0IGN1cnNvciA9IDY7XG4gICAgY29uc3QgdHJhaWxpbmdQYXlsb2FkU2l6ZSA9IGRhdGEucmVhZFVpbnQ4KGN1cnNvcik7XG4gICAgY3Vyc29yICs9IDEgKyB0cmFpbGluZ1BheWxvYWRTaXplO1xuICAgIC8vIGNvbnN0IHByb29mVHlwZSA9IGRhdGEucmVhZFVpbnQ4KGN1cnNvcik7XG4gICAgY3Vyc29yICs9IDE7XG4gICAgY29uc3QgdmFhU2l6ZSA9IGRhdGEucmVhZFVpbnQxNkJFKGN1cnNvcik7XG4gICAgY3Vyc29yICs9IDI7XG4gICAgY3Vyc29yICs9IHZhYVNpemU7XG4gICAgY29uc3QgZW5kT2ZWYWEgPSBjdXJzb3I7XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIGNvbnN0IG51bVVwZGF0ZXMgPSBkYXRhLnJlYWRVSW50OChjdXJzb3IpO1xuICAgIGN1cnNvciArPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVXBkYXRlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVN0YXJ0ID0gY3Vyc29yO1xuICAgICAgICBjb25zdCBtZXNzYWdlU2l6ZSA9IGRhdGEucmVhZFVpbnQxNkJFKGN1cnNvcik7XG4gICAgICAgIGN1cnNvciArPSAyO1xuICAgICAgICBjdXJzb3IgKz0gbWVzc2FnZVNpemU7XG4gICAgICAgIGNvbnN0IG51bVByb29mcyA9IGRhdGEucmVhZFVJbnQ4KGN1cnNvcik7XG4gICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICBjdXJzb3IgKz0gS0VDQ0FLMTYwX0hBU0hfU0laRSAqIG51bVByb29mcztcbiAgICAgICAgdXBkYXRlcy5wdXNoKGRhdGEuc3ViYXJyYXkodXBkYXRlU3RhcnQsIGN1cnNvcikpO1xuICAgIH1cbiAgICBpZiAoY3Vyc29yICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWRuJ3QgcmVhY2ggdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2VVcGRhdGVzID0gdXBkYXRlcy5zbGljZShzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGRhdGEuc3ViYXJyYXkoMCwgZW5kT2ZWYWEpLFxuICAgICAgICBCdWZmZXIuZnJvbShbc2xpY2VVcGRhdGVzLmxlbmd0aF0pLFxuICAgICAgICAuLi51cGRhdGVzLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgIF0pO1xufVxuZXhwb3J0cy5zbGljZUFjY3VtdWxhdG9yVXBkYXRlRGF0YSA9IHNsaWNlQWNjdW11bGF0b3JVcGRhdGVEYXRhO1xuZnVuY3Rpb24gcGFyc2VBY2N1bXVsYXRvclVwZGF0ZURhdGEoZGF0YSkge1xuICAgIGlmICghaXNBY2N1bXVsYXRvclVwZGF0ZURhdGEoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2N1bXVsYXRvciBtZXNzYWdlXCIpO1xuICAgIH1cbiAgICBsZXQgY3Vyc29yID0gNjtcbiAgICBjb25zdCB0cmFpbGluZ1BheWxvYWRTaXplID0gZGF0YS5yZWFkVWludDgoY3Vyc29yKTtcbiAgICBjdXJzb3IgKz0gMSArIHRyYWlsaW5nUGF5bG9hZFNpemU7XG4gICAgLy8gY29uc3QgcHJvb2ZUeXBlID0gZGF0YS5yZWFkVWludDgoY3Vyc29yKTtcbiAgICBjdXJzb3IgKz0gMTtcbiAgICBjb25zdCB2YWFTaXplID0gZGF0YS5yZWFkVWludDE2QkUoY3Vyc29yKTtcbiAgICBjdXJzb3IgKz0gMjtcbiAgICBjb25zdCB2YWEgPSBkYXRhLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgdmFhU2l6ZSk7XG4gICAgY3Vyc29yICs9IHZhYVNpemU7XG4gICAgY29uc3QgbnVtVXBkYXRlcyA9IGRhdGEucmVhZFVJbnQ4KGN1cnNvcik7XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIGN1cnNvciArPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVXBkYXRlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VTaXplID0gZGF0YS5yZWFkVWludDE2QkUoY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yICs9IDI7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkYXRhLnN1YmFycmF5KGN1cnNvciwgY3Vyc29yICsgbWVzc2FnZVNpemUpO1xuICAgICAgICBjdXJzb3IgKz0gbWVzc2FnZVNpemU7XG4gICAgICAgIGNvbnN0IG51bVByb29mcyA9IGRhdGEucmVhZFVJbnQ4KGN1cnNvcik7XG4gICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVByb29mczsgaisrKSB7XG4gICAgICAgICAgICBwcm9vZi5wdXNoKEFycmF5LmZyb20oZGF0YS5zdWJhcnJheShjdXJzb3IsIGN1cnNvciArIEtFQ0NBSzE2MF9IQVNIX1NJWkUpKSk7XG4gICAgICAgICAgICBjdXJzb3IgKz0gS0VDQ0FLMTYwX0hBU0hfU0laRTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVzLnB1c2goeyBtZXNzYWdlLCBwcm9vZiB9KTtcbiAgICB9XG4gICAgaWYgKGN1cnNvciAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkbid0IHJlYWNoIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHJldHVybiB7IHZhYSwgdXBkYXRlcyB9O1xufVxuZXhwb3J0cy5wYXJzZUFjY3VtdWxhdG9yVXBkYXRlRGF0YSA9IHBhcnNlQWNjdW11bGF0b3JVcGRhdGVEYXRhO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/index.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/index.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PriceFeed = exports.PriceFeedMetadata = exports.Price = exports.parseTwapMessage = exports.parsePriceFeedMessage = exports.parseAccumulatorUpdateData = exports.sliceAccumulatorUpdateData = exports.isAccumulatorUpdateData = void 0;\nconst PriceFeed_1 = __webpack_require__(/*! ./schemas/PriceFeed */ \"(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js\");\nvar AccumulatorUpdateData_1 = __webpack_require__(/*! ./AccumulatorUpdateData */ \"(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/AccumulatorUpdateData.js\");\nObject.defineProperty(exports, \"isAccumulatorUpdateData\", ({ enumerable: true, get: function () { return AccumulatorUpdateData_1.isAccumulatorUpdateData; } }));\nObject.defineProperty(exports, \"sliceAccumulatorUpdateData\", ({ enumerable: true, get: function () { return AccumulatorUpdateData_1.sliceAccumulatorUpdateData; } }));\nObject.defineProperty(exports, \"parseAccumulatorUpdateData\", ({ enumerable: true, get: function () { return AccumulatorUpdateData_1.parseAccumulatorUpdateData; } }));\nObject.defineProperty(exports, \"parsePriceFeedMessage\", ({ enumerable: true, get: function () { return AccumulatorUpdateData_1.parsePriceFeedMessage; } }));\nObject.defineProperty(exports, \"parseTwapMessage\", ({ enumerable: true, get: function () { return AccumulatorUpdateData_1.parseTwapMessage; } }));\n/**\n * A Pyth Price represented as `${price} ± ${conf} * 10^${expo}` published at `publishTime`.\n */\nclass Price {\n    conf;\n    expo;\n    price;\n    publishTime;\n    constructor(rawPrice) {\n        this.conf = rawPrice.conf;\n        this.expo = rawPrice.expo;\n        this.price = rawPrice.price;\n        this.publishTime = rawPrice.publishTime;\n    }\n    /**\n     * Get price as number. Warning: this conversion might result in an inaccurate number.\n     * We store price and confidence values in our Oracle at 64-bit precision, but the JavaScript\n     * number type can only represent numbers with 52-bit precision. So if a price or confidence\n     * is larger than 52-bits, the conversion will lose the most insignificant bits.\n     *\n     * @returns a floating point number representing the price\n     */\n    getPriceAsNumberUnchecked() {\n        return Number(this.price) * 10 ** this.expo;\n    }\n    /**\n     * Get price as number. Warning: this conversion might result in an inaccurate number.\n     * Explanation is the same as `priceAsNumberUnchecked()` documentation.\n     *\n     * @returns a floating point number representing the price\n     */\n    getConfAsNumberUnchecked() {\n        return Number(this.conf) * 10 ** this.expo;\n    }\n    static fromJson(json) {\n        const jsonPrice = PriceFeed_1.Convert.toPrice(json);\n        return new Price({\n            conf: jsonPrice.conf,\n            expo: jsonPrice.expo,\n            price: jsonPrice.price,\n            publishTime: jsonPrice.publish_time,\n        });\n    }\n    toJson() {\n        const jsonPrice = {\n            conf: this.conf,\n            expo: this.expo,\n            price: this.price,\n            publish_time: this.publishTime,\n        };\n        // this is done to avoid sending undefined values to the server\n        return PriceFeed_1.Convert.priceToJson(jsonPrice);\n    }\n}\nexports.Price = Price;\n/**\n * Metadata about the price\n *\n * Represents metadata of a price feed.\n */\nclass PriceFeedMetadata {\n    /**\n     * Attestation time of the price\n     */\n    attestationTime;\n    /**\n     * Chain of the emitter\n     */\n    emitterChain;\n    /**\n     * The time that the price service received the price\n     */\n    priceServiceReceiveTime;\n    /**\n     * Sequence number of the price\n     */\n    sequenceNumber;\n    /**\n     * Pythnet slot number of the price\n     */\n    slot;\n    /**\n     * The time that the previous price was published\n     */\n    prevPublishTime;\n    constructor(metadata) {\n        this.attestationTime = metadata.attestationTime;\n        this.emitterChain = metadata.emitterChain;\n        this.priceServiceReceiveTime = metadata.receiveTime;\n        this.sequenceNumber = metadata.sequenceNumber;\n        this.slot = metadata.slot;\n        this.prevPublishTime = metadata.prevPublishTime;\n    }\n    static fromJson(json) {\n        if (json === undefined) {\n            return undefined;\n        }\n        const jsonFeed = PriceFeed_1.Convert.toPriceFeedMetadata(json);\n        return new PriceFeedMetadata({\n            attestationTime: jsonFeed.attestation_time,\n            emitterChain: jsonFeed.emitter_chain,\n            receiveTime: jsonFeed.price_service_receive_time,\n            sequenceNumber: jsonFeed.sequence_number,\n            slot: jsonFeed.slot,\n            prevPublishTime: jsonFeed.prev_publish_time,\n        });\n    }\n    toJson() {\n        const jsonFeed = {\n            attestation_time: this.attestationTime,\n            emitter_chain: this.emitterChain,\n            price_service_receive_time: this.priceServiceReceiveTime,\n            sequence_number: this.sequenceNumber,\n            slot: this.slot,\n            prev_publish_time: this.prevPublishTime,\n        };\n        // this is done to avoid sending undefined values to the server\n        return PriceFeed_1.Convert.priceFeedMetadataToJson(jsonFeed);\n    }\n}\nexports.PriceFeedMetadata = PriceFeedMetadata;\n/**\n * Pyth Price Feed\n *\n * Represents a current aggregation price from pyth publisher feeds.\n */\nclass PriceFeed {\n    /**\n     * Exponentially-weighted moving average Price\n     */\n    emaPrice;\n    /**\n     * Unique identifier for this price.\n     */\n    id;\n    /**\n     * Metadata of the price\n     */\n    metadata;\n    /**\n     * VAA of the price\n     */\n    vaa;\n    /**\n     * Price\n     */\n    price;\n    constructor(rawFeed) {\n        this.emaPrice = rawFeed.emaPrice;\n        this.id = rawFeed.id;\n        this.metadata = rawFeed.metadata;\n        this.vaa = rawFeed.vaa;\n        this.price = rawFeed.price;\n    }\n    static fromJson(json) {\n        const jsonFeed = PriceFeed_1.Convert.toPriceFeed(json);\n        return new PriceFeed({\n            emaPrice: Price.fromJson(jsonFeed.ema_price),\n            id: jsonFeed.id,\n            metadata: PriceFeedMetadata.fromJson(jsonFeed.metadata),\n            vaa: jsonFeed.vaa,\n            price: Price.fromJson(jsonFeed.price),\n        });\n    }\n    toJson() {\n        const jsonFeed = {\n            ema_price: this.emaPrice.toJson(),\n            id: this.id,\n            metadata: this.metadata?.toJson(),\n            price: this.price.toJson(),\n        };\n        return PriceFeed_1.Convert.priceFeedToJson(jsonFeed);\n    }\n    /**\n     * Get the price and confidence interval as fixed-point numbers of the form a * 10^e.\n     * This function returns the current best estimate of the price at the time that this `PriceFeed` was\n     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function\n     * makes no guarantees that the returned price is recent or useful for any particular application.\n     *\n     * Users of this function should check the returned `publishTime` to ensure that the returned price is\n     * sufficiently recent for their application. If you are considering using this function, it may be\n     * safer / easier to use `getPriceNoOlderThan` method.\n     *\n     * @returns a Price that contains the price and confidence interval along with\n     * the exponent for them, and publish time of the price.\n     */\n    getPriceUnchecked() {\n        return this.price;\n    }\n    /**\n     * Get the exponentially-weighted moving average (EMA) price and confidence interval.\n     *\n     * This function returns the current best estimate of the price at the time that this `PriceFeed` was\n     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function\n     * makes no guarantees that the returned price is recent or useful for any particular application.\n     *\n     * Users of this function should check the returned `publishTime` to ensure that the returned price is\n     * sufficiently recent for their application. If you are considering using this function, it may be\n     * safer / easier to use `getEmaPriceNoOlderThan` method.\n     *\n     * At the moment, the confidence interval returned by this method is computed in\n     * a somewhat questionable way, so we do not recommend using it for high-value applications.\n     *\n     * @returns a Price that contains the EMA price and confidence interval along with\n     * the exponent for them, and publish time of the price.\n     */\n    getEmaPriceUnchecked() {\n        return this.emaPrice;\n    }\n    /**\n     * Get the price if it was updated no older than `age` seconds of the current time.\n     *\n     * This function is a sanity-checked version of `getPriceUnchecked` which is useful in\n     * applications that require a sufficiently-recent price. Returns `undefined` if the price\n     * is not recent enough.\n     *\n     * @param age return a price as long as it has been updated within this number of seconds\n     * @returns a Price struct containing the price, confidence interval along with the exponent for\n     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.\n     */\n    getPriceNoOlderThan(age) {\n        const price = this.getPriceUnchecked();\n        const currentTime = Math.floor(Date.now() / 1000);\n        // This checks the absolute difference as a sanity check\n        // for the cases that the system time is behind or price\n        // feed timestamp happen to be in the future (a bug).\n        if (Math.abs(currentTime - price.publishTime) > age) {\n            return undefined;\n        }\n        return price;\n    }\n    /**\n     * Get the exponentially-weighted moving average (EMA) price if it was updated no older than\n     * `age` seconds of the current time.\n     *\n     * This function is a sanity-checked version of `getEmaPriceUnchecked` which is useful in\n     * applications that require a sufficiently-recent price. Returns `undefined` if the price\n     * is not recent enough.\n     *\n     * At the moment, the confidence interval returned by this method is computed in\n     * a somewhat questionable way, so we do not recommend using it for high-value applications.\n     *\n     * @param age return a price as long as it has been updated within this number of seconds\n     * @returns a Price struct containing the EMA price, confidence interval along with the exponent for\n     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.\n     */\n    getEmaPriceNoOlderThan(age) {\n        const emaPrice = this.getEmaPriceUnchecked();\n        const currentTime = Math.floor(Date.now() / 1000);\n        // This checks the absolute difference as a sanity check\n        // for the cases that the system time is behind or price\n        // feed timestamp happen to be in the future (a bug).\n        if (Math.abs(currentTime - emaPrice.publishTime) > age) {\n            return undefined;\n        }\n        return emaPrice;\n    }\n    /**\n     * Get the price feed metadata.\n     *\n     * @returns a struct containing the attestation time, emitter chain, and the sequence number.\n     * Returns `undefined` if metadata is currently unavailable.\n     */\n    getMetadata() {\n        return this.metadata;\n    }\n    /**\n     * Get the price feed vaa.\n     *\n     * @returns vaa in base64.\n     * Returns `undefined` if vaa is unavailable.\n     */\n    getVAA() {\n        return this.vaa;\n    }\n}\nexports.PriceFeed = PriceFeed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHB5dGhuZXR3b3JrK3ByaWNlLXNlcnZpY2Utc2RrQDEuOC4wL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvcHJpY2Utc2VydmljZS1zZGsvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHlCQUF5QixHQUFHLGFBQWEsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0I7QUFDcE8sb0JBQW9CLG1CQUFPLENBQUMsaUtBQXFCO0FBQ2pELDhCQUE4QixtQkFBTyxDQUFDLHlLQUF5QjtBQUMvRCwyREFBMEQsRUFBRSxxQ0FBcUMsMkRBQTJELEVBQUM7QUFDN0osOERBQTZELEVBQUUscUNBQXFDLDhEQUE4RCxFQUFDO0FBQ25LLDhEQUE2RCxFQUFFLHFDQUFxQyw4REFBOEQsRUFBQztBQUNuSyx5REFBd0QsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDekosb0RBQW1ELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQy9JO0FBQ0Esa0NBQWtDLE9BQU8sSUFBSSxNQUFNLE9BQU8sS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvZnVqaWF3YW5nL0Rlc2t0b3AvY2hhdGJvdC9ub2RlX21vZHVsZXMvLnBucG0vQHB5dGhuZXR3b3JrK3ByaWNlLXNlcnZpY2Utc2RrQDEuOC4wL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvcHJpY2Utc2VydmljZS1zZGsvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmljZUZlZWQgPSBleHBvcnRzLlByaWNlRmVlZE1ldGFkYXRhID0gZXhwb3J0cy5QcmljZSA9IGV4cG9ydHMucGFyc2VUd2FwTWVzc2FnZSA9IGV4cG9ydHMucGFyc2VQcmljZUZlZWRNZXNzYWdlID0gZXhwb3J0cy5wYXJzZUFjY3VtdWxhdG9yVXBkYXRlRGF0YSA9IGV4cG9ydHMuc2xpY2VBY2N1bXVsYXRvclVwZGF0ZURhdGEgPSBleHBvcnRzLmlzQWNjdW11bGF0b3JVcGRhdGVEYXRhID0gdm9pZCAwO1xuY29uc3QgUHJpY2VGZWVkXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzL1ByaWNlRmVlZFwiKTtcbnZhciBBY2N1bXVsYXRvclVwZGF0ZURhdGFfMSA9IHJlcXVpcmUoXCIuL0FjY3VtdWxhdG9yVXBkYXRlRGF0YVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWNjdW11bGF0b3JVcGRhdGVEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBY2N1bXVsYXRvclVwZGF0ZURhdGFfMS5pc0FjY3VtdWxhdG9yVXBkYXRlRGF0YTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNsaWNlQWNjdW11bGF0b3JVcGRhdGVEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBY2N1bXVsYXRvclVwZGF0ZURhdGFfMS5zbGljZUFjY3VtdWxhdG9yVXBkYXRlRGF0YTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlQWNjdW11bGF0b3JVcGRhdGVEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBY2N1bXVsYXRvclVwZGF0ZURhdGFfMS5wYXJzZUFjY3VtdWxhdG9yVXBkYXRlRGF0YTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlUHJpY2VGZWVkTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQWNjdW11bGF0b3JVcGRhdGVEYXRhXzEucGFyc2VQcmljZUZlZWRNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VUd2FwTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQWNjdW11bGF0b3JVcGRhdGVEYXRhXzEucGFyc2VUd2FwTWVzc2FnZTsgfSB9KTtcbi8qKlxuICogQSBQeXRoIFByaWNlIHJlcHJlc2VudGVkIGFzIGAke3ByaWNlfSDCsSAke2NvbmZ9ICogMTBeJHtleHBvfWAgcHVibGlzaGVkIGF0IGBwdWJsaXNoVGltZWAuXG4gKi9cbmNsYXNzIFByaWNlIHtcbiAgICBjb25mO1xuICAgIGV4cG87XG4gICAgcHJpY2U7XG4gICAgcHVibGlzaFRpbWU7XG4gICAgY29uc3RydWN0b3IocmF3UHJpY2UpIHtcbiAgICAgICAgdGhpcy5jb25mID0gcmF3UHJpY2UuY29uZjtcbiAgICAgICAgdGhpcy5leHBvID0gcmF3UHJpY2UuZXhwbztcbiAgICAgICAgdGhpcy5wcmljZSA9IHJhd1ByaWNlLnByaWNlO1xuICAgICAgICB0aGlzLnB1Ymxpc2hUaW1lID0gcmF3UHJpY2UucHVibGlzaFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwcmljZSBhcyBudW1iZXIuIFdhcm5pbmc6IHRoaXMgY29udmVyc2lvbiBtaWdodCByZXN1bHQgaW4gYW4gaW5hY2N1cmF0ZSBudW1iZXIuXG4gICAgICogV2Ugc3RvcmUgcHJpY2UgYW5kIGNvbmZpZGVuY2UgdmFsdWVzIGluIG91ciBPcmFjbGUgYXQgNjQtYml0IHByZWNpc2lvbiwgYnV0IHRoZSBKYXZhU2NyaXB0XG4gICAgICogbnVtYmVyIHR5cGUgY2FuIG9ubHkgcmVwcmVzZW50IG51bWJlcnMgd2l0aCA1Mi1iaXQgcHJlY2lzaW9uLiBTbyBpZiBhIHByaWNlIG9yIGNvbmZpZGVuY2VcbiAgICAgKiBpcyBsYXJnZXIgdGhhbiA1Mi1iaXRzLCB0aGUgY29udmVyc2lvbiB3aWxsIGxvc2UgdGhlIG1vc3QgaW5zaWduaWZpY2FudCBiaXRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBwcmljZVxuICAgICAqL1xuICAgIGdldFByaWNlQXNOdW1iZXJVbmNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wcmljZSkgKiAxMCAqKiB0aGlzLmV4cG87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwcmljZSBhcyBudW1iZXIuIFdhcm5pbmc6IHRoaXMgY29udmVyc2lvbiBtaWdodCByZXN1bHQgaW4gYW4gaW5hY2N1cmF0ZSBudW1iZXIuXG4gICAgICogRXhwbGFuYXRpb24gaXMgdGhlIHNhbWUgYXMgYHByaWNlQXNOdW1iZXJVbmNoZWNrZWQoKWAgZG9jdW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcHJpY2VcbiAgICAgKi9cbiAgICBnZXRDb25mQXNOdW1iZXJVbmNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5jb25mKSAqIDEwICoqIHRoaXMuZXhwbztcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb24pIHtcbiAgICAgICAgY29uc3QganNvblByaWNlID0gUHJpY2VGZWVkXzEuQ29udmVydC50b1ByaWNlKGpzb24pO1xuICAgICAgICByZXR1cm4gbmV3IFByaWNlKHtcbiAgICAgICAgICAgIGNvbmY6IGpzb25QcmljZS5jb25mLFxuICAgICAgICAgICAgZXhwbzoganNvblByaWNlLmV4cG8sXG4gICAgICAgICAgICBwcmljZToganNvblByaWNlLnByaWNlLFxuICAgICAgICAgICAgcHVibGlzaFRpbWU6IGpzb25QcmljZS5wdWJsaXNoX3RpbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0pzb24oKSB7XG4gICAgICAgIGNvbnN0IGpzb25QcmljZSA9IHtcbiAgICAgICAgICAgIGNvbmY6IHRoaXMuY29uZixcbiAgICAgICAgICAgIGV4cG86IHRoaXMuZXhwbyxcbiAgICAgICAgICAgIHByaWNlOiB0aGlzLnByaWNlLFxuICAgICAgICAgICAgcHVibGlzaF90aW1lOiB0aGlzLnB1Ymxpc2hUaW1lLFxuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzIGlzIGRvbmUgdG8gYXZvaWQgc2VuZGluZyB1bmRlZmluZWQgdmFsdWVzIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgcmV0dXJuIFByaWNlRmVlZF8xLkNvbnZlcnQucHJpY2VUb0pzb24oanNvblByaWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlByaWNlID0gUHJpY2U7XG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IHRoZSBwcmljZVxuICpcbiAqIFJlcHJlc2VudHMgbWV0YWRhdGEgb2YgYSBwcmljZSBmZWVkLlxuICovXG5jbGFzcyBQcmljZUZlZWRNZXRhZGF0YSB7XG4gICAgLyoqXG4gICAgICogQXR0ZXN0YXRpb24gdGltZSBvZiB0aGUgcHJpY2VcbiAgICAgKi9cbiAgICBhdHRlc3RhdGlvblRpbWU7XG4gICAgLyoqXG4gICAgICogQ2hhaW4gb2YgdGhlIGVtaXR0ZXJcbiAgICAgKi9cbiAgICBlbWl0dGVyQ2hhaW47XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUgdGhhdCB0aGUgcHJpY2Ugc2VydmljZSByZWNlaXZlZCB0aGUgcHJpY2VcbiAgICAgKi9cbiAgICBwcmljZVNlcnZpY2VSZWNlaXZlVGltZTtcbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZSBudW1iZXIgb2YgdGhlIHByaWNlXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXI7XG4gICAgLyoqXG4gICAgICogUHl0aG5ldCBzbG90IG51bWJlciBvZiB0aGUgcHJpY2VcbiAgICAgKi9cbiAgICBzbG90O1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIHByZXZpb3VzIHByaWNlIHdhcyBwdWJsaXNoZWRcbiAgICAgKi9cbiAgICBwcmV2UHVibGlzaFRpbWU7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5hdHRlc3RhdGlvblRpbWUgPSBtZXRhZGF0YS5hdHRlc3RhdGlvblRpbWU7XG4gICAgICAgIHRoaXMuZW1pdHRlckNoYWluID0gbWV0YWRhdGEuZW1pdHRlckNoYWluO1xuICAgICAgICB0aGlzLnByaWNlU2VydmljZVJlY2VpdmVUaW1lID0gbWV0YWRhdGEucmVjZWl2ZVRpbWU7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBtZXRhZGF0YS5zZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgdGhpcy5zbG90ID0gbWV0YWRhdGEuc2xvdDtcbiAgICAgICAgdGhpcy5wcmV2UHVibGlzaFRpbWUgPSBtZXRhZGF0YS5wcmV2UHVibGlzaFRpbWU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uKSB7XG4gICAgICAgIGlmIChqc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbkZlZWQgPSBQcmljZUZlZWRfMS5Db252ZXJ0LnRvUHJpY2VGZWVkTWV0YWRhdGEoanNvbik7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VGZWVkTWV0YWRhdGEoe1xuICAgICAgICAgICAgYXR0ZXN0YXRpb25UaW1lOiBqc29uRmVlZC5hdHRlc3RhdGlvbl90aW1lLFxuICAgICAgICAgICAgZW1pdHRlckNoYWluOiBqc29uRmVlZC5lbWl0dGVyX2NoYWluLFxuICAgICAgICAgICAgcmVjZWl2ZVRpbWU6IGpzb25GZWVkLnByaWNlX3NlcnZpY2VfcmVjZWl2ZV90aW1lLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IGpzb25GZWVkLnNlcXVlbmNlX251bWJlcixcbiAgICAgICAgICAgIHNsb3Q6IGpzb25GZWVkLnNsb3QsXG4gICAgICAgICAgICBwcmV2UHVibGlzaFRpbWU6IGpzb25GZWVkLnByZXZfcHVibGlzaF90aW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCBqc29uRmVlZCA9IHtcbiAgICAgICAgICAgIGF0dGVzdGF0aW9uX3RpbWU6IHRoaXMuYXR0ZXN0YXRpb25UaW1lLFxuICAgICAgICAgICAgZW1pdHRlcl9jaGFpbjogdGhpcy5lbWl0dGVyQ2hhaW4sXG4gICAgICAgICAgICBwcmljZV9zZXJ2aWNlX3JlY2VpdmVfdGltZTogdGhpcy5wcmljZVNlcnZpY2VSZWNlaXZlVGltZSxcbiAgICAgICAgICAgIHNlcXVlbmNlX251bWJlcjogdGhpcy5zZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIHNsb3Q6IHRoaXMuc2xvdCxcbiAgICAgICAgICAgIHByZXZfcHVibGlzaF90aW1lOiB0aGlzLnByZXZQdWJsaXNoVGltZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdGhpcyBpcyBkb25lIHRvIGF2b2lkIHNlbmRpbmcgdW5kZWZpbmVkIHZhbHVlcyB0byB0aGUgc2VydmVyXG4gICAgICAgIHJldHVybiBQcmljZUZlZWRfMS5Db252ZXJ0LnByaWNlRmVlZE1ldGFkYXRhVG9Kc29uKGpzb25GZWVkKTtcbiAgICB9XG59XG5leHBvcnRzLlByaWNlRmVlZE1ldGFkYXRhID0gUHJpY2VGZWVkTWV0YWRhdGE7XG4vKipcbiAqIFB5dGggUHJpY2UgRmVlZFxuICpcbiAqIFJlcHJlc2VudHMgYSBjdXJyZW50IGFnZ3JlZ2F0aW9uIHByaWNlIGZyb20gcHl0aCBwdWJsaXNoZXIgZmVlZHMuXG4gKi9cbmNsYXNzIFByaWNlRmVlZCB7XG4gICAgLyoqXG4gICAgICogRXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZSBQcmljZVxuICAgICAqL1xuICAgIGVtYVByaWNlO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHByaWNlLlxuICAgICAqL1xuICAgIGlkO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIG9mIHRoZSBwcmljZVxuICAgICAqL1xuICAgIG1ldGFkYXRhO1xuICAgIC8qKlxuICAgICAqIFZBQSBvZiB0aGUgcHJpY2VcbiAgICAgKi9cbiAgICB2YWE7XG4gICAgLyoqXG4gICAgICogUHJpY2VcbiAgICAgKi9cbiAgICBwcmljZTtcbiAgICBjb25zdHJ1Y3RvcihyYXdGZWVkKSB7XG4gICAgICAgIHRoaXMuZW1hUHJpY2UgPSByYXdGZWVkLmVtYVByaWNlO1xuICAgICAgICB0aGlzLmlkID0gcmF3RmVlZC5pZDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHJhd0ZlZWQubWV0YWRhdGE7XG4gICAgICAgIHRoaXMudmFhID0gcmF3RmVlZC52YWE7XG4gICAgICAgIHRoaXMucHJpY2UgPSByYXdGZWVkLnByaWNlO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvbikge1xuICAgICAgICBjb25zdCBqc29uRmVlZCA9IFByaWNlRmVlZF8xLkNvbnZlcnQudG9QcmljZUZlZWQoanNvbik7XG4gICAgICAgIHJldHVybiBuZXcgUHJpY2VGZWVkKHtcbiAgICAgICAgICAgIGVtYVByaWNlOiBQcmljZS5mcm9tSnNvbihqc29uRmVlZC5lbWFfcHJpY2UpLFxuICAgICAgICAgICAgaWQ6IGpzb25GZWVkLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IFByaWNlRmVlZE1ldGFkYXRhLmZyb21Kc29uKGpzb25GZWVkLm1ldGFkYXRhKSxcbiAgICAgICAgICAgIHZhYToganNvbkZlZWQudmFhLFxuICAgICAgICAgICAgcHJpY2U6IFByaWNlLmZyb21Kc29uKGpzb25GZWVkLnByaWNlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QganNvbkZlZWQgPSB7XG4gICAgICAgICAgICBlbWFfcHJpY2U6IHRoaXMuZW1hUHJpY2UudG9Kc29uKCksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhPy50b0pzb24oKSxcbiAgICAgICAgICAgIHByaWNlOiB0aGlzLnByaWNlLnRvSnNvbigpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJpY2VGZWVkXzEuQ29udmVydC5wcmljZUZlZWRUb0pzb24oanNvbkZlZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByaWNlIGFuZCBjb25maWRlbmNlIGludGVydmFsIGFzIGZpeGVkLXBvaW50IG51bWJlcnMgb2YgdGhlIGZvcm0gYSAqIDEwXmUuXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXJyZW50IGJlc3QgZXN0aW1hdGUgb2YgdGhlIHByaWNlIGF0IHRoZSB0aW1lIHRoYXQgdGhpcyBgUHJpY2VGZWVkYCB3YXNcbiAgICAgKiBwdWJsaXNoZWQgKGBwdWJsaXNoVGltZWApLiBUaGUgcmV0dXJuZWQgcHJpY2UgY2FuIGJlIGZyb20gYXJiaXRyYXJpbHkgZmFyIGluIHRoZSBwYXN0OyB0aGlzIGZ1bmN0aW9uXG4gICAgICogbWFrZXMgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSByZXR1cm5lZCBwcmljZSBpcyByZWNlbnQgb3IgdXNlZnVsIGZvciBhbnkgcGFydGljdWxhciBhcHBsaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGNoZWNrIHRoZSByZXR1cm5lZCBgcHVibGlzaFRpbWVgIHRvIGVuc3VyZSB0aGF0IHRoZSByZXR1cm5lZCBwcmljZSBpc1xuICAgICAqIHN1ZmZpY2llbnRseSByZWNlbnQgZm9yIHRoZWlyIGFwcGxpY2F0aW9uLiBJZiB5b3UgYXJlIGNvbnNpZGVyaW5nIHVzaW5nIHRoaXMgZnVuY3Rpb24sIGl0IG1heSBiZVxuICAgICAqIHNhZmVyIC8gZWFzaWVyIHRvIHVzZSBgZ2V0UHJpY2VOb09sZGVyVGhhbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBQcmljZSB0aGF0IGNvbnRhaW5zIHRoZSBwcmljZSBhbmQgY29uZmlkZW5jZSBpbnRlcnZhbCBhbG9uZyB3aXRoXG4gICAgICogdGhlIGV4cG9uZW50IGZvciB0aGVtLCBhbmQgcHVibGlzaCB0aW1lIG9mIHRoZSBwcmljZS5cbiAgICAgKi9cbiAgICBnZXRQcmljZVVuY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZSAoRU1BKSBwcmljZSBhbmQgY29uZmlkZW5jZSBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VycmVudCBiZXN0IGVzdGltYXRlIG9mIHRoZSBwcmljZSBhdCB0aGUgdGltZSB0aGF0IHRoaXMgYFByaWNlRmVlZGAgd2FzXG4gICAgICogcHVibGlzaGVkIChgcHVibGlzaFRpbWVgKS4gVGhlIHJldHVybmVkIHByaWNlIGNhbiBiZSBmcm9tIGFyYml0cmFyaWx5IGZhciBpbiB0aGUgcGFzdDsgdGhpcyBmdW5jdGlvblxuICAgICAqIG1ha2VzIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgcmV0dXJuZWQgcHJpY2UgaXMgcmVjZW50IG9yIHVzZWZ1bCBmb3IgYW55IHBhcnRpY3VsYXIgYXBwbGljYXRpb24uXG4gICAgICpcbiAgICAgKiBVc2VycyBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjaGVjayB0aGUgcmV0dXJuZWQgYHB1Ymxpc2hUaW1lYCB0byBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgcHJpY2UgaXNcbiAgICAgKiBzdWZmaWNpZW50bHkgcmVjZW50IGZvciB0aGVpciBhcHBsaWNhdGlvbi4gSWYgeW91IGFyZSBjb25zaWRlcmluZyB1c2luZyB0aGlzIGZ1bmN0aW9uLCBpdCBtYXkgYmVcbiAgICAgKiBzYWZlciAvIGVhc2llciB0byB1c2UgYGdldEVtYVByaWNlTm9PbGRlclRoYW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEF0IHRoZSBtb21lbnQsIHRoZSBjb25maWRlbmNlIGludGVydmFsIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGlzIGNvbXB1dGVkIGluXG4gICAgICogYSBzb21ld2hhdCBxdWVzdGlvbmFibGUgd2F5LCBzbyB3ZSBkbyBub3QgcmVjb21tZW5kIHVzaW5nIGl0IGZvciBoaWdoLXZhbHVlIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgUHJpY2UgdGhhdCBjb250YWlucyB0aGUgRU1BIHByaWNlIGFuZCBjb25maWRlbmNlIGludGVydmFsIGFsb25nIHdpdGhcbiAgICAgKiB0aGUgZXhwb25lbnQgZm9yIHRoZW0sIGFuZCBwdWJsaXNoIHRpbWUgb2YgdGhlIHByaWNlLlxuICAgICAqL1xuICAgIGdldEVtYVByaWNlVW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWFQcmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmljZSBpZiBpdCB3YXMgdXBkYXRlZCBubyBvbGRlciB0aGFuIGBhZ2VgIHNlY29uZHMgb2YgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYSBzYW5pdHktY2hlY2tlZCB2ZXJzaW9uIG9mIGBnZXRQcmljZVVuY2hlY2tlZGAgd2hpY2ggaXMgdXNlZnVsIGluXG4gICAgICogYXBwbGljYXRpb25zIHRoYXQgcmVxdWlyZSBhIHN1ZmZpY2llbnRseS1yZWNlbnQgcHJpY2UuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHByaWNlXG4gICAgICogaXMgbm90IHJlY2VudCBlbm91Z2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlIHJldHVybiBhIHByaWNlIGFzIGxvbmcgYXMgaXQgaGFzIGJlZW4gdXBkYXRlZCB3aXRoaW4gdGhpcyBudW1iZXIgb2Ygc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIGEgUHJpY2Ugc3RydWN0IGNvbnRhaW5pbmcgdGhlIHByaWNlLCBjb25maWRlbmNlIGludGVydmFsIGFsb25nIHdpdGggdGhlIGV4cG9uZW50IGZvclxuICAgICAqIGJvdGggbnVtYmVycywgYW5kIGl0cyBwdWJsaXNoIHRpbWUsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHByaWNlIHVwZGF0ZSBvY2N1cnJlZCB3aXRoaW4gYGFnZWAgc2Vjb25kcyBvZiB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqL1xuICAgIGdldFByaWNlTm9PbGRlclRoYW4oYWdlKSB7XG4gICAgICAgIGNvbnN0IHByaWNlID0gdGhpcy5nZXRQcmljZVVuY2hlY2tlZCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAvLyBUaGlzIGNoZWNrcyB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBhcyBhIHNhbml0eSBjaGVja1xuICAgICAgICAvLyBmb3IgdGhlIGNhc2VzIHRoYXQgdGhlIHN5c3RlbSB0aW1lIGlzIGJlaGluZCBvciBwcmljZVxuICAgICAgICAvLyBmZWVkIHRpbWVzdGFtcCBoYXBwZW4gdG8gYmUgaW4gdGhlIGZ1dHVyZSAoYSBidWcpLlxuICAgICAgICBpZiAoTWF0aC5hYnMoY3VycmVudFRpbWUgLSBwcmljZS5wdWJsaXNoVGltZSkgPiBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2UgKEVNQSkgcHJpY2UgaWYgaXQgd2FzIHVwZGF0ZWQgbm8gb2xkZXIgdGhhblxuICAgICAqIGBhZ2VgIHNlY29uZHMgb2YgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYSBzYW5pdHktY2hlY2tlZCB2ZXJzaW9uIG9mIGBnZXRFbWFQcmljZVVuY2hlY2tlZGAgd2hpY2ggaXMgdXNlZnVsIGluXG4gICAgICogYXBwbGljYXRpb25zIHRoYXQgcmVxdWlyZSBhIHN1ZmZpY2llbnRseS1yZWNlbnQgcHJpY2UuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHByaWNlXG4gICAgICogaXMgbm90IHJlY2VudCBlbm91Z2guXG4gICAgICpcbiAgICAgKiBBdCB0aGUgbW9tZW50LCB0aGUgY29uZmlkZW5jZSBpbnRlcnZhbCByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBpcyBjb21wdXRlZCBpblxuICAgICAqIGEgc29tZXdoYXQgcXVlc3Rpb25hYmxlIHdheSwgc28gd2UgZG8gbm90IHJlY29tbWVuZCB1c2luZyBpdCBmb3IgaGlnaC12YWx1ZSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlIHJldHVybiBhIHByaWNlIGFzIGxvbmcgYXMgaXQgaGFzIGJlZW4gdXBkYXRlZCB3aXRoaW4gdGhpcyBudW1iZXIgb2Ygc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIGEgUHJpY2Ugc3RydWN0IGNvbnRhaW5pbmcgdGhlIEVNQSBwcmljZSwgY29uZmlkZW5jZSBpbnRlcnZhbCBhbG9uZyB3aXRoIHRoZSBleHBvbmVudCBmb3JcbiAgICAgKiBib3RoIG51bWJlcnMsIGFuZCBpdHMgcHVibGlzaCB0aW1lLCBvciBgdW5kZWZpbmVkYCBpZiBubyBwcmljZSB1cGRhdGUgb2NjdXJyZWQgd2l0aGluIGBhZ2VgIHNlY29uZHMgb2YgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKi9cbiAgICBnZXRFbWFQcmljZU5vT2xkZXJUaGFuKGFnZSkge1xuICAgICAgICBjb25zdCBlbWFQcmljZSA9IHRoaXMuZ2V0RW1hUHJpY2VVbmNoZWNrZWQoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgLy8gVGhpcyBjaGVja3MgdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYXMgYSBzYW5pdHkgY2hlY2tcbiAgICAgICAgLy8gZm9yIHRoZSBjYXNlcyB0aGF0IHRoZSBzeXN0ZW0gdGltZSBpcyBiZWhpbmQgb3IgcHJpY2VcbiAgICAgICAgLy8gZmVlZCB0aW1lc3RhbXAgaGFwcGVuIHRvIGJlIGluIHRoZSBmdXR1cmUgKGEgYnVnKS5cbiAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gZW1hUHJpY2UucHVibGlzaFRpbWUpID4gYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbWFQcmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwcmljZSBmZWVkIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBzdHJ1Y3QgY29udGFpbmluZyB0aGUgYXR0ZXN0YXRpb24gdGltZSwgZW1pdHRlciBjaGFpbiwgYW5kIHRoZSBzZXF1ZW5jZSBudW1iZXIuXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBtZXRhZGF0YSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByaWNlIGZlZWQgdmFhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdmFhIGluIGJhc2U2NC5cbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHZhYSBpcyB1bmF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRWQUEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhYTtcbiAgICB9XG59XG5leHBvcnRzLlByaWNlRmVlZCA9IFByaWNlRmVlZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// To parse this data:\n//\n//   import { Convert, PriceFeed } from \"./file\";\n//\n//   const priceFeed = Convert.toPriceFeed(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Convert = void 0;\n// Converts JSON types to/from your types\n// and asserts the results at runtime\nclass Convert {\n    static toPriceFeed(json) {\n        return cast(json, r(\"PriceFeed\"));\n    }\n    static priceFeedToJson(value) {\n        return uncast(value, r(\"PriceFeed\"));\n    }\n    static toPrice(json) {\n        return cast(json, r(\"Price\"));\n    }\n    static priceToJson(value) {\n        return uncast(value, r(\"Price\"));\n    }\n    static toPriceFeedMetadata(json) {\n        return cast(json, r(\"PriceFeedMetadata\"));\n    }\n    static priceFeedMetadataToJson(value) {\n        return uncast(value, r(\"PriceFeedMetadata\"));\n    }\n}\nexports.Convert = Convert;\nfunction invalidValue(typ, val, key = \"\") {\n    if (key) {\n        throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n    }\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);\n}\nfunction jsonToJSProps(typ) {\n    if (typ.jsonToJS === undefined) {\n        const map = {};\n        typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\nfunction jsToJSONProps(typ) {\n    if (typ.jsToJSON === undefined) {\n        const map = {};\n        typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\nfunction transform(val, typ, getProps, key = \"\") {\n    function transformPrimitive(typ, val) {\n        if (typeof typ === typeof val)\n            return val;\n        return invalidValue(typ, val, key);\n    }\n    function transformUnion(typs, val) {\n        // val must validate against one typ in typs\n        const l = typs.length;\n        for (let i = 0; i < l; i++) {\n            const typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            }\n            catch (_) { }\n        }\n        return invalidValue(typs, val);\n    }\n    function transformEnum(cases, val) {\n        if (cases.indexOf(val) !== -1)\n            return val;\n        return invalidValue(cases, val);\n    }\n    function transformArray(typ, val) {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val))\n            return invalidValue(\"array\", val);\n        return val.map((el) => transform(el, typ, getProps));\n    }\n    function transformDate(val) {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n    function transformObject(props, additional, val) {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        const result = {};\n        Object.getOwnPropertyNames(props).forEach((key) => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key)\n                ? val[key]\n                : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n        });\n        Object.getOwnPropertyNames(val).forEach((key) => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps, key);\n            }\n        });\n        return result;\n    }\n    if (typ === \"any\")\n        return val;\n    if (typ === null) {\n        if (val === null)\n            return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false)\n        return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ))\n        return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\")\n            ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")\n                ? transformArray(typ.arrayItems, val)\n                : typ.hasOwnProperty(\"props\")\n                    ? transformObject(getProps(typ), typ.additional, val)\n                    : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\")\n        return transformDate(val);\n    return transformPrimitive(typ, val);\n}\nfunction cast(val, typ) {\n    return transform(val, typ, jsonToJSProps);\n}\nfunction uncast(val, typ) {\n    return transform(val, typ, jsToJSONProps);\n}\nfunction a(typ) {\n    return { arrayItems: typ };\n}\nfunction u(...typs) {\n    return { unionMembers: typs };\n}\nfunction o(props, additional) {\n    return { props, additional };\n}\nfunction m(additional) {\n    return { props: [], additional };\n}\nfunction r(name) {\n    return { ref: name };\n}\nconst typeMap = {\n    PriceFeed: o([\n        { json: \"ema_price\", js: \"ema_price\", typ: r(\"Price\") },\n        { json: \"id\", js: \"id\", typ: \"\" },\n        {\n            json: \"metadata\",\n            js: \"metadata\",\n            typ: u(undefined, r(\"PriceFeedMetadata\")),\n        },\n        { json: \"price\", js: \"price\", typ: r(\"Price\") },\n        { json: \"vaa\", js: \"vaa\", typ: u(undefined, \"\") },\n    ], \"any\"),\n    Price: o([\n        { json: \"conf\", js: \"conf\", typ: \"\" },\n        { json: \"expo\", js: \"expo\", typ: 0 },\n        { json: \"price\", js: \"price\", typ: \"\" },\n        { json: \"publish_time\", js: \"publish_time\", typ: 0 },\n    ], \"any\"),\n    PriceFeedMetadata: o([\n        {\n            json: \"attestation_time\",\n            js: \"attestation_time\",\n            typ: u(undefined, 0),\n        },\n        { json: \"emitter_chain\", js: \"emitter_chain\", typ: 0 },\n        {\n            json: \"prev_publish_time\",\n            js: \"prev_publish_time\",\n            typ: u(undefined, 0),\n        },\n        {\n            json: \"price_service_receive_time\",\n            js: \"price_service_receive_time\",\n            typ: u(undefined, 0),\n        },\n        { json: \"sequence_number\", js: \"sequence_number\", typ: u(undefined, 0) },\n        { json: \"slot\", js: \"slot\", typ: u(undefined, 0) },\n    ], \"any\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHB5dGhuZXR3b3JrK3ByaWNlLXNlcnZpY2Utc2RrQDEuOC4wL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvcHJpY2Utc2VydmljZS1zZGsvbGliL3NjaGVtYXMvUHJpY2VGZWVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxtQkFBbUIscUJBQXFCLFVBQVUsb0JBQW9CO0FBQ3hIO0FBQ0EsaUNBQWlDLHFCQUFxQixXQUFXLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx1QkFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRCxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLDZDQUE2QztBQUN2RCxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0EsVUFBVSxtQ0FBbUM7QUFDN0MsVUFBVSxrQ0FBa0M7QUFDNUMsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsb0RBQW9EO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsc0VBQXNFO0FBQ2hGLFVBQVUsZ0RBQWdEO0FBQzFEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9mdWppYXdhbmcvRGVza3RvcC9jaGF0Ym90L25vZGVfbW9kdWxlcy8ucG5wbS9AcHl0aG5ldHdvcmsrcHJpY2Utc2VydmljZS1zZGtAMS44LjAvbm9kZV9tb2R1bGVzL0BweXRobmV0d29yay9wcmljZS1zZXJ2aWNlLXNkay9saWIvc2NoZW1hcy9QcmljZUZlZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUbyBwYXJzZSB0aGlzIGRhdGE6XG4vL1xuLy8gICBpbXBvcnQgeyBDb252ZXJ0LCBQcmljZUZlZWQgfSBmcm9tIFwiLi9maWxlXCI7XG4vL1xuLy8gICBjb25zdCBwcmljZUZlZWQgPSBDb252ZXJ0LnRvUHJpY2VGZWVkKGpzb24pO1xuLy9cbi8vIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBKU09OIGRvZXNuJ3Rcbi8vIG1hdGNoIHRoZSBleHBlY3RlZCBpbnRlcmZhY2UsIGV2ZW4gaWYgdGhlIEpTT04gaXMgdmFsaWQuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnZlcnQgPSB2b2lkIDA7XG4vLyBDb252ZXJ0cyBKU09OIHR5cGVzIHRvL2Zyb20geW91ciB0eXBlc1xuLy8gYW5kIGFzc2VydHMgdGhlIHJlc3VsdHMgYXQgcnVudGltZVxuY2xhc3MgQ29udmVydCB7XG4gICAgc3RhdGljIHRvUHJpY2VGZWVkKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGNhc3QoanNvbiwgcihcIlByaWNlRmVlZFwiKSk7XG4gICAgfVxuICAgIHN0YXRpYyBwcmljZUZlZWRUb0pzb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHVuY2FzdCh2YWx1ZSwgcihcIlByaWNlRmVlZFwiKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1ByaWNlKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGNhc3QoanNvbiwgcihcIlByaWNlXCIpKTtcbiAgICB9XG4gICAgc3RhdGljIHByaWNlVG9Kc29uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1bmNhc3QodmFsdWUsIHIoXCJQcmljZVwiKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1ByaWNlRmVlZE1ldGFkYXRhKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGNhc3QoanNvbiwgcihcIlByaWNlRmVlZE1ldGFkYXRhXCIpKTtcbiAgICB9XG4gICAgc3RhdGljIHByaWNlRmVlZE1ldGFkYXRhVG9Kc29uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1bmNhc3QodmFsdWUsIHIoXCJQcmljZUZlZWRNZXRhZGF0YVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db252ZXJ0ID0gQ29udmVydDtcbmZ1bmN0aW9uIGludmFsaWRWYWx1ZSh0eXAsIHZhbCwga2V5ID0gXCJcIikge1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIGtleSBcIiR7a2V5fVwiLiBFeHBlY3RlZCB0eXBlICR7SlNPTi5zdHJpbmdpZnkodHlwKX0gYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9YCk7XG4gICAgfVxuICAgIHRocm93IEVycm9yKGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkodmFsKX0gZm9yIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXApfWApO1xufVxuZnVuY3Rpb24ganNvblRvSlNQcm9wcyh0eXApIHtcbiAgICBpZiAodHlwLmpzb25Ub0pTID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgIHR5cC5wcm9wcy5mb3JFYWNoKChwKSA9PiAobWFwW3AuanNvbl0gPSB7IGtleTogcC5qcywgdHlwOiBwLnR5cCB9KSk7XG4gICAgICAgIHR5cC5qc29uVG9KUyA9IG1hcDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cC5qc29uVG9KUztcbn1cbmZ1bmN0aW9uIGpzVG9KU09OUHJvcHModHlwKSB7XG4gICAgaWYgKHR5cC5qc1RvSlNPTiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICB0eXAucHJvcHMuZm9yRWFjaCgocCkgPT4gKG1hcFtwLmpzXSA9IHsga2V5OiBwLmpzb24sIHR5cDogcC50eXAgfSkpO1xuICAgICAgICB0eXAuanNUb0pTT04gPSBtYXA7XG4gICAgfVxuICAgIHJldHVybiB0eXAuanNUb0pTT047XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0odmFsLCB0eXAsIGdldFByb3BzLCBrZXkgPSBcIlwiKSB7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUHJpbWl0aXZlKHR5cCwgdmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwID09PSB0eXBlb2YgdmFsKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXAsIHZhbCwga2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtVW5pb24odHlwcywgdmFsKSB7XG4gICAgICAgIC8vIHZhbCBtdXN0IHZhbGlkYXRlIGFnYWluc3Qgb25lIHR5cCBpbiB0eXBzXG4gICAgICAgIGNvbnN0IGwgPSB0eXBzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cCA9IHR5cHNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCB0eXAsIGdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52YWxpZFZhbHVlKHR5cHMsIHZhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUVudW0oY2FzZXMsIHZhbCkge1xuICAgICAgICBpZiAoY2FzZXMuaW5kZXhPZih2YWwpICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIHJldHVybiBpbnZhbGlkVmFsdWUoY2FzZXMsIHZhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUFycmF5KHR5cCwgdmFsKSB7XG4gICAgICAgIC8vIHZhbCBtdXN0IGJlIGFuIGFycmF5IHdpdGggbm8gaW52YWxpZCBlbGVtZW50c1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsdWUoXCJhcnJheVwiLCB2YWwpO1xuICAgICAgICByZXR1cm4gdmFsLm1hcCgoZWwpID0+IHRyYW5zZm9ybShlbCwgdHlwLCBnZXRQcm9wcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRlKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUodmFsKTtcbiAgICAgICAgaWYgKGlzTmFOKGQudmFsdWVPZigpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZShcIkRhdGVcIiwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtT2JqZWN0KHByb3BzLCBhZGRpdGlvbmFsLCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZShcIm9iamVjdFwiLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpXG4gICAgICAgICAgICAgICAgPyB2YWxba2V5XVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzdWx0W3Byb3Aua2V5XSA9IHRyYW5zZm9ybSh2LCBwcm9wLnR5cCwgZ2V0UHJvcHMsIHByb3Aua2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdHJhbnNmb3JtKHZhbFtrZXldLCBhZGRpdGlvbmFsLCBnZXRQcm9wcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXAgPT09IFwiYW55XCIpXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgaWYgKHR5cCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZSh0eXAsIHZhbCk7XG4gICAgfVxuICAgIGlmICh0eXAgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gaW52YWxpZFZhbHVlKHR5cCwgdmFsKTtcbiAgICB3aGlsZSAodHlwZW9mIHR5cCA9PT0gXCJvYmplY3RcIiAmJiB0eXAucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwID0gdHlwZU1hcFt0eXAucmVmXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUVudW0odHlwLCB2YWwpO1xuICAgIGlmICh0eXBlb2YgdHlwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB0eXAuaGFzT3duUHJvcGVydHkoXCJ1bmlvbk1lbWJlcnNcIilcbiAgICAgICAgICAgID8gdHJhbnNmb3JtVW5pb24odHlwLnVuaW9uTWVtYmVycywgdmFsKVxuICAgICAgICAgICAgOiB0eXAuaGFzT3duUHJvcGVydHkoXCJhcnJheUl0ZW1zXCIpXG4gICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1BcnJheSh0eXAuYXJyYXlJdGVtcywgdmFsKVxuICAgICAgICAgICAgICAgIDogdHlwLmhhc093blByb3BlcnR5KFwicHJvcHNcIilcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1PYmplY3QoZ2V0UHJvcHModHlwKSwgdHlwLmFkZGl0aW9uYWwsIHZhbClcbiAgICAgICAgICAgICAgICAgICAgOiBpbnZhbGlkVmFsdWUodHlwLCB2YWwpO1xuICAgIH1cbiAgICAvLyBOdW1iZXJzIGNhbiBiZSBwYXJzZWQgYnkgRGF0ZSBidXQgc2hvdWxkbid0IGJlLlxuICAgIGlmICh0eXAgPT09IERhdGUgJiYgdHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybURhdGUodmFsKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJpbWl0aXZlKHR5cCwgdmFsKTtcbn1cbmZ1bmN0aW9uIGNhc3QodmFsLCB0eXApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtKHZhbCwgdHlwLCBqc29uVG9KU1Byb3BzKTtcbn1cbmZ1bmN0aW9uIHVuY2FzdCh2YWwsIHR5cCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCB0eXAsIGpzVG9KU09OUHJvcHMpO1xufVxuZnVuY3Rpb24gYSh0eXApIHtcbiAgICByZXR1cm4geyBhcnJheUl0ZW1zOiB0eXAgfTtcbn1cbmZ1bmN0aW9uIHUoLi4udHlwcykge1xuICAgIHJldHVybiB7IHVuaW9uTWVtYmVyczogdHlwcyB9O1xufVxuZnVuY3Rpb24gbyhwcm9wcywgYWRkaXRpb25hbCkge1xuICAgIHJldHVybiB7IHByb3BzLCBhZGRpdGlvbmFsIH07XG59XG5mdW5jdGlvbiBtKGFkZGl0aW9uYWwpIHtcbiAgICByZXR1cm4geyBwcm9wczogW10sIGFkZGl0aW9uYWwgfTtcbn1cbmZ1bmN0aW9uIHIobmFtZSkge1xuICAgIHJldHVybiB7IHJlZjogbmFtZSB9O1xufVxuY29uc3QgdHlwZU1hcCA9IHtcbiAgICBQcmljZUZlZWQ6IG8oW1xuICAgICAgICB7IGpzb246IFwiZW1hX3ByaWNlXCIsIGpzOiBcImVtYV9wcmljZVwiLCB0eXA6IHIoXCJQcmljZVwiKSB9LFxuICAgICAgICB7IGpzb246IFwiaWRcIiwganM6IFwiaWRcIiwgdHlwOiBcIlwiIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGpzb246IFwibWV0YWRhdGFcIixcbiAgICAgICAgICAgIGpzOiBcIm1ldGFkYXRhXCIsXG4gICAgICAgICAgICB0eXA6IHUodW5kZWZpbmVkLCByKFwiUHJpY2VGZWVkTWV0YWRhdGFcIikpLFxuICAgICAgICB9LFxuICAgICAgICB7IGpzb246IFwicHJpY2VcIiwganM6IFwicHJpY2VcIiwgdHlwOiByKFwiUHJpY2VcIikgfSxcbiAgICAgICAgeyBqc29uOiBcInZhYVwiLCBqczogXCJ2YWFcIiwgdHlwOiB1KHVuZGVmaW5lZCwgXCJcIikgfSxcbiAgICBdLCBcImFueVwiKSxcbiAgICBQcmljZTogbyhbXG4gICAgICAgIHsganNvbjogXCJjb25mXCIsIGpzOiBcImNvbmZcIiwgdHlwOiBcIlwiIH0sXG4gICAgICAgIHsganNvbjogXCJleHBvXCIsIGpzOiBcImV4cG9cIiwgdHlwOiAwIH0sXG4gICAgICAgIHsganNvbjogXCJwcmljZVwiLCBqczogXCJwcmljZVwiLCB0eXA6IFwiXCIgfSxcbiAgICAgICAgeyBqc29uOiBcInB1Ymxpc2hfdGltZVwiLCBqczogXCJwdWJsaXNoX3RpbWVcIiwgdHlwOiAwIH0sXG4gICAgXSwgXCJhbnlcIiksXG4gICAgUHJpY2VGZWVkTWV0YWRhdGE6IG8oW1xuICAgICAgICB7XG4gICAgICAgICAgICBqc29uOiBcImF0dGVzdGF0aW9uX3RpbWVcIixcbiAgICAgICAgICAgIGpzOiBcImF0dGVzdGF0aW9uX3RpbWVcIixcbiAgICAgICAgICAgIHR5cDogdSh1bmRlZmluZWQsIDApLFxuICAgICAgICB9LFxuICAgICAgICB7IGpzb246IFwiZW1pdHRlcl9jaGFpblwiLCBqczogXCJlbWl0dGVyX2NoYWluXCIsIHR5cDogMCB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBqc29uOiBcInByZXZfcHVibGlzaF90aW1lXCIsXG4gICAgICAgICAgICBqczogXCJwcmV2X3B1Ymxpc2hfdGltZVwiLFxuICAgICAgICAgICAgdHlwOiB1KHVuZGVmaW5lZCwgMCksXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGpzb246IFwicHJpY2Vfc2VydmljZV9yZWNlaXZlX3RpbWVcIixcbiAgICAgICAgICAgIGpzOiBcInByaWNlX3NlcnZpY2VfcmVjZWl2ZV90aW1lXCIsXG4gICAgICAgICAgICB0eXA6IHUodW5kZWZpbmVkLCAwKSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBqc29uOiBcInNlcXVlbmNlX251bWJlclwiLCBqczogXCJzZXF1ZW5jZV9udW1iZXJcIiwgdHlwOiB1KHVuZGVmaW5lZCwgMCkgfSxcbiAgICAgICAgeyBqc29uOiBcInNsb3RcIiwganM6IFwic2xvdFwiLCB0eXA6IHUodW5kZWZpbmVkLCAwKSB9LFxuICAgIF0sIFwiYW55XCIpLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@pythnetwork+price-service-sdk@1.8.0/node_modules/@pythnetwork/price-service-sdk/lib/schemas/PriceFeed.js\n");

/***/ })

};
;