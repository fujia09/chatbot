(()=>{var e={};e.id=166,e.ids=[166],e.modules={44237:e=>{function t(e){var t=Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=44237,e.exports=t},10846:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},44870:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},3295:e=>{"use strict";e.exports=require("next/dist/server/app-render/after-task-async-storage.external.js")},29294:e=>{"use strict";e.exports=require("next/dist/server/app-render/work-async-storage.external.js")},63033:e=>{"use strict";e.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},12412:e=>{"use strict";e.exports=require("assert")},79428:e=>{"use strict";e.exports=require("buffer")},55511:e=>{"use strict";e.exports=require("crypto")},14985:e=>{"use strict";e.exports=require("dns")},94735:e=>{"use strict";e.exports=require("events")},29021:e=>{"use strict";e.exports=require("fs")},81630:e=>{"use strict";e.exports=require("http")},73496:e=>{"use strict";e.exports=require("http2")},55591:e=>{"use strict";e.exports=require("https")},91645:e=>{"use strict";e.exports=require("net")},21820:e=>{"use strict";e.exports=require("os")},33873:e=>{"use strict";e.exports=require("path")},11997:e=>{"use strict";e.exports=require("punycode")},27910:e=>{"use strict";e.exports=require("stream")},34631:e=>{"use strict";e.exports=require("tls")},83997:e=>{"use strict";e.exports=require("tty")},79551:e=>{"use strict";e.exports=require("url")},28354:e=>{"use strict";e.exports=require("util")},73566:e=>{"use strict";e.exports=require("worker_threads")},74075:e=>{"use strict";e.exports=require("zlib")},77598:e=>{"use strict";e.exports=require("node:crypto")},73024:e=>{"use strict";e.exports=require("node:fs")},57075:e=>{"use strict";e.exports=require("node:stream")},37830:e=>{"use strict";e.exports=require("node:stream/web")},28204:(e,t,r)=>{"use strict";let i,n;r.r(t),r.d(t,{patchFetch:()=>iH,routeModule:()=>iB,serverHooks:()=>iU,workAsyncStorage:()=>iG,workUnitAsyncStorage:()=>iF});var s={};r.r(s);var a={};r.r(a),r.d(a,{BaseChatMessageHistory:()=>eu,BaseListChatMessageHistory:()=>eh,InMemoryChatMessageHistory:()=>ed});var o={};r.r(o),r.d(o,{BaseDocumentTransformer:()=>eg,Document:()=>ep.y,MappingDocumentTransformer:()=>eb});var l={};r.r(l),r.d(l,{BaseMemory:()=>ek,getInputValue:()=>ej,getOutputValue:()=>eP,getPromptInputKey:()=>eE});var c={};r.r(c),r.d(c,{BaseRetriever:()=>e$});var u={};r.r(u),r.d(u,{BaseStore:()=>eR,InMemoryStore:()=>eM});var h={};r.r(h),r.d(h,{LangChainTracerV1:()=>eK});var d={};r.r(d),r.d(d,{getTracingCallbackHandler:()=>eB,getTracingV2CallbackHandler:()=>eG});var p={};r.r(p),r.d(p,{RunCollectorCallbackHandler:()=>eU});var f={};r.r(f),r.d(f,{Validator:()=>eZ.Dr,deepCompareStrict:()=>eZ.rA});var g={};r.r(g),r.d(g,{cosineSimilarity:()=>e4,euclideanDistance:()=>e3,innerProduct:()=>e8,matrixFunc:()=>e2,maximalMarginalRelevance:()=>e6,normalize:()=>e5});var b={};r.r(b),r.d(b,{SaveableVectorStore:()=>ti,VectorStore:()=>tr,VectorStoreRetriever:()=>tt});var m={};r.r(m),r.d(m,{FakeChatMessageHistory:()=>td,FakeChatModel:()=>tl,FakeEmbeddings:()=>tb,FakeLLM:()=>ta,FakeListChatMessageHistory:()=>tp,FakeListChatModel:()=>th,FakeRetriever:()=>tu,FakeRunnable:()=>ts,FakeSplitIntoListParser:()=>tn,FakeStreamingChatModel:()=>tc,FakeStreamingLLM:()=>to,FakeTool:()=>tg,FakeTracer:()=>tf,FakeVectorStore:()=>tw,SingleRunExtractor:()=>ty,SyntheticEmbeddings:()=>tm});var y={};r.r(y),r.d(y,{isZodSchema:()=>t_.l});var w={};r.r(w),r.d(w,{agents:()=>s,caches:()=>es,callbacks__base:()=>ea,callbacks__manager:()=>eo,callbacks__promises:()=>el,chat_history:()=>a,documents:()=>o,embeddings:()=>em,example_selectors:()=>ey,language_models__base:()=>ew,language_models__chat_models:()=>ev,language_models__llms:()=>e_,load__serializable:()=>ei,memory:()=>l,messages:()=>ec,output_parsers:()=>eS,outputs:()=>eA,prompt_values:()=>eC,prompts:()=>eN,retrievers:()=>c,runnables:()=>ex,stores:()=>u,tools:()=>eI,tracers__base:()=>eD,tracers__console:()=>eL,tracers__initialize:()=>d,tracers__log_stream:()=>eF,tracers__run_collector:()=>p,tracers__tracer_langchain:()=>eW,tracers__tracer_langchain_v1:()=>h,utils__async_caller:()=>eH,utils__chunk_array:()=>ez,utils__env:()=>eq,utils__function_calling:()=>eJ,utils__hash:()=>eY,utils__json_patch:()=>eX,utils__json_schema:()=>f,utils__math:()=>g,utils__stream:()=>e7,utils__testing:()=>m,utils__tiktoken:()=>tv,utils__types:()=>y,vectorstores:()=>b});var v={};r.r(v),r.d(v,{POST:()=>iK});var _=r(25986),k=r(68827),O=r(27034),j=r(96849),P=r(15742),E=r(45109),S=r(63057);let A=require("node:async_hooks");class N extends Error{constructor(e,t){let r=e??"";t?.lc_error_code&&(r=`${r}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${t.lc_error_code}/
`),super(r),Object.defineProperty(this,"lc_error_code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.lc_error_code=t?.lc_error_code}}class C extends N{get is_bubble_up(){return!0}}class x extends N{constructor(e,t){super(e,t),this.name="GraphRecursionError"}static get unminifiable_name(){return"GraphRecursionError"}}class T extends N{constructor(e,t){super(e,t),this.name="GraphValueError"}static get unminifiable_name(){return"GraphValueError"}}class $ extends C{constructor(e,t){super(JSON.stringify(e,null,2),t),Object.defineProperty(this,"interrupts",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name="GraphInterrupt",this.interrupts=e??[]}static get unminifiable_name(){return"GraphInterrupt"}}class R extends ${constructor(e,t){super([{value:e,when:"during"}],t),this.name="NodeInterrupt"}static get unminifiable_name(){return"NodeInterrupt"}}class M extends C{constructor(e){super(),Object.defineProperty(this,"command",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name="ParentCommand",this.command=e}static get unminifiable_name(){return"ParentCommand"}}function I(e){return void 0!==e&&!0===e.is_bubble_up}function D(e){return void 0!==e&&[$.unminifiable_name,R.unminifiable_name].includes(e.name)}class L extends N{constructor(e,t){super(e,t),this.name="EmptyInputError"}static get unminifiable_name(){return"EmptyInputError"}}class W extends N{constructor(e,t){super(e,t),this.name="EmptyChannelError"}static get unminifiable_name(){return"EmptyChannelError"}}class V extends N{constructor(e,t){super(e,t),this.name="InvalidUpdateError"}static get unminifiable_name(){return"InvalidUpdateError"}}class q extends N{constructor(e,t){super(e,t),this.name="MultipleSubgraphError"}static get unminifiable_name(){return"MultipleSubgraphError"}}class K extends N{constructor(e,t){super(e,t),this.name="UnreachableNodeError"}static get unminifiable_name(){return"UnreachableNodeError"}}let B=()=>(void 0===globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")]&&(globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")]=new Set),globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")]);var G=r(9129),F=r(30025);let U=0,H=0,z=function(e,t,r){let s=t&&r||0,a=t||Array(16),o=(e=e||{}).node,l=e.clockseq;if(e._v6||(o||(o=i),null!=l||(l=n)),null==o||null==l){let t=e.random||(e.rng||F.A)();null!=o||(o=[t[0],t[1],t[2],t[3],t[4],t[5]],i||e._v6||(o[0]|=1,i=o)),null!=l||(l=(t[6]<<8|t[7])&16383,void 0!==n||e._v6||(n=l))}let c=void 0!==e.msecs?e.msecs:Date.now(),u=void 0!==e.nsecs?e.nsecs:H+1,h=c-U+(u-H)/1e4;if(h<0&&void 0===e.clockseq&&(l=l+1&16383),(h<0||c>U)&&void 0===e.nsecs&&(u=0),u>=1e4)throw Error("uuid.v1(): Can't create more than 10M uuids/sec");U=c,H=u,n=l;let d=((0xfffffff&(c+=122192928e5))*1e4+u)%0x100000000;a[s++]=d>>>24&255,a[s++]=d>>>16&255,a[s++]=d>>>8&255,a[s++]=255&d;let p=c/0x100000000*1e4&0xfffffff;a[s++]=p>>>8&255,a[s++]=255&p,a[s++]=p>>>24&15|16,a[s++]=p>>>16&255,a[s++]=l>>>8|128,a[s++]=255&l;for(let e=0;e<6;++e)a[s+e]=o[e];return t||(0,G.k)(a)};var J=r(20143);let Y=function(e){let t;if(!(0,J.A)(e))throw TypeError("Invalid UUID");let r=new Uint8Array(16);return r[0]=(t=parseInt(e.slice(0,8),16))>>>24,r[1]=t>>>16&255,r[2]=t>>>8&255,r[3]=255&t,r[4]=(t=parseInt(e.slice(9,13),16))>>>8,r[5]=255&t,r[6]=(t=parseInt(e.slice(14,18),16))>>>8,r[7]=255&t,r[8]=(t=parseInt(e.slice(19,23),16))>>>8,r[9]=255&t,r[10]=(t=parseInt(e.slice(24,36),16))/0x10000000000&255,r[11]=t/0x100000000&255,r[12]=t>>>24&255,r[13]=t>>>16&255,r[14]=t>>>8&255,r[15]=255&t,r};var X=r(77598),Z=r.n(X);let Q=function(e,t,r){function i(e,t,i,n){var s;if("string"==typeof e&&(e=function(e){e=unescape(encodeURIComponent(e));let t=[];for(let r=0;r<e.length;++r)t.push(e.charCodeAt(r));return t}(e)),"string"==typeof t&&(t=Y(t)),(null===(s=t)||void 0===s?void 0:s.length)!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");let a=new Uint8Array(16+e.length);if(a.set(t),a.set(e,t.length),(a=r(a))[6]=15&a[6]|80,a[8]=63&a[8]|128,i){n=n||0;for(let e=0;e<16;++e)i[n+e]=a[e];return i}return(0,G.k)(a)}try{i.name="v5"}catch(e){}return i.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",i.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",i}(0,0,function(e){return Array.isArray(e)?e=Buffer.from(e):"string"==typeof e&&(e=Buffer.from(e,"utf8")),Z().createHash("sha1").update(e).digest()});function ee(e){return function(e={},t,r=0){let i=z({...e,_v6:!0},new Uint8Array(16));return i=function(e){let t=function(e,t=!1){return Uint8Array.of((15&e[6])<<4|e[7]>>4&15,(15&e[7])<<4|(240&e[4])>>4,(15&e[4])<<4|(240&e[5])>>4,(15&e[5])<<4|(240&e[0])>>4,(15&e[0])<<4|(240&e[1])>>4,(15&e[1])<<4|(240&e[2])>>4,96|15&e[2],e[3],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}("string"==typeof e?Y(e):e);return"string"==typeof e?(0,G.k)(t):t}(i),(0,G.k)(i)}({clockseq:e})}function et(e,t){return Q(e,new Uint8Array(t.replace(/-/g,"").match(/.{2}/g).map(e=>parseInt(e,16))))}let er="__scheduled__";var ei=r(65880);let en=[];var es=r(40691),ea=r(18668),eo=r(70795),el=r(49455),ec=r(60506);class eu extends ei.Serializable{async addMessages(e){for(let t of e)await this.addMessage(t)}}class eh extends ei.Serializable{addUserMessage(e){return this.addMessage(new ec.HumanMessage(e))}addAIChatMessage(e){return this.addMessage(new ec.AIMessage(e))}addAIMessage(e){return this.addMessage(new ec.AIMessage(e))}async addMessages(e){for(let t of e)await this.addMessage(t)}clear(){throw Error("Not implemented.")}}class ed extends eh{constructor(e){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","stores","message","in_memory"]}),Object.defineProperty(this,"messages",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.messages=e??[]}async getMessages(){return this.messages}async addMessage(e){this.messages.push(e)}async clear(){this.messages=[]}}var ep=r(7378),ef=r(30081);class eg extends ef.YN{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","documents","transformers"]})}invoke(e,t){return this.transformDocuments(e)}}class eb extends eg{async transformDocuments(e){let t=[];for(let r of e){let e=await this._transformDocument(r);t.push(e)}return t}}var em=r(83722),ey=r(16290),ew=r(15223),ev=r(13405),e_=r(82666);class ek{}let eO=(e,t)=>{if(void 0!==t)return e[t];let r=Object.keys(e);if(1===r.length)return e[r[0]]},ej=(e,t)=>{let r=eO(e,t);if(!r){let t=Object.keys(e);throw Error(`input values have ${t.length} keys, you must specify an input key or pass only 1 key as input`)}return r},eP=(e,t)=>{let r=eO(e,t);if(!r&&""!==r){let t=Object.keys(e);throw Error(`output values have ${t.length} keys, you must specify an output key or pass only 1 key as output`)}return r};function eE(e,t){let r=Object.keys(e).filter(e=>!t.includes(e)&&"stop"!==e);if(1!==r.length)throw Error(`One input key expected, but got ${r.length}`);return r[0]}var eS=r(1822),eA=r(89384),eN=r(61281),eC=r(28191),ex=r(46709),eT=r(57505);class e$ extends ef.YN{constructor(e){super(e),Object.defineProperty(this,"callbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"verbose",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.callbacks=e?.callbacks,this.tags=e?.tags??[],this.metadata=e?.metadata??{},this.verbose=e?.verbose??!1}_getRelevantDocuments(e,t){throw Error("Not implemented!")}async invoke(e,t){return this.getRelevantDocuments(e,(0,eT.ZI)(t))}async getRelevantDocuments(e,t){let r=(0,eT.ZI)((0,eo.parseCallbackConfigArg)(t)),i=await eo.CallbackManager.configure(r.callbacks,this.callbacks,r.tags,this.tags,r.metadata,this.metadata,{verbose:this.verbose}),n=await i?.handleRetrieverStart(this.toJSON(),e,r.runId,void 0,void 0,void 0,r.runName);try{let t=await this._getRelevantDocuments(e,n);return await n?.handleRetrieverEnd(t),t}catch(e){throw await n?.handleRetrieverError(e),e}}}class eR extends ei.Serializable{}class eM extends eR{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","storage"]}),Object.defineProperty(this,"store",{enumerable:!0,configurable:!0,writable:!0,value:{}})}async mget(e){return e.map(e=>this.store[e])}async mset(e){for(let[t,r]of e)this.store[t]=r}async mdelete(e){for(let t of e)delete this.store[t]}async *yieldKeys(e){for(let t of Object.keys(this.store))(void 0===e||t.startsWith(e))&&(yield t)}}var eI=r(83710),eD=r(88902),eL=r(46426),eW=r(8898),eV=r(9650),eq=r(23383);class eK extends eD.BaseTracer{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"endpoint",{enumerable:!0,configurable:!0,writable:!0,value:(0,eq.getEnvironmentVariable)("LANGCHAIN_ENDPOINT")||"http://localhost:1984"}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:{"Content-Type":"application/json"}}),Object.defineProperty(this,"session",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let e=(0,eq.getEnvironmentVariable)("LANGCHAIN_API_KEY");e&&(this.headers["x-api-key"]=e)}async newSession(e){let t={start_time:Date.now(),name:e},r=await this.persistSession(t);return this.session=r,r}async loadSession(e){let t=`${this.endpoint}/sessions?name=${e}`;return this._handleSessionResponse(t)}async loadDefaultSession(){let e=`${this.endpoint}/sessions?name=default`;return this._handleSessionResponse(e)}async convertV2RunToRun(e){let t;let r=this.session??await this.loadDefaultSession(),i=e.serialized;if("llm"===e.run_type){let n=e.inputs.prompts?e.inputs.prompts:e.inputs.messages.map(e=>(0,eV.Sw)(e));t={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:i,type:e.run_type,session_id:r.id,prompts:n,response:e.outputs}}else if("chain"===e.run_type){let n=await Promise.all(e.child_runs.map(e=>this.convertV2RunToRun(e)));t={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:i,type:e.run_type,session_id:r.id,inputs:e.inputs,outputs:e.outputs,child_llm_runs:n.filter(e=>"llm"===e.type),child_chain_runs:n.filter(e=>"chain"===e.type),child_tool_runs:n.filter(e=>"tool"===e.type)}}else if("tool"===e.run_type){let n=await Promise.all(e.child_runs.map(e=>this.convertV2RunToRun(e)));t={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:i,type:e.run_type,session_id:r.id,tool_input:e.inputs.input,output:e.outputs?.output,action:JSON.stringify(i),child_llm_runs:n.filter(e=>"llm"===e.type),child_chain_runs:n.filter(e=>"chain"===e.type),child_tool_runs:n.filter(e=>"tool"===e.type)}}else throw Error(`Unknown run type: ${e.run_type}`);return t}async persistRun(e){let t,r;t="llm"===(r=void 0!==e.run_type?await this.convertV2RunToRun(e):e).type?`${this.endpoint}/llm-runs`:"chain"===r.type?`${this.endpoint}/chain-runs`:`${this.endpoint}/tool-runs`;let i=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(r)});i.ok||console.error(`Failed to persist run: ${i.status} ${i.statusText}`)}async persistSession(e){let t=`${this.endpoint}/sessions`,r=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(e)});return r.ok?{id:(await r.json()).id,...e}:(console.error(`Failed to persist session: ${r.status} ${r.statusText}, using default session.`),{id:1,...e})}async _handleSessionResponse(e){let t;let r=await fetch(e,{method:"GET",headers:this.headers});if(!r.ok)return console.error(`Failed to load session: ${r.status} ${r.statusText}`),t={id:1,start_time:Date.now()},this.session=t,t;let i=await r.json();return 0===i.length?t={id:1,start_time:Date.now()}:[t]=i,this.session=t,t}}async function eB(e){let t=new eK;return e?await t.loadSession(e):await t.loadDefaultSession(),t}async function eG(){return new eW.LangChainTracer}var eF=r(23392);class eU extends eD.BaseTracer{constructor({exampleId:e}={}){super({_awaitHandler:!0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"run_collector"}),Object.defineProperty(this,"exampleId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracedRuns",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.exampleId=e,this.tracedRuns=[]}async persistRun(e){let t={...e};t.reference_example_id=this.exampleId,this.tracedRuns.push(t)}}var eH=r(78228),ez=r(10183),eJ=r(2517),eY=r(11358),eX=r(16869),eZ=r(87778);function eQ(e,t){let r=0,i=0,n=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s],i+=e[s]*e[s],n+=t[s]*t[s];return r/(Math.sqrt(i)*Math.sqrt(n))}function e0(e,t){let r=0;for(let i=0;i<e.length;i++)r+=e[i]*t[i];return r}function e1(e,t){return Math.sqrt(function(e,t){let r=0;for(let i=0;i<e.length;i++)r+=(e[i]-t[i])*(e[i]-t[i]);return r}(e,t))}function e2(e,t,r){if(0===e.length||0===e[0].length||0===t.length||0===t[0].length)return[[]];if(e[0].length!==t[0].length)throw Error(`Number of columns in X and Y must be the same. X has shape ${[e.length,e[0].length]} and Y has shape ${[t.length,t[0].length]}.`);return e.map(e=>t.map(t=>r(e,t)).map(e=>Number.isNaN(e)?0:e))}function e5(e,t=!1){let r=e.reduce((e,t)=>Math.max(e,e9(t).maxValue),0);return e.map(e=>e.map(e=>t?1-e/r:e/r))}function e4(e,t){return e2(e,t,eQ)}function e8(e,t){return e2(e,t,e0)}function e3(e,t){return e2(e,t,e1)}function e6(e,t,r=.5,i=4){if(0>=Math.min(i,t.length))return[];let n=e4(Array.isArray(e[0])?e:[e],t)[0],s=e9(n).maxIndex,a=[t[s]],o=[s];for(;o.length<Math.min(i,t.length);){let e=-1/0,i=-1,s=e4(t,a);n.forEach((t,n)=>{if(o.includes(n))return;let a=r*t-(1-r)*Math.max(...s[n]);a>e&&(e=a,i=n)}),a.push(t[i]),o.push(i)}return o}function e9(e){if(0===e.length)return{maxIndex:-1,maxValue:NaN};let t=e[0],r=0;for(let i=1;i<e.length;i+=1)e[i]>t&&(r=i,t=e[i]);return{maxIndex:r,maxValue:t}}var e7=r(40938),te=r(27532);class tt extends e${static lc_name(){return"VectorStoreRetriever"}get lc_namespace(){return["langchain_core","vectorstores"]}_vectorstoreType(){return this.vectorStore._vectorstoreType()}constructor(e){super(e),Object.defineProperty(this,"vectorStore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"k",{enumerable:!0,configurable:!0,writable:!0,value:4}),Object.defineProperty(this,"searchType",{enumerable:!0,configurable:!0,writable:!0,value:"similarity"}),Object.defineProperty(this,"searchKwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"filter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.vectorStore=e.vectorStore,this.k=e.k??this.k,this.searchType=e.searchType??this.searchType,this.filter=e.filter,"mmr"===e.searchType&&(this.searchKwargs=e.searchKwargs)}async _getRelevantDocuments(e,t){if("mmr"===this.searchType){if("function"!=typeof this.vectorStore.maxMarginalRelevanceSearch)throw Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);return this.vectorStore.maxMarginalRelevanceSearch(e,{k:this.k,filter:this.filter,...this.searchKwargs},t?.getChild("vectorstore"))}return this.vectorStore.similaritySearch(e,this.k,this.filter,t?.getChild("vectorstore"))}async addDocuments(e,t){return this.vectorStore.addDocuments(e,t)}}class tr extends ei.Serializable{constructor(e,t){super(t),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","vectorstores",this._vectorstoreType()]}),Object.defineProperty(this,"embeddings",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.embeddings=e}async delete(e){throw Error("Not implemented.")}async similaritySearch(e,t=4,r,i){return(await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e),t,r)).map(e=>e[0])}async similaritySearchWithScore(e,t=4,r,i){return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(e),t,r)}static fromTexts(e,t,r,i){throw Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug")}static fromDocuments(e,t,r){throw Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug")}asRetriever(e,t,r,i,n,s){if("number"==typeof e)return new tt({vectorStore:this,k:e,filter:t,tags:[...i??[],this._vectorstoreType()],metadata:n,verbose:s,callbacks:r});{let t={vectorStore:this,k:e?.k,filter:e?.filter,tags:[...e?.tags??[],this._vectorstoreType()],metadata:e?.metadata,verbose:e?.verbose,callbacks:e?.callbacks,searchType:e?.searchType};return new tt(e?.searchType==="mmr"?{...t,searchKwargs:e.searchKwargs}:{...t})}}}class ti extends tr{static load(e,t){throw Error("Not implemented")}}class tn extends te.mJ{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["tests","fake"]})}getFormatInstructions(){return""}async parse(e){return e.split(",").map(e=>e.trim())}}class ts extends ef.YN{constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["tests","fake"]}),Object.defineProperty(this,"returnOptions",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.returnOptions=e.returnOptions}async invoke(e,t){return this.returnOptions?t??{}:{input:e}}}class ta extends e_.LLM{constructor(e){super(e),Object.defineProperty(this,"response",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"thrownErrorString",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.response=e.response,this.thrownErrorString=e.thrownErrorString}_llmType(){return"fake"}async _call(e,t,r){if(this.thrownErrorString)throw Error(this.thrownErrorString);let i=this.response??e;return await r?.handleLLMNewToken(i),i}}class to extends e_.LLM{constructor(e){super(e),Object.defineProperty(this,"sleep",{enumerable:!0,configurable:!0,writable:!0,value:50}),Object.defineProperty(this,"responses",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"thrownErrorString",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.sleep=e.sleep??this.sleep,this.responses=e.responses,this.thrownErrorString=e.thrownErrorString}_llmType(){return"fake"}async _call(e){if(this.thrownErrorString)throw Error(this.thrownErrorString);let t=this.responses?.[0];return this.responses=this.responses?.slice(1),t??e}async *_streamResponseChunks(e,t,r){if(this.thrownErrorString)throw Error(this.thrownErrorString);let i=this.responses?.[0];for(let t of(this.responses=this.responses?.slice(1),i??e))await new Promise(e=>setTimeout(e,this.sleep)),yield{text:t,generationInfo:{}},await r?.handleLLMNewToken(t)}}class tl extends ev.BaseChatModel{_combineLLMOutput(){return[]}_llmType(){return"fake"}async _generate(e,t,r){if(t?.stop?.length)return{generations:[{message:new ec.AIMessage(t.stop[0]),text:t.stop[0]}]};let i=e.map(e=>"string"==typeof e.content?e.content:JSON.stringify(e.content,null,2)).join("\n");return await r?.handleLLMNewToken(i),{generations:[{message:new ec.AIMessage(i),text:i}],llmOutput:{}}}}class tc extends ev.BaseChatModel{constructor(e){super(e),Object.defineProperty(this,"sleep",{enumerable:!0,configurable:!0,writable:!0,value:50}),Object.defineProperty(this,"responses",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"thrownErrorString",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.sleep=e.sleep??this.sleep,this.responses=e.responses,this.thrownErrorString=e.thrownErrorString}_llmType(){return"fake"}async _generate(e,t,r){if(this.thrownErrorString)throw Error(this.thrownErrorString);let i=this.responses?.[0].content??e[0].content;return{generations:[{text:"",message:new ec.AIMessage({content:i})}]}}async *_streamResponseChunks(e,t,r){if(this.thrownErrorString)throw Error(this.thrownErrorString);let i=this.responses?.[0].content??e[0].content;if("string"!=typeof i)for(let t of this.responses??e)yield new eA.ChatGenerationChunk({text:"",message:new ec.AIMessageChunk({content:i})});else for(let t of this.responses??e)yield new eA.ChatGenerationChunk({text:i,message:new ec.AIMessageChunk({content:i})})}}class tu extends e${constructor(e){super(),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["test","fake"]}),Object.defineProperty(this,"output",{enumerable:!0,configurable:!0,writable:!0,value:[new ep.y({pageContent:"foo"}),new ep.y({pageContent:"bar"})]}),this.output=e?.output??this.output}async _getRelevantDocuments(e){return this.output}}class th extends ev.BaseChatModel{static lc_name(){return"FakeListChatModel"}constructor(e){super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"responses",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"i",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"sleep",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"emitCustomEvent",{enumerable:!0,configurable:!0,writable:!0,value:!1});let{responses:t,sleep:r,emitCustomEvent:i}=e;this.responses=t,this.sleep=r,this.emitCustomEvent=i??this.emitCustomEvent}_combineLLMOutput(){return[]}_llmType(){return"fake-list"}async _generate(e,t,r){if(await this._sleepIfRequested(),t?.thrownErrorString)throw Error(t.thrownErrorString);if(this.emitCustomEvent&&await r?.handleCustomEvent("some_test_event",{someval:!0}),t?.stop?.length)return{generations:[this._formatGeneration(t.stop[0])]};{let e=this._currentResponse();return this._incrementResponse(),{generations:[this._formatGeneration(e)],llmOutput:{}}}}_formatGeneration(e){return{message:new ec.AIMessage(e),text:e}}async *_streamResponseChunks(e,t,r){let i=this._currentResponse();for await(let e of(this._incrementResponse(),this.emitCustomEvent&&await r?.handleCustomEvent("some_test_event",{someval:!0}),i)){if(await this._sleepIfRequested(),t?.thrownErrorString)throw Error(t.thrownErrorString);let i=this._createResponseChunk(e);yield i,r?.handleLLMNewToken(e)}}async _sleepIfRequested(){void 0!==this.sleep&&await this._sleep()}async _sleep(){return new Promise(e=>{setTimeout(()=>e(),this.sleep)})}_createResponseChunk(e){return new eA.ChatGenerationChunk({message:new ec.AIMessageChunk({content:e}),text:e})}_currentResponse(){return this.responses[this.i]}_incrementResponse(){this.i<this.responses.length-1?this.i+=1:this.i=0}withStructuredOutput(e,t){return ef.jY.from(async e=>JSON.parse((await this.invoke(e)).content))}}class td extends eu{constructor(){super(),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","message","fake"]}),Object.defineProperty(this,"messages",{enumerable:!0,configurable:!0,writable:!0,value:[]})}async getMessages(){return this.messages}async addMessage(e){this.messages.push(e)}async addUserMessage(e){this.messages.push(new ec.HumanMessage(e))}async addAIChatMessage(e){this.messages.push(new ec.AIMessage(e))}async clear(){this.messages=[]}}class tp extends eh{constructor(){super(),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","message","fake"]}),Object.defineProperty(this,"messages",{enumerable:!0,configurable:!0,writable:!0,value:[]})}async addMessage(e){this.messages.push(e)}async getMessages(){return this.messages}}class tf extends eD.BaseTracer{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"fake_tracer"}),Object.defineProperty(this,"runs",{enumerable:!0,configurable:!0,writable:!0,value:[]})}persistRun(e){return this.runs.push(e),Promise.resolve()}}class tg extends eI.StructuredTool{constructor(e){super(e),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"description",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"schema",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=e.name,this.description=e.description,this.schema=e.schema}async _call(e,t){return JSON.stringify(e)}}class tb extends em.Embeddings{constructor(e){super(e??{})}embedDocuments(e){return Promise.resolve(e.map(()=>[.1,.2,.3,.4]))}embedQuery(e){return Promise.resolve([.1,.2,.3,.4])}}class tm extends em.Embeddings{constructor(e){super(e??{}),Object.defineProperty(this,"vectorSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.vectorSize=e?.vectorSize??4}async embedDocuments(e){return Promise.all(e.map(e=>this.embedQuery(e)))}async embedQuery(e){let t=e,r=(t=t.toLowerCase().replaceAll(/[^a-z ]/g,"")).length%this.vectorSize,i=0===r?0:this.vectorSize-r,n=t.length+i,s=(t=t.padEnd(n," ")).length/this.vectorSize,a=[];for(let e=0;e<t.length;e+=s)a.push(t.slice(e,e+s));return a.map(e=>{let t=0;for(let r=0;r<e.length;r+=1)t+=" "===e?0:e.charCodeAt(r);return t%26/26})}}class ty extends eD.BaseTracer{constructor(){super(),Object.defineProperty(this,"runPromiseResolver",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"runPromise",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"single_run_extractor"}),this.runPromise=new Promise(e=>{this.runPromiseResolver=e})}async persistRun(e){this.runPromiseResolver(e)}async extract(){return this.runPromise}}class tw extends tr{_vectorstoreType(){return"memory"}constructor(e,{similarity:t,...r}={}){super(e,r),Object.defineProperty(this,"memoryVectors",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"similarity",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.similarity=t??eQ}async addDocuments(e){let t=e.map(({pageContent:e})=>e);return this.addVectors(await this.embeddings.embedDocuments(t),e)}async addVectors(e,t){let r=e.map((e,r)=>({content:t[r].pageContent,embedding:e,metadata:t[r].metadata}));this.memoryVectors=this.memoryVectors.concat(r)}async similaritySearchVectorWithScore(e,t,r){let i=this.memoryVectors.filter(e=>!r||r(new ep.y({metadata:e.metadata,pageContent:e.content})));return i.map((t,r)=>({similarity:this.similarity(e,t.embedding),index:r})).sort((e,t)=>e.similarity>t.similarity?-1:0).slice(0,t).map(e=>[new ep.y({metadata:i[e.index].metadata,pageContent:i[e.index].content}),e.similarity])}static async fromTexts(e,t,r,i){let n=[];for(let r=0;r<e.length;r+=1){let i=Array.isArray(t)?t[r]:t,s=new ep.y({pageContent:e[r],metadata:i});n.push(s)}return tw.fromDocuments(n,r,i)}static async fromDocuments(e,t,r){let i=new this(t,r);return await i.addDocuments(e),i}static async fromExistingIndex(e,t){return new this(e,t)}}var tv=r(17204),t_=r(83794),tk=r(81280);async function tO(e){let{optionalImportsMap:t={},optionalImportEntrypoints:r=[],importMap:i={},secretsMap:n={},path:s=["$"]}=this,a=s.join(".");if("object"==typeof e&&null!==e&&!Array.isArray(e)&&"lc"in e&&"type"in e&&"id"in e&&1===e.lc&&"secret"===e.type){let[t]=e.id;if(t in n)return n[t];{let e=(0,eq.getEnvironmentVariable)(t);if(e)return e;throw Error(`Missing key "${t}" for ${a} in load(secretsMap={})`)}}if("object"==typeof e&&null!==e&&!Array.isArray(e)&&"lc"in e&&"type"in e&&"id"in e&&1===e.lc&&"not_implemented"===e.type){let t=JSON.stringify(e);throw Error(`Trying to load an object that doesn't implement serialization: ${a} -> ${t}`)}if("object"==typeof e&&null!==e&&!Array.isArray(e)&&"lc"in e&&"type"in e&&"id"in e&&"kwargs"in e&&1===e.lc){let n=JSON.stringify(e),[o,...l]=e.id.slice().reverse(),c=l.reverse(),u=null,h=[c.join("/")];"langchain_community"===c[0]&&h.push(["langchain",...c.slice(1)].join("/"));let d=h.find(e=>e in t);if(en.concat(r).includes(c.join("/"))||d){if(void 0!==d)u=await t[d];else throw Error(`Missing key "${c.join("/")}" for ${a} in load(optionalImportsMap={})`)}else{let e,t;if("langchain"===c[0]||"langchain_core"===c[0])e=({langchain_core:w,langchain:i})[c[0]],c.shift();else throw Error(`Invalid namespace: ${a} -> ${n}`);if(0===c.length)throw Error(`Invalid namespace: ${a} -> ${n}`);do{if((t=c.join("__"))in e)break;c.pop()}while(c.length>0);t in e&&(u=e[t])}if("object"!=typeof u||null===u)throw Error(`Invalid namespace: ${a} -> ${n}`);let p=u[o]??Object.values(u).find(e=>"function"==typeof e&&(0,ei.get_lc_unique_name)(e)===o);if("function"!=typeof p)throw Error(`Invalid identifer: ${a} -> ${n}`);let f=await tO.call({...this,path:[...s,"kwargs"]},e.kwargs);if("constructor"===e.type){let e=new p((0,tk.d4)(f,tk.O3,function(e){let t={};for(let r=e;r&&r.prototype;r=Object.getPrototypeOf(r))Object.assign(t,Reflect.get(r.prototype,"lc_aliases"));return Object.entries(t).reduce((e,[t,r])=>(e[r]=t,e),{})}(p)));return Object.defineProperty(e.constructor,"name",{value:o}),e}throw Error(`Invalid type: ${a} -> ${n}`)}return"object"==typeof e&&null!==e?Array.isArray(e)?Promise.all(e.map((e,t)=>tO.call({...this,path:[...s,`${t}`]},e))):Object.fromEntries(await Promise.all(Object.entries(e).map(async([e,t])=>[e,await tO.call({...this,path:[...s,e]},t)]))):e}async function tj(e,t){let r=JSON.parse(e);return tO.call({...t},r)}var tP=[],tE=[];function tS(e,t,r,i){var n=Object.getOwnPropertyDescriptor(i,r);void 0!==n.get?n.configurable?(Object.defineProperty(i,r,{value:e}),tP.push([i,r,t,n])):tE.push([t,r,e]):(i[r]=e,tP.push([i,r,t]))}async function tA(e){if(e&&"object"==typeof e){if(Array.isArray(e))return await Promise.all(e.map(e=>tA(e)));{let t={};for(let[r,i]of Object.entries(e))t[r]=await tA(i);if(2===t.lc&&"undefined"===t.type)return;if(2===t.lc&&"constructor"===t.type&&Array.isArray(t.id))try{let e;switch(t.id[t.id.length-1]){case"Set":e=Set;break;case"Map":e=Map;break;case"RegExp":e=RegExp;break;case"Error":e=Error;break;default:return t}if(t.method)return e[t.method](...t.args||[]);return new e(...t.args||[])}catch(e){}else if(null!==t&&1===t.lc&&"constructor"===t.type&&Array.isArray(t.id))return tj(JSON.stringify(t));return t}}return e}function tN(e,t,r,i){return{lc:2,type:"constructor",id:[e.name],method:t??null,args:r??[],kwargs:i??{}}}class tC{_dumps(e){return new TextEncoder().encode(function(e,t,r,i){void 0===i&&(i={depthLimit:Number.MAX_SAFE_INTEGER,edgesLimit:Number.MAX_SAFE_INTEGER}),function e(t,r,i,n,s,a,o){if(a+=1,"object"==typeof t&&null!==t){for(l=0;l<n.length;l++)if(n[l]===t){tS("[Circular]",t,r,s);return}if(void 0!==o.depthLimit&&a>o.depthLimit||void 0!==o.edgesLimit&&i+1>o.edgesLimit){tS("[...]",t,r,s);return}if(n.push(t),Array.isArray(t))for(l=0;l<t.length;l++)e(t[l],l,l,n,t,a,o);else{var l,c=Object.keys(t);for(l=0;l<c.length;l++){var u=c[l];e(t[u],u,l,n,t,a,o)}}n.pop()}}(e,"",0,[],void 0,0,i);try{var n;s=0===tE.length?JSON.stringify(e,t,void 0):JSON.stringify(e,(n=t,n=void 0!==n?n:function(e,t){return t},function(e,t){if(tE.length>0)for(var r=0;r<tE.length;r++){var i=tE[r];if(i[1]===e&&i[0]===t){t=i[2],tE.splice(r,1);break}}return n.call(this,e,t)}),void 0)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==tP.length;){var s,a=tP.pop();4===a.length?Object.defineProperty(a[0],a[1],a[3]):a[0][a[1]]=a[2]}}return s}(e,(e,t)=>{var r;return void 0===(r=t)?{lc:2,type:"undefined"}:r instanceof Set||r instanceof Map?tN(r.constructor,void 0,[Array.from(r)]):r instanceof RegExp?tN(RegExp,void 0,[r.source,r.flags]):r instanceof Error?tN(r.constructor,void 0,[r.message]):r?.lg_name==="Send"?{node:r.node,args:r.args}:r}))}dumpsTyped(e){return e instanceof Uint8Array?["bytes",e]:["json",this._dumps(e)]}async _loads(e){return tA(JSON.parse(e))}async loadsTyped(e,t){if("bytes"===e)return"string"==typeof t?new TextEncoder().encode(t):t;if("json"===e)return this._loads("string"==typeof t?t:new TextDecoder().decode(t));throw Error(`Unknown serialization type: ${e}`)}}function tx(e){if("object"!=typeof e||null===e)return e;let t=Array.isArray(e)?[]:{};for(let r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=tx(e[r]));return t}function tT(){return{v:1,id:ee(-2),ts:new Date().toISOString(),channel_values:{},channel_versions:{},versions_seen:{},pending_sends:[]}}function t$(e){return{v:e.v,id:e.id,ts:e.ts,channel_values:{...e.channel_values},channel_versions:{...e.channel_versions},versions_seen:tx(e.versions_seen),pending_sends:[...e.pending_sends]}}class tR{constructor(e){Object.defineProperty(this,"serde",{enumerable:!0,configurable:!0,writable:!0,value:new tC}),this.serde=e||this.serde}async get(e){let t=await this.getTuple(e);return t?t.checkpoint:void 0}getNextVersion(e,t){if("string"==typeof e)throw Error("Please override this method to use string versions.");return void 0!==e&&"number"==typeof e?e+1:1}}function tM(e,t){return"number"==typeof e&&"number"==typeof t?Math.sign(e-t):String(e).localeCompare(String(t))}function tI(...e){return e.reduce((e,t,r)=>0===r?t:tM(e,t)>=0?e:t)}let tD={__error__:-1,[er]:-2,__interrupt__:-3,__resume__:-4};function tL(e,t,r){return JSON.stringify([e,t,r])}class tW extends tR{constructor(e){super(e),Object.defineProperty(this,"storage",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"writes",{enumerable:!0,configurable:!0,writable:!0,value:{}})}async _getPendingSends(e,t,r){let i=[];if(void 0!==r){let n=tL(e,t,r);i=await Promise.all(Object.values(this.writes[n]||{})?.filter(([e,t])=>"__pregel_tasks"===t).map(([e,t,r])=>this.serde.loadsTyped("json",r))??[])}return i}async getTuple(e){let t=e.configurable?.thread_id,r=e.configurable?.checkpoint_ns??"",i=e.configurable?.checkpoint_id||e.configurable?.thread_ts||"";if(i){let n=this.storage[t]?.[r]?.[i];if(void 0!==n){let[s,a,o]=n,l=tL(t,r,i),c=await this._getPendingSends(t,r,o),u={...await this.serde.loadsTyped("json",s),pending_sends:c},h=await Promise.all(Object.values(this.writes[l]||{}).map(async([e,t,r])=>[e,t,await this.serde.loadsTyped("json",r)])),d={config:e,checkpoint:u,metadata:await this.serde.loadsTyped("json",a),pendingWrites:h};return void 0!==o&&(d.parentConfig={configurable:{thread_id:t,checkpoint_ns:r,checkpoint_id:o}}),d}}else{let e=this.storage[t]?.[r];if(void 0!==e){i=Object.keys(e).sort((e,t)=>t.localeCompare(e))[0];let[n,s,a]=e[i],o=tL(t,r,i),l=await this._getPendingSends(t,r,a),c={...await this.serde.loadsTyped("json",n),pending_sends:l},u=await Promise.all(Object.values(this.writes[o]||{}).map(async([e,t,r])=>[e,t,await this.serde.loadsTyped("json",r)])),h={config:{configurable:{thread_id:t,checkpoint_id:i,checkpoint_ns:r}},checkpoint:c,metadata:await this.serde.loadsTyped("json",s),pendingWrites:u};return void 0!==a&&(h.parentConfig={configurable:{thread_id:t,checkpoint_ns:r,checkpoint_id:a}}),h}}}async *list(e,t){let{before:r,limit:i,filter:n}=t??{},s=e.configurable?.thread_id?[e.configurable?.thread_id]:Object.keys(this.storage),a=e.configurable?.checkpoint_ns,o=e.configurable?.checkpoint_id;for(let e of s)for(let t of Object.keys(this.storage[e]??{}))if(void 0===a||t===a)for(let[s,[a,l,c]]of Object.entries(this.storage[e]?.[t]??{}).sort((e,t)=>t[0].localeCompare(e[0]))){if(o&&s!==o||r&&r.configurable?.checkpoint_id&&s>=r.configurable.checkpoint_id)continue;let u=await this.serde.loadsTyped("json",l);if(n&&!Object.entries(n).every(([e,t])=>u[e]===t))continue;if(void 0!==i){if(i<=0)break;i-=1}let h=tL(e,t,s),d=Object.values(this.writes[h]||{}),p=await this._getPendingSends(e,t,c),f=await Promise.all(d.map(async([e,t,r])=>[e,t,await this.serde.loadsTyped("json",r)])),g={config:{configurable:{thread_id:e,checkpoint_ns:t,checkpoint_id:s}},checkpoint:{...await this.serde.loadsTyped("json",a),pending_sends:p},metadata:u,pendingWrites:f};void 0!==c&&(g.parentConfig={configurable:{thread_id:e,checkpoint_ns:t,checkpoint_id:c}}),yield g}}async put(e,t,r){let i=t$(t);delete i.pending_sends;let n=e.configurable?.thread_id,s=e.configurable?.checkpoint_ns??"";if(void 0===n)throw Error('Failed to put checkpoint. The passed RunnableConfig is missing a required "thread_id" field in its "configurable" property.');this.storage[n]||(this.storage[n]={}),this.storage[n][s]||(this.storage[n][s]={});let[,a]=this.serde.dumpsTyped(i),[,o]=this.serde.dumpsTyped(r);return this.storage[n][s][t.id]=[a,o,e.configurable?.checkpoint_id],{configurable:{thread_id:n,checkpoint_ns:s,checkpoint_id:t.id}}}async putWrites(e,t,r){let i=e.configurable?.thread_id,n=e.configurable?.checkpoint_ns,s=e.configurable?.checkpoint_id;if(void 0===i)throw Error('Failed to put writes. The passed RunnableConfig is missing a required "thread_id" field in its "configurable" property');if(void 0===s)throw Error('Failed to put writes. The passed RunnableConfig is missing a required "checkpoint_id" field in its "configurable" property.');let a=tL(i,n,s),o=this.writes[a];void 0===this.writes[a]&&(this.writes[a]={}),t.forEach(([e,t],i)=>{let[,n]=this.serde.dumpsTyped(t),s=[r,tD[e]||i],l=`${s[0]},${s[1]}`;s[1]>=0&&o&&l in o||(this.writes[a][l]=[r,e,n])})}}class tV extends Error{constructor(e){super(e),this.name="InvalidNamespaceError"}}class tq{async get(e,t){return(await this.batch([{namespace:e,key:t}]))[0]}async search(e,t={}){let{filter:r,limit:i=10,offset:n=0,query:s}=t;return(await this.batch([{namespacePrefix:e,filter:r,limit:i,offset:n,query:s}]))[0]}async put(e,t,r,i){(function(e){if(0===e.length)throw new tV("Namespace cannot be empty.");for(let t of e){if("string"!=typeof t)throw new tV(`Invalid namespace label '${t}' found in ${e}. Namespace labels must be strings, but got ${typeof t}.`);if(t.includes("."))throw new tV(`Invalid namespace label '${t}' found in ${e}. Namespace labels cannot contain periods ('.').`);if(""===t)throw new tV(`Namespace labels cannot be empty strings. Got ${t} in ${e}`)}if("langgraph"===e[0])throw new tV(`Root label for namespace cannot be "langgraph". Got: ${e}`)})(e),await this.batch([{namespace:e,key:t,value:r,index:i}])}async delete(e,t){await this.batch([{namespace:e,key:t,value:null}])}async listNamespaces(e={}){let{prefix:t,suffix:r,maxDepth:i,limit:n=100,offset:s=0}=e,a=[];return t&&a.push({matchType:"prefix",path:t}),r&&a.push({matchType:"suffix",path:r}),(await this.batch([{matchConditions:a.length?a:void 0,maxDepth:i,limit:n,offset:s}]))[0]}start(){}stop(){}}class tK extends tq{constructor(e){super(),Object.defineProperty(this,"store",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"nextKey",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"running",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"processingTask",{enumerable:!0,configurable:!0,writable:!0,value:null}),this.store=e}get isRunning(){return this.running}async batch(e){throw Error("The `batch` method is not implemented on `AsyncBatchedStore`.\n Instead, it calls the `batch` method on the wrapped store.\n If you are seeing this error, something is wrong.")}async get(e,t){return this.enqueueOperation({namespace:e,key:t})}async search(e,t){let{filter:r,limit:i=10,offset:n=0}=t||{};return this.enqueueOperation({namespacePrefix:e,filter:r,limit:i,offset:n})}async put(e,t,r){return this.enqueueOperation({namespace:e,key:t,value:r})}async delete(e,t){return this.enqueueOperation({namespace:e,key:t,value:null})}start(){this.running||(this.running=!0,this.processingTask=this.processBatchQueue())}async stop(){this.running=!1,this.processingTask&&await this.processingTask}enqueueOperation(e){return new Promise((t,r)=>{let i=this.nextKey;this.nextKey+=1,this.queue.set(i,{operation:e,resolve:t,reject:r})})}async processBatchQueue(){for(;this.running;){if(await new Promise(e=>{setTimeout(e,0)}),0===this.queue.size)continue;let e=new Map(this.queue);this.queue.clear();try{let t=Array.from(e.values()).map(({operation:e})=>e),r=await this.store.batch(t);e.forEach(({resolve:t},i)=>{let n=Array.from(e.keys()).indexOf(i);t(r[n])})}catch(t){e.forEach(({reject:e})=>{e(t)})}}}toJSON(){return{queue:this.queue,nextKey:this.nextKey,running:this.running,store:"[LangGraphStore]"}}}function tB(e){return null!=e&&!0===e.lg_is_channel}class tG{constructor(){Object.defineProperty(this,"ValueType",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UpdateType",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"lg_is_channel",{enumerable:!0,configurable:!0,writable:!0,value:!0})}consume(){return!1}}function tF(e,t){let r=Object.fromEntries(Object.entries(e).filter(([,e])=>tB(e))),i={};for(let e in r)if(Object.prototype.hasOwnProperty.call(r,e)){let n=t.channel_values[e];i[e]=r[e].fromCheckpoint(n)}return i}function tU(e,t,r){let i;if(void 0===t)i=e.channel_values;else for(let e of(i={},Object.keys(t)))try{i[e]=t[e].checkpoint()}catch(e){if(e.name===W.unminifiable_name);else throw e}return{v:1,id:ee(r),ts:new Date().toISOString(),channel_values:i,channel_versions:{...e.channel_versions},versions_seen:tx(e.versions_seen),pending_sends:e.pending_sends??[]}}class tH extends tG{constructor(e,t){super(),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"BinaryOperatorAggregate"}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"operator",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"initialValueFactory",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.operator=e,this.initialValueFactory=t,this.value=t?.()}fromCheckpoint(e){let t=new tH(this.operator,this.initialValueFactory);return e&&(t.value=e),t}update(e){let t=e;if(!t.length)return!1;for(let e of(void 0===this.value&&([this.value]=t,t=t.slice(1)),t))void 0!==this.value&&(this.value=this.operator(this.value,e));return!0}get(){if(void 0===this.value)throw new W;return this.value}checkpoint(){if(void 0===this.value)throw new W;return this.value}}class tz extends tG{constructor(){super(...arguments),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"LastValue"}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:[]})}fromCheckpoint(e){let t=new tz;return e&&(t.value=[e]),t}update(e){if(0===e.length)return!1;if(1!==e.length)throw new V("LastValue can only receive one value per step.",{lc_error_code:"INVALID_CONCURRENT_GRAPH_UPDATE"});return this.value=[e[e.length-1]],!0}get(){if(0===this.value.length)throw new W;return this.value[0]}checkpoint(){if(0===this.value.length)throw new W;return this.value[0]}}let tJ="__start__",tY="__end__",tX="__input__",tZ="__error__",tQ="__pregel_send",t0="__pregel_call",t1="__pregel_read",t2="__pregel_checkpointer",t5="__pregel_resuming",t4="__pregel_task_id",t8="__pregel_stream",t3="__pregel_scratchpad",t6="__pregel_previous",t9="checkpoint_map",t7="__interrupt__",re="__resume__",rt="__no_writes__",rr="__return__",ri="__previous__",rn="__pregel_runtime_placeholder__",rs="langsmith:hidden",ra="__self__",ro="__pregel_tasks",rl="__pregel_push",rc="__pregel_pull",ru="00000000-0000-0000-0000-000000000000",rh=[rs,tX,t7,re,tZ,rt,ro,tQ,t1,t2,t8,t5,t4,t0,"__pregel_resume_value",t3,t6,t9,"checkpoint_ns","checkpoint_id"];function rd(e){return void 0!==e&&"Send"===e.lg_name}class rp{constructor(e){Object.defineProperty(this,"lg_name",{enumerable:!0,configurable:!0,writable:!0,value:"Command"}),Object.defineProperty(this,"lc_direct_tool_output",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"graph",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"update",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"resume",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"goto",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.resume=e.resume,this.graph=e.graph,this.update=e.update,e.goto&&(this.goto=Array.isArray(e.goto)?e.goto:[e.goto])}_updateAsTuples(){return this.update&&"object"==typeof this.update&&!Array.isArray(this.update)?Object.entries(this.update):Array.isArray(this.update)&&this.update.every(e=>Array.isArray(e)&&2===e.length&&"string"==typeof e[0])?this.update:[["__root__",this.update]]}toJSON(){let e;return e="string"==typeof this.goto?this.goto:rd(this.goto)?this.goto.toJSON():this.goto.map(e=>"string"==typeof e?e:e.toJSON()),{update:this.update,resume:this.resume,goto:e}}}function rf(e){return"object"==typeof e&&!!e&&"Command"===e.lg_name}Object.defineProperty(rp,"PARENT",{enumerable:!0,configurable:!0,writable:!0,value:"__parent__"});class rg{constructor(e,t){Object.defineProperty(this,"runtime",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_promises",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"lg_is_managed_value",{enumerable:!0,configurable:!0,writable:!0,value:!0}),this.config=e}static async initialize(e,t){throw Error("Not implemented")}async promises(){return Promise.all(this._promises)}addPromise(e){this._promises.push(e)}}class rb extends Map{constructor(e){super(e?Array.from(e):void 0)}replaceRuntimeValues(e,t){if(!(0===this.size||!t||Array.from(this.values()).every(e=>!e.runtime))){if("object"!=typeof t||Array.isArray(t)){if("object"==typeof t&&"constructor"in t)for(let r of Object.getOwnPropertyNames(Object.getPrototypeOf(t)))try{let i=t[r];for(let[n,s]of this.entries())s.runtime&&s.call(e)===i&&(t[r]={[rn]:n})}catch(e){if(e.name!==TypeError.name)throw e}}else for(let[r,i]of Object.entries(t))for(let[n,s]of this.entries())s.runtime&&s.call(e)===i&&(t[r]={[rn]:n})}}replaceRuntimePlaceholders(e,t){if(!(0===this.size||!t||Array.from(this.values()).every(e=>!e.runtime))){if("object"!=typeof t||Array.isArray(t)){if("object"==typeof t&&"constructor"in t)for(let r of Object.getOwnPropertyNames(Object.getPrototypeOf(t)))try{let i=t[r];if("object"==typeof i&&null!==i&&rn in i){let n=this.get(i[rn]);n&&(t[r]=n.call(e))}}catch(e){if(e.name!==TypeError.name)throw e}}else for(let[r,i]of Object.entries(t))if("object"==typeof i&&null!==i&&rn in i){let n=i[rn];"string"==typeof n&&(t[r]=this.get(n)?.call(e))}}}}function rm(e){return"object"==typeof e&&!!e&&"cls"in e&&"params"in e}class ry extends rg{call(){}static async initialize(e,t){return Promise.resolve(new ry(e))}}class rw{constructor(e){Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"AnnotationRoot"}),Object.defineProperty(this,"spec",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.spec=e}}let rv=function(e){return rm(e)?e:e?r_(e):new tz};function r_(e){return"object"==typeof e&&e&&"reducer"in e&&e.reducer?new tH(e.reducer,e.default):"object"==typeof e&&e&&"value"in e&&e.value?new tH(e.value,e.default):new tz}rv.Root=e=>new rw(e);var rk=r(71399),rO=r(79159),rj=r(8199);let rP=["tags","metadata","callbacks","configurable"],rE=["tags","metadata","callbacks","runName","maxConcurrency","recursionLimit","configurable","runId","outputKeys","streamMode","store","writer","interruptBefore","interruptAfter","signal"];function rS(...e){let t={tags:[],metadata:{},callbacks:void 0,recursionLimit:25,configurable:{}},r=S.Nx.getRunnableConfig();if(void 0!==r){for(let[e,i]of Object.entries(r))if(void 0!==i){if(rP.includes(e)){let r;r=Array.isArray(i)?[...i]:"object"==typeof i?"callbacks"===e&&"copy"in i&&"function"==typeof i.copy?i.copy():{...i}:i,t[e]=r}else t[e]=i}}for(let r of e)if(void 0!==r)for(let[e,i]of Object.entries(r))void 0!==i&&rE.includes(e)&&(t[e]=i);for(let[e,r]of Object.entries(t.configurable))t.metadata=t.metadata??{},e.startsWith("__")||"string"!=typeof r&&"number"!=typeof r&&"boolean"!=typeof r||e in t.metadata||(t.metadata[e]=r);return t}class rA extends rk.YN{constructor(e){super(),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langgraph"]}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"trace",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"recurse",{enumerable:!0,configurable:!0,writable:!0,value:!0}),this.name=e.name??e.func.name,this.func=e.func,this.config=e.tags?{tags:e.tags}:void 0,this.trace=e.trace??this.trace,this.recurse=e.recurse??this.recurse}async _tracedInvoke(e,t,r){return new Promise((i,n)=>{let s=(0,rk.tn)(t,{callbacks:r?.getChild()});S.Nx.runWithConfig(s,async()=>{try{let t=await this.func(e,s);i(t)}catch(e){n(e)}})})}async invoke(e,t){let r;let i=rS(t),n=(0,rk.SV)(this.config,i);return(r=this.trace?await this._callWithConfig(this._tracedInvoke,e,n):await S.Nx.runWithConfig(n,async()=>this.func(e,n)),rk.YN.isRunnable(r)&&this.recurse)?await S.Nx.runWithConfig(n,async()=>r.invoke(e,n)):r}}function*rN(e,t){if(void 0===t)yield*e;else for(let r of e)yield[t,r]}async function rC(e){let t=[];for await(let r of(await e))t.push(r);return t}function rx(e){let t=[];for(let r of e)t.push(r);return t}function rT(e,t){return e?"configurable"in e?{...e,configurable:{...e.configurable,...t}}:{...e,configurable:t}:{configurable:t}}Symbol.for("LG_SKIP_WRITE");let r$={[Symbol.for("LG_PASSTHROUGH")]:!0};function rR(e){return"object"==typeof e&&e?.[Symbol.for("LG_PASSTHROUGH")]!==void 0}let rM=Symbol("IS_WRITER");class rI extends rA{constructor(e,t){super({writes:e,name:`ChannelWrite<${e.map(e=>rd(e)?e.node:"channel"in e?e.channel:"...").join(",")}>`,tags:t,func:async(e,t)=>this._write(e,t??{})}),Object.defineProperty(this,"writes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.writes=e}async _write(e,t){let r=this.writes.map(t=>rL(t)&&rR(t.value)?{mapper:t.mapper,value:e}:rD(t)&&rR(t.value)?{channel:t.channel,value:e,skipNone:t.skipNone,mapper:t.mapper}:t);return await rI.doWrite(t,r),e}static async doWrite(e,t){for(let e of t){if(rD(e)){if(e.channel===ro)throw new V("Cannot write to the reserved channel TASKS");if(rR(e.value))throw new V("PASSTHROUGH value must be replaced")}if(rL(e)&&rR(e.value))throw new V("PASSTHROUGH value must be replaced")}let r=[];for(let i of t)if(rd(i))r.push([ro,i]);else if(rL(i)){let t=await i.mapper.invoke(i.value,e);null!=t&&t.length>0&&r.push(...t)}else if(rD(i)){let t=void 0!==i.mapper?await i.mapper.invoke(i.value,e):i.value;if("object"==typeof t&&t?.[Symbol.for("LG_SKIP_WRITE")]!==void 0||i.skipNone&&void 0===t)continue;r.push([i.channel,t])}else throw Error(`Invalid write entry: ${JSON.stringify(i)}`);(e.configurable?.[tQ])(r)}static isWriter(e){return e instanceof rI||rM in e&&!!e[rM]}static registerWriter(e){return Object.defineProperty(e,rM,{value:!0})}}function rD(e){return void 0!==e&&"string"==typeof e.channel}function rL(e){return void 0!==e&&!rD(e)&&rk.YN.isRunnable(e.mapper)}class rW extends rA{constructor(e,t,r=!1){super({func:(e,t)=>rW.doRead(t,this.channel,this.fresh,this.mapper)}),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"ChannelRead"}),Object.defineProperty(this,"channel",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fresh",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"mapper",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.fresh=r,this.mapper=t,this.channel=e,this.name=Array.isArray(e)?`ChannelRead<${e.join(",")}>`:`ChannelRead<${e}>`}static doRead(e,t,r,i){let n=e.configurable?.[t1];if(!n)throw Error(`Runnable ${this} is not configured with a read function. Make sure to call in the context of a Pregel process`);return i?i(n(t,r)):n(t,r)}}let rV=new rk.kI;class rq extends rk.fJ{constructor(e){let{channels:t,triggers:r,mapper:i,writers:n,bound:s,kwargs:a,metadata:o,retryPolicy:l,tags:c,subgraphs:u,ends:h}=e,d=[...e.config?.tags?e.config.tags:[],...c??[]];super({...e,bound:e.bound??rV,config:{...e.config?e.config:{},tags:d}}),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"PregelNode"}),Object.defineProperty(this,"channels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"triggers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"mapper",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"writers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:rV}),Object.defineProperty(this,"kwargs",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"retryPolicy",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"subgraphs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"ends",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.channels=t,this.triggers=r,this.mapper=i,this.writers=n??this.writers,this.bound=s??this.bound,this.kwargs=a??this.kwargs,this.metadata=o??this.metadata,this.tags=d,this.retryPolicy=l,this.subgraphs=u,this.ends=h}getWriters(){let e=[...this.writers];for(;e.length>1&&e[e.length-1]instanceof rI&&e[e.length-2]instanceof rI;){let t=e.slice(-2),r=t[0].writes.concat(t[1].writes);e[e.length-2]=new rI(r,t[0].config?.tags),e.pop()}return e}getNode(){let e=this.getWriters();if(this.bound!==rV||0!==e.length)return this.bound===rV&&1===e.length?e[0]:this.bound===rV?new rk.zZ({first:e[0],middle:e.slice(1,e.length-1),last:e[e.length-1],omitSequenceTags:!0}):e.length>0?new rk.zZ({first:this.bound,middle:e.slice(0,e.length-1),last:e[e.length-1],omitSequenceTags:!0}):this.bound}join(e){if(!Array.isArray(e))throw Error("channels must be a list");if("object"!=typeof this.channels)throw Error("all channels must be named when using .join()");return new rq({channels:{...this.channels,...Object.fromEntries(e.map(e=>[e,e]))},triggers:this.triggers,mapper:this.mapper,writers:this.writers,bound:this.bound,kwargs:this.kwargs,config:this.config,retryPolicy:this.retryPolicy})}pipe(e){return new rq(rI.isWriter(e)?{channels:this.channels,triggers:this.triggers,mapper:this.mapper,writers:[...this.writers,e],bound:this.bound,config:this.config,kwargs:this.kwargs,retryPolicy:this.retryPolicy}:this.bound===rV?{channels:this.channels,triggers:this.triggers,mapper:this.mapper,writers:this.writers,bound:(0,rk.Bp)(e),config:this.config,kwargs:this.kwargs,retryPolicy:this.retryPolicy}:{channels:this.channels,triggers:this.triggers,mapper:this.mapper,writers:this.writers,bound:this.bound.pipe(e),config:this.config,kwargs:this.kwargs,retryPolicy:this.retryPolicy})}}class rK extends Error{constructor(e){super(e),this.name="GraphValidationError"}}function rB(e,t){if(Array.isArray(e)){for(let r of e)if(!(r in t))throw Error(`Key ${String(r)} not found in channels`)}else if(!(e in t))throw Error(`Key ${String(e)} not found in channels`)}function rG(e,t,r=!0,i=!1){try{return e[t].get()}catch(e){if(e.name===W.unminifiable_name){if(i)return e;if(r)return null}throw e}}function rF(e,t,r=!0){if(!Array.isArray(t))return rG(e,t);{let i={};for(let n of t)try{i[n]=rG(e,n,!r)}catch(e){if(e.name===W.unminifiable_name)continue}return i}}function*rU(e,t,r){Array.isArray(e)?(!0===t||t.find(([t,r])=>e.includes(t)))&&(yield rF(r,e)):(!0===t||t.some(([t,r])=>t===e))&&(yield rG(r,e))}function*rH(e,t,r){let i;let n=t.filter(([e,t])=>(void 0===e.config||!e.config.tags?.includes(rs))&&t[0][0]!==tZ&&t[0][0]!==t7);if(!n.length)return;i=n.some(([e])=>e.writes.some(([e,t])=>e===rr))?n.flatMap(([e])=>e.writes.filter(([e,t])=>e===rr).map(([t,r])=>[e.name,r])):Array.isArray(e)?n.filter(([t])=>t.writes.some(([t])=>e.includes(t))).map(([t])=>[t.name,Object.fromEntries(t.writes.filter(([t])=>e.includes(t)))]):n.flatMap(([t])=>t.writes.filter(([t,r])=>t===e).map(([e,r])=>[t.name,r]));let s=Object.fromEntries(n.map(([e])=>[e.name,[]]));for(let[e,t]of i)s[e].push(t);for(let[e,t]of Object.entries(s))0===t.length?delete s[e]:1===t.length&&(s[e]=t[0]);r&&(s.__metadata__={cached:r}),yield s}function rz(e){return"lg_is_pregel"in e&&!0===e.lg_is_pregel}function rJ(e){let t=[e];for(let e of t){if(rz(e))return e;"steps"in e&&Array.isArray(e.steps)&&t.push(...e.steps)}}let rY={blue:{start:"\x1b[34m",end:"\x1b[0m"},green:{start:"\x1b[32m",end:"\x1b[0m"},yellow:{start:"\x1b[33;1m",end:"\x1b[0m"}},rX=(e,t)=>`${e.start}${t}${e.end}`;function*rZ(e,t){let r=new Date().toISOString();for(let{id:i,name:n,input:s,config:a,triggers:o,writes:l}of t){if(a?.tags?.includes(rs))continue;let t=l.filter(([e,t])=>e===i&&t===t7).map(([,e])=>e);yield{type:"task",timestamp:r,step:e,payload:{id:i,name:n,input:s,triggers:o,interrupts:t}}}}function rQ(e,t,r){return e.map(e=>{let i=t.find(([t,r])=>t===e.id&&r===tZ)?.[2],n=t.filter(([t,r])=>t===e.id&&r===t7).map(([,,e])=>e);return i?{id:e.id,name:e.name,path:e.path,error:i,interrupts:n}:{id:e.id,name:e.name,path:e.path,interrupts:n,state:r?.[e.id]}})}function r0(e,t){let r=t.length;console.log([`${rX(rY.blue,`[${e}:tasks]`)}`,`\x1b[1m Starting step ${e} with ${r} task${1===r?"":"s"}:\x1b[0m
`,t.map(e=>`- ${rX(rY.green,String(e.name))} -> ${JSON.stringify(e.input,null,2)}`).join("\n")].join(""))}class r1{constructor({func:e,name:t,input:r,retry:i,callbacks:n}){Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"input",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"retry",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"callbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"__lg_type",{enumerable:!0,configurable:!0,writable:!0,value:"call"}),this.func=e,this.name=t,this.input=r,this.retry=i,this.callbacks=n}}function r2(e){let t;let r=Object.values(e),i=r.length>0?typeof r[0]:void 0;return"number"===i?t=0:"string"===i&&(t=""),t}function r5(e,t){if(!(Object.keys(e).length>0))return t;{let r=r2(t);return Object.fromEntries(Object.entries(t).filter(([t,i])=>i>(e[t]??r)))}}function r4(e,t){return null===e?{configurable:t}:e?.configurable===void 0?{...e,configurable:t}:{...e,configurable:{...e.configurable,...t}}}function r8(e,t){let r=t?.parents??{};return Object.keys(r).length>0?r4(e,{[t9]:{...r,[e.configurable?.checkpoint_ns??""]:e.configurable?.checkpoint_id}}):e}let r3=e=>void 0!==e?e+1:1;function r6(e,t,r){let i;let n=Object.values(e.channel_versions),s=n.length>0?typeof n[0]:void 0;"number"===s?i=0:"string"===s&&(i="");let a=e.versions_seen[t7]??{},o=Object.entries(e.channel_versions).some(([e,t])=>t>(a[e]??i)),l=r.some(e=>"*"===t?!e.config?.tags?.includes(rs):t.includes(e.name));return o&&l}function r9(e,t,r,i,n,s,a=!1){let o,l=[],c=new Set;if(Array.isArray(s))l=s.filter(e=>i.get(e)),c=new Set((s=s.filter(e=>!i.get(e))).filter(e=>n.writes.some(([t,r])=>t===e)));else{for(let[e]of n.writes)if(e===s){c=new Set([e]);break}c=c||new Set}if(a&&c.size>0){let e=Object.fromEntries(Object.entries(r).filter(([e,t])=>c.has(e))),i=tU(t,e,-1),a=tF(e,i);it(t$(i),a,[n]),o=rF({...r,...a},s)}else o=rF(r,s);if(l.length>0)for(let t of l){let r=i.get(t);if(r){let i=r.call(e);o[t]=i}}return o}function r7(e,t,r,i,n){for(let[t,s]of n)if(t===ro&&null!=s){if(!rd(s))throw new V(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(s)}`);if(!(s.node in r))throw new V(`Invalid node name "${s.node}" in Send packet`);i.replaceRuntimeValues(e,s.args)}t(n)}let ie=new Set([rt,rl,re,t7,rr,tZ]);function it(e,t,r,i){let n;r.sort((e,t)=>{let r=e.path?.slice(0,3)||[],i=t.path?.slice(0,3)||[];for(let e=0;e<Math.min(r.length,i.length);e+=1){if(r[e]<i[e])return -1;if(r[e]>i[e])return 1}return r.length-i.length});let s=r.some(e=>e.triggers.length>0),a=Object.fromEntries(Object.entries(t).filter(([e,t])=>tB(t)));for(let t of r)for(let r of(void 0===e.versions_seen[t.name]&&(e.versions_seen[t.name]={}),t.triggers))r in e.channel_versions&&(e.versions_seen[t.name][r]=e.channel_versions[r]);for(let t of(Object.keys(e.channel_versions).length>0&&(n=tI(...Object.values(e.channel_versions))),new Set(r.flatMap(e=>e.triggers).filter(e=>!rh.includes(e)))))t in a&&a[t].consume()&&void 0!==i&&(e.channel_versions[t]=i(n,a[t]));e.pending_sends?.length&&s&&(e.pending_sends=[]);let o={},l={};for(let t of r)for(let[r,i]of t.writes)ie.has(r)||(r===ro?e.pending_sends.push({node:i.node,args:i.args}):r in a?r in o?o[r].push(i):o[r]=[i]:r in l?l[r].push(i):l[r]=[i]);n=void 0,Object.keys(e.channel_versions).length>0&&(n=tI(...Object.values(e.channel_versions)));let c=new Set;for(let[t,r]of Object.entries(o))if(t in a){let s;try{s=a[t].update(r)}catch(e){if(e.name===V.unminifiable_name){let i=new V(`Invalid update for channel "${t}" with values ${JSON.stringify(r)}: ${e.message}`);throw i.lc_error_code=e.lc_error_code,i}throw e}s&&void 0!==i&&(e.channel_versions[t]=i(n,a[t])),c.add(t)}if(s)for(let t of Object.keys(a))!c.has(t)&&a[t].update([])&&void 0!==i&&(e.channel_versions[t]=i(n,a[t]));return l}function ir(e,t,r,i,n,s,a,o){let l={};for(let c=0;c<e.pending_sends.length;c+=1){let u=ii([rl,c],e,t,r,i,n,s,a,o);void 0!==u&&(l[u.id]=u)}for(let c of Object.keys(r)){let u=ii([rc,c],e,t,r,i,n,s,a,o);void 0!==u&&(l[u.id]=u)}return l}function ii(e,t,r,i,n,s,a,o,l){var c;let{step:u,checkpointer:h,manager:d}=l,p=a.configurable??{},f=p.checkpoint_ns??"";if(e[0]===rl&&"object"==typeof(c=e[e.length-1])&&null!==c&&"__lg_type"in c&&"call"===c.__lg_type){let c=e[e.length-1],g=function(e,t){let r=new rA({func:e=>t(...e),name:e,trace:!1,recurse:!1});return new rk.zZ({name:e,first:r,last:new rI([{channel:rr,value:r$}],[rs])})}(c.name,c.func),b=[rl],m=""===f?c.name:`${f}|${c.name}`,y=et(JSON.stringify([m,u.toString(),c.name,rl,e[1],e[2]]),t.id),w=`${m}:${y}`,v={langgraph_step:u,langgraph_node:c.name,langgraph_triggers:b,langgraph_path:e.slice(0,3),langgraph_checkpoint_ns:w};if(!o)return{id:y,name:c.name,interrupts:[],path:e.slice(0,3)};{let o=[];return{name:c.name,input:c.input,proc:g,writes:o,config:(0,rk.tn)((0,rk.SV)(a,{metadata:v,store:l.store??a.store}),{runName:c.name,callbacks:d?.getChild(`graph:step:${u}`),configurable:{[t4]:y,[tQ]:e=>r7(u,e=>o.push(...e),i,s,e),[t1]:(r,i=!1)=>r9(u,t,n,s,{name:c.name,writes:o,triggers:b,path:e.slice(0,3)},r,i),[t2]:h??p[t2],[t9]:{...p[t9],[f]:t.id},[t3]:is([...r||[],...(p[t3]?.resume||[]).map(e=>[y,re,e])],y),[t6]:t.channel_values[ri],checkpoint_id:void 0,checkpoint_ns:w}}),triggers:b,retry_policy:c.retry,id:y,path:e.slice(0,3),writers:[]}}}if(e[0]===rl){let c="number"==typeof e[1]?e[1]:parseInt(e[1],10);if(c>=t.pending_sends.length)return;let g=t.pending_sends[c];if(!(null!=g&&"string"==typeof g.node&&void 0!==g.args)){console.warn(`Ignoring invalid packet ${JSON.stringify(g)} in pending sends.`);return}if(!(g.node in i)){console.warn(`Ignoring unknown node name ${g.node} in pending sends.`);return}let b=[rl],m=""===f?g.node:`${f}|${g.node}`,y=et(JSON.stringify([m,u.toString(),g.node,rl,c.toString()]),t.id),w=`${m}:${y}`,v={langgraph_step:u,langgraph_node:g.node,langgraph_triggers:b,langgraph_path:e,langgraph_checkpoint_ns:w};if(!o)return{id:y,name:g.node,interrupts:[],path:e};{let o=i[g.node],c=o.getNode();if(void 0!==c){s.replaceRuntimePlaceholders(u,g.args),void 0!==o.metadata&&(v={...v,...o.metadata});let m=[];return{name:g.node,input:g.args,proc:c,subgraphs:o.subgraphs,writes:m,config:(0,rk.tn)((0,rk.SV)(a,{metadata:v,tags:o.tags,store:l.store??a.store}),{runName:g.node,callbacks:d?.getChild(`graph:step:${u}`),configurable:{[t4]:y,[tQ]:e=>r7(u,e=>m.push(...e),i,s,e),[t1]:(r,i=!1)=>r9(u,t,n,s,{name:g.node,writes:m,triggers:b,path:e},r,i),[t2]:h??p[t2],[t9]:{...p[t9],[f]:t.id},[t3]:is([...r||[],...(p[t3]?.resume||[]).map(e=>[y,re,e])],y),[t6]:t.channel_values[ri],checkpoint_id:void 0,checkpoint_ns:w}}),triggers:b,retry_policy:o.retryPolicy,id:y,path:e,writers:o.getWriters()}}}}else if(e[0]===rc){let c=e[1].toString(),g=i[c];if(void 0===g)return;let b=r2(t.channel_versions);if(void 0===b)return;let m=t.versions_seen[c]??{},y=g.triggers.filter(e=>{let r=rG(n,e,!1,!0);return!(r instanceof Error&&r.name===W.unminifiable_name)&&(t.channel_versions[e]??b)>(m[e]??b)}).sort();if(y.length>0){let b=function(e,t,r,i,n){let s;if("object"!=typeof t.channels||Array.isArray(t.channels)){if(Array.isArray(t.channels)){let e=!1;for(let r of t.channels)try{s=rG(i,r,!1),e=!0;break}catch(e){if(e.name===W.unminifiable_name)continue;throw e}if(!e)return}else throw Error(`Invalid channels type, expected list or dict, got ${t.channels}`)}else for(let[n,a]of(s={},Object.entries(t.channels)))if(t.triggers.includes(a))try{s[n]=rG(i,a,!1)}catch(e){if(e.name===W.unminifiable_name)return;throw e}else if(a in i)try{s[n]=rG(i,a,!0)}catch(e){if(e.name===W.unminifiable_name)continue;throw e}else s[n]=r.get(n)?.call(e);return n&&void 0!==t.mapper&&(s=t.mapper(s)),s}(u,g,s,n,o);if(void 0===b)return;let m=""===f?c:`${f}|${c}`,w=et(JSON.stringify([m,u.toString(),c,rc,y]),t.id),v={langgraph_step:u,langgraph_node:c,langgraph_triggers:y,langgraph_path:e,langgraph_checkpoint_ns:`${m}:${w}`};if(!o)return{id:w,name:c,interrupts:[],path:e};{let o=g.getNode();if(void 0!==o){void 0!==g.metadata&&(v={...v,...g.metadata});let _=[],k=`${m}:${w}`;return{name:c,input:b,proc:o,subgraphs:g.subgraphs,writes:_,config:(0,rk.tn)((0,rk.SV)(a,{metadata:v,tags:g.tags,store:l.store??a.store}),{runName:c,callbacks:d?.getChild(`graph:step:${u}`),configurable:{[t4]:w,[tQ]:e=>r7(u,e=>{_.push(...e)},i,s,e),[t1]:(r,i=!1)=>r9(u,t,n,s,{name:c,writes:_,triggers:y,path:e},r,i),[t2]:h??p[t2],[t9]:{...p[t9],[f]:t.id},[t3]:is([...r||[],...(p[t3]?.resume||[]).map(e=>[w,re,e])],w),[t6]:t.channel_values[ri],checkpoint_id:void 0,checkpoint_ns:k}}),triggers:y,retry_policy:g.retryPolicy,id:w,path:e,writers:g.getWriters()}}}}}}function is(e,t){return{callCounter:0,interruptCounter:-1,resume:e.filter(([e,r])=>e===t&&r===re).flatMap(([e,t,r])=>r),nullResume:e.find(([e,t])=>e===ru&&t===re)?.[2]}}class ia extends e7.IterableReadableStream{get closed(){return this._closed}constructor(e){let t;let r=new Promise(e=>{t=e});super({start:e=>{t(e)}}),Object.defineProperty(this,"modes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"passthroughFn",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_closed",{enumerable:!0,configurable:!0,writable:!0,value:!1}),r.then(e=>{this.controller=e}),this.passthroughFn=e.passthroughFn,this.modes=e.modes}push(e){this.passthroughFn?.(e),this.controller.enqueue(e)}close(){try{this.controller.close()}catch(e){}finally{this._closed=!0}}error(e){this.controller.error(e)}}let io=Symbol.for("INPUT_DONE"),il=Symbol.for("INPUT_RESUMING");class ic{constructor(e){Object.defineProperty(this,"input",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"output",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointerGetNextVersion",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"channels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"managed",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpoint",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointConfig",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointMetadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointNamespace",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointPendingWrites",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"checkpointPreviousVersions",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"step",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"stop",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputKeys",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"streamKeys",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"nodes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"skipDoneTasks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"prevCheckpointConfig",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:"pending"}),Object.defineProperty(this,"tasks",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"stream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"checkpointerPromises",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"isNested",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_checkpointerChainedPromise",{enumerable:!0,configurable:!0,writable:!0,value:Promise.resolve()}),Object.defineProperty(this,"store",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"manager",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"interruptAfter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"interruptBefore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"toInterrupt",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"debug",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.input=e.input,this.checkpointer=e.checkpointer,void 0!==this.checkpointer?this.checkpointerGetNextVersion=this.checkpointer.getNextVersion.bind(this.checkpointer):this.checkpointerGetNextVersion=r3,this.checkpoint=e.checkpoint,this.checkpointMetadata=e.checkpointMetadata,this.checkpointPreviousVersions=e.checkpointPreviousVersions,this.channels=e.channels,this.managed=e.managed,this.checkpointPendingWrites=e.checkpointPendingWrites,this.step=e.step,this.stop=e.stop,this.config=e.config,this.checkpointConfig=e.checkpointConfig,this.isNested=e.isNested,this.manager=e.manager,this.outputKeys=e.outputKeys,this.streamKeys=e.streamKeys,this.nodes=e.nodes,this.skipDoneTasks=e.skipDoneTasks,this.store=e.store,this.stream=e.stream,this.checkpointNamespace=e.checkpointNamespace,this.prevCheckpointConfig=e.prevCheckpointConfig,this.interruptAfter=e.interruptAfter,this.interruptBefore=e.interruptBefore,this.debug=e.debug}static async initialize(e){let{config:t,stream:r}=e,{checkSubgraphs:i=!0}=e;void 0!==r&&t.configurable?.[t8]!==void 0&&(r=function(...e){return new ia({passthroughFn:t=>{for(let r of e)r.modes.has(t[1])&&r.push(t)},modes:new Set(e.flatMap(e=>Array.from(e.modes)))})}(r,t.configurable[t8]));let n=!t.configurable||!("checkpoint_id"in t.configurable),s=t1 in(t.configurable??{});s||t.configurable?.checkpoint_ns===void 0||t.configurable?.checkpoint_ns===""||(t=r4(t,{checkpoint_ns:"",checkpoint_id:void 0}));let a=t;t.configurable?.[t9]!==void 0&&t.configurable?.[t9]?.[t.configurable?.checkpoint_ns]&&(a=r4(t,{checkpoint_id:t.configurable[t9][t.configurable?.checkpoint_ns]}));let o=t.configurable?.checkpoint_ns?.split("|")??[],l=await e.checkpointer?.getTuple(a)??{config:t,checkpoint:tT(),metadata:{source:"input",step:-2,writes:null,parents:{}},pendingWrites:[]};a={...t,...l.config,configurable:{checkpoint_ns:"",...t.configurable,...l.config.configurable}};let c=l.parentConfig,u=t$(l.checkpoint),h={...l.metadata},d=l.pendingWrites??[],p=tF(e.channelSpecs,u),f=(h.step??0)+1,g=f+(t.recursionLimit??25)+1,b={...u.channel_versions},m=e.store?new tK(e.store):void 0;if(m&&m.start(),i&&s&&void 0!==e.checkpointer){if(B().has(t.configurable?.checkpoint_ns))throw new q('Detected the same subgraph called multiple times by the same node.\nThis is not allowed if checkpointing is enabled.\n\nYou can disable checkpointing for a subgraph by compiling it with ".compile({ checkpointer: false });"',{lc_error_code:"MULTIPLE_SUBGRAPHS"});B().add(t.configurable?.checkpoint_ns)}return new ic({input:e.input,config:t,checkpointer:e.checkpointer,checkpoint:u,checkpointMetadata:h,checkpointConfig:a,prevCheckpointConfig:c,checkpointNamespace:o,channels:p,managed:e.managed,isNested:s,manager:e.manager,skipDoneTasks:n,step:f,stop:g,checkpointPreviousVersions:b,checkpointPendingWrites:d,outputKeys:e.outputKeys??[],streamKeys:e.streamKeys??[],nodes:e.nodes,stream:r,store:m,interruptAfter:e.interruptAfter,interruptBefore:e.interruptBefore,debug:e.debug})}_checkpointerPutAfterPrevious(e){this._checkpointerChainedPromise=this._checkpointerChainedPromise.then(()=>this.checkpointer?.put(e.config,e.checkpoint,e.metadata,e.newVersions)),this.checkpointerPromises.push(this._checkpointerChainedPromise)}async updateManagedValues(e,t){let r=this.managed.get(e);r&&"update"in r&&"function"==typeof r.update&&await r.update(t)}putWrites(e,t){let r=t;if(0===r.length)return;for(let[t,i]of(r.every(([e])=>e in tD)&&(r=Array.from(new Map(r.map(e=>[e[0],e])).values())),r)){let r=this.checkpointPendingWrites.findIndex(r=>r[0]===e&&r[1]===t);t in tD&&-1!==r?this.checkpointPendingWrites[r]=[e,t,i]:this.checkpointPendingWrites.push([e,t,i])}let i=this.checkpointer?.putWrites({...this.checkpointConfig,configurable:{...this.checkpointConfig.configurable,checkpoint_ns:this.config.configurable?.checkpoint_ns??"",checkpoint_id:this.checkpoint.id}},r,e);void 0!==i&&this.checkpointerPromises.push(i),this.tasks&&this._outputWrites(e,r)}_outputWrites(e,t,r=!1){let i=this.tasks[e];if(void 0!==i){if(void 0!==i.config&&(i.config.tags??[]).includes(rs))return;t.length>0&&t[0][0]!==tZ&&t[0][0]!==t7&&this._emit(rx(rN(rH(this.outputKeys,[[i,t]],r),"updates"))),r||this._emit(rx(rN(function*(e,t,r){let i=new Date().toISOString();for(let[{id:n,name:s,config:a},o]of t)a?.tags?.includes(rs)||(yield{type:"task_result",timestamp:i,step:e,payload:{id:n,name:s,result:o.filter(([e])=>Array.isArray(r)?r.includes(e):e===r),interrupts:o.filter(e=>e[0]===t7).map(e=>e[1])}})}(this.step,[[i,t]],this.streamKeys),"debug")))}}async tick(e){this.store&&!this.store.isRunning&&this.store?.start();let{inputKeys:t=[]}=e;if("pending"!==this.status)throw Error(`Cannot tick when status is no longer "pending". Current status: "${this.status}"`);if([io,il].includes(this.input)){if(!Object.values(this.tasks).every(e=>e.writes.filter(([e])=>!(e in tD)).length>0))return!1;{let e=Object.values(this.tasks).flatMap(e=>e.writes);for(let[e,t]of Object.entries(it(this.checkpoint,this.channels,Object.values(this.tasks),this.checkpointerGetNextVersion)))await this.updateManagedValues(e,t);let t=await rC(rN(rU(this.outputKeys,e,this.channels),"values"));if(this._emit(t),this.checkpointPendingWrites=[],await this._putCheckpoint({source:"loop",writes:rH(this.outputKeys,Object.values(this.tasks).map(e=>[e,e.writes])).next().value??null}),r6(this.checkpoint,this.interruptAfter,Object.values(this.tasks)))throw this.status="interrupt_after",new $}}else await this._first(t);if(this.step>this.stop)return this.status="out_of_steps",!1;let r=ir(this.checkpoint,this.checkpointPendingWrites,this.nodes,this.channels,this.managed,this.config,!0,{step:this.step,checkpointer:this.checkpointer,isResuming:this.input===il,manager:this.manager,store:this.store,stream:this.stream});if(this.tasks=r,this.checkpointer&&this._emit(await rC(rN(function*(e,t,r,i,n,s,a,o){function l(e){let t={};return null!=e.callbacks&&(t.callbacks=e.callbacks),null!=e.configurable&&(t.configurable=e.configurable),null!=e.maxConcurrency&&(t.max_concurrency=e.maxConcurrency),null!=e.metadata&&(t.metadata=e.metadata),null!=e.recursionLimit&&(t.recursion_limit=e.recursionLimit),null!=e.runId&&(t.run_id=e.runId),null!=e.runName&&(t.run_name=e.runName),null!=e.tags&&(t.tags=e.tags),t}let c=t.configurable?.checkpoint_ns,u={};for(let e of s){if(!(e.subgraphs?.length?e.subgraphs:[e.proc]).find(rJ))continue;let r=`${e.name}:${e.id}`;c&&(r=`${c}|${r}`),u[e.id]={configurable:{thread_id:t.configurable?.thread_id,checkpoint_ns:r}}}let h=new Date().toISOString();yield{type:"checkpoint",timestamp:h,step:e,payload:{config:l(t),values:rF(r,i),metadata:n,next:s.map(e=>e.name),tasks:rQ(s,a,u),parentConfig:o?l(o):void 0}}}(this.step-1,this.checkpointConfig,this.channels,this.streamKeys,this.checkpointMetadata,Object.values(this.tasks),this.checkpointPendingWrites,this.prevCheckpointConfig),"debug"))),0===Object.values(this.tasks).length)return this.status="done",!1;if(this.skipDoneTasks&&this.checkpointPendingWrites.length>0){for(let[e,t,r]of this.checkpointPendingWrites){if(t===tZ||t===t7||t===re)continue;let i=Object.values(this.tasks).find(t=>t.id===e);i&&i.writes.push([t,r])}for(let e of Object.values(this.tasks))e.writes.length>0&&this._outputWrites(e.id,e.writes,!0)}if(Object.values(this.tasks).every(e=>e.writes.length>0))return this.tick({inputKeys:t});if(r6(this.checkpoint,this.interruptBefore,Object.values(this.tasks)))throw this.status="interrupt_before",new $;let i=await rC(rN(rZ(this.step,Object.values(this.tasks)),"debug"));return this._emit(i),!0}async finishAndHandleError(e){let t=this._suppressInterrupt(e);if((t||void 0===e)&&(this.output=rF(this.channels,this.outputKeys)),t){if(void 0!==this.tasks&&this.checkpointPendingWrites.length>0&&Object.values(this.tasks).some(e=>e.writes.length>0)){for(let[e,t]of Object.entries(it(this.checkpoint,this.channels,Object.values(this.tasks),this.checkpointerGetNextVersion)))await this.updateManagedValues(e,t);this._emit(rx(rN(rU(this.outputKeys,Object.values(this.tasks).flatMap(e=>e.writes),this.channels),"values")))}this._emit([["updates",{[t7]:e.interrupts}]])}return t}acceptPush(e,t,r){if(this.interruptAfter?.length>0&&r6(this.checkpoint,this.interruptAfter,[e])){this.toInterrupt.push(e);return}let i=ii([rl,e.path??[],t,e.id,r],this.checkpoint,this.checkpointPendingWrites,this.nodes,this.channels,this.managed,this.config,!0,{step:this.step,checkpointer:this.checkpointer,manager:this.manager,store:this.store,stream:this.stream});if(i){if(this.interruptBefore?.length>0&&r6(this.checkpoint,this.interruptBefore,[i])){this.toInterrupt.push(i);return}return this._emit(rx(rN(rZ(this.step,[i]),"debug"))),this.debug&&r0(this.step,[i]),this.tasks[i.id]=i,this.skipDoneTasks&&this._matchWrites({[i.id]:i}),i}}_suppressInterrupt(e){return D(e)&&!this.isNested}async _first(e){let{configurable:t}=this.config,r=0!==Object.keys(this.checkpoint.channel_versions).length&&(this.config.configurable?.[t5]!==void 0||null===this.input||rf(this.input)),i=t?.[t3];if(i&&void 0!==i.nullResume&&this.putWrites(ru,[[re,i.nullResume]]),rf(this.input)){if(null!=this.input.resume&&null==this.checkpointer)throw Error("Cannot use Command(resume=...) without checkpointer");let e={};for(let[t,r,i]of function*(e,t){if(e.graph===rp.PARENT)throw new V("There is no parent graph.");if(e.goto)for(let t of Array.isArray(e.goto)?e.goto:[e.goto])if(rd(t))yield[ru,ro,t];else if("string"==typeof t)yield[ru,`branch:__start__:${ra}:${t}`,"__start__"];else throw Error(`In Command.send, expected Send or string, got ${typeof t}`);if(e.resume){if("object"==typeof e.resume&&Object.keys(e.resume).length&&Object.keys(e.resume).every(J.A))for(let[r,i]of Object.entries(e.resume)){let e=t.filter(e=>e[0]===r&&e[1]===re).map(e=>e[2]).slice(0,1)??[];e.push(i),yield[r,re,e]}else yield[ru,re,e.resume]}if(e.update){if("object"!=typeof e.update||!e.update)throw Error("Expected cmd.update to be a dict mapping channel names to update values");if(Array.isArray(e.update))for(let[t,r]of e.update)yield[ru,t,r];else for(let[t,r]of Object.entries(e.update))yield[ru,t,r]}}(this.input,this.checkpointPendingWrites))void 0===e[t]&&(e[t]=[]),e[t].push([r,i]);if(0===Object.keys(e).length)throw new L("Received empty Command input");for(let[t,r]of Object.entries(e))this.putWrites(t,r)}let n=(this.checkpointPendingWrites??[]).filter(e=>e[0]===ru).map(e=>e.slice(1));if(n.length>0&&it(this.checkpoint,this.channels,[{name:tX,writes:n,triggers:[]}],this.checkpointerGetNextVersion),r){for(let e of Object.keys(this.channels))if(void 0!==this.checkpoint.channel_versions[e]){let t=this.checkpoint.channel_versions[e];this.checkpoint.versions_seen[t7]={...this.checkpoint.versions_seen[t7],[e]:t}}let e=await rC(rN(rU(this.outputKeys,!0,this.channels),"values"));this._emit(e)}else{let t=await rC(function*(e,t){if(null!=t){if(Array.isArray(e)&&"object"==typeof t&&!Array.isArray(t))for(let r in t)e.includes(r)&&(yield[r,t[r]]);else if(Array.isArray(e))throw Error('Input chunk must be an object when "inputChannels" is an array');else yield[e,t]}}(e,this.input));if(0===t.length)throw new L(`Received no input writes for ${JSON.stringify(e,null,2)}`);let r=ir(this.checkpoint,this.checkpointPendingWrites,this.nodes,this.channels,this.managed,this.config,!0,{step:this.step});it(this.checkpoint,this.channels,Object.values(r).concat([{name:tX,writes:t,triggers:[]}]),this.checkpointerGetNextVersion),await this._putCheckpoint({source:"input",writes:Object.fromEntries(t)})}this.input=this.input===il?il:io,this.isNested||(this.config=r4(this.config,{[t5]:this.input===il}))}_emit(e){for(let t of e)this.stream.modes.has(t[0])&&this.stream.push([this.checkpointNamespace,...t])}async _putCheckpoint(e){let t={...e,step:this.step,parents:this.config.configurable?.[t9]??{}};if(void 0!==this.checkpointer){this.prevCheckpointConfig=this.checkpointConfig?.configurable?.checkpoint_id?this.checkpointConfig:void 0,this.checkpointMetadata=t,this.checkpoint=tU(this.checkpoint,this.channels,this.step),this.checkpointConfig={...this.checkpointConfig,configurable:{...this.checkpointConfig.configurable,checkpoint_ns:this.config.configurable?.checkpoint_ns??""}};let e={...this.checkpoint.channel_versions},r=r5(this.checkpointPreviousVersions,e);this.checkpointPreviousVersions=e,this._checkpointerPutAfterPrevious({config:{...this.checkpointConfig},checkpoint:t$(this.checkpoint),metadata:{...this.checkpointMetadata},newVersions:r}),this.checkpointConfig={...this.checkpointConfig,configurable:{...this.checkpointConfig.configurable,checkpoint_id:this.checkpoint.id}}}this.step+=1}_matchWrites(e){for(let[t,r,i]of this.checkpointPendingWrites){if(r===tZ||r===t7||r===re)continue;let n=Object.values(e).find(e=>e.id===t);n&&n.writes.push([r,i])}for(let t of Object.values(e))t.writes.length>0&&this._outputWrites(t.id,t.writes,!0)}}class iu extends ea.BaseCallbackHandler{constructor(e){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"StreamMessagesHandler"}),Object.defineProperty(this,"streamFn",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadatas",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"seen",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"emittedChatModelRunIds",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"stableMessageIdMap",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"lc_prefer_streaming",{enumerable:!0,configurable:!0,writable:!0,value:!0}),this.streamFn=e}_emit(e,t,r,i=!1){if(i&&void 0!==t.id&&void 0!==this.seen[t.id])return;let n=t.id;(null==n||n===`run-${r}`)&&(n=this.stableMessageIdMap[r]??n??`run-${r}`),this.stableMessageIdMap[r]??=n,n!==t.id&&(t.id=n,t.lc_kwargs.id=n),this.seen[t.id]=t,this.streamFn([e[0],"messages",[t,e[1]]])}handleChatModelStart(e,t,r,i,n,s,a,o){!a||s&&(s.includes("langsmith:nostream")||s.includes("nostream"))||(this.metadatas[r]=[a.langgraph_checkpoint_ns.split("|"),{tags:s,name:o,...a}])}handleLLMNewToken(e,t,r,i,n,s){let a=s?.chunk;this.emittedChatModelRunIds[r]=!0,void 0!==this.metadatas[r]&&((0,E.ny)(a?.message)?this._emit(this.metadatas[r],a.message,r):this._emit(this.metadatas[r],new E.H({content:e}),r))}handleLLMEnd(e,t){if(!this.emittedChatModelRunIds[t]){let r=e.generations?.[0]?.[0];(0,E.ny)(r?.message)&&this._emit(this.metadatas[t],r?.message,t,!0),delete this.emittedChatModelRunIds[t]}delete this.metadatas[t],delete this.stableMessageIdMap[t]}handleLLMError(e,t){delete this.metadatas[t]}handleChainStart(e,t,r,i,n,s,a,o){void 0===s||o!==s.langgraph_node||void 0!==n&&n.includes(rs)||(this.metadatas[r]=[s.langgraph_checkpoint_ns.split("|"),{tags:n,name:o,...s}])}handleChainEnd(e,t){let r=this.metadatas[t];if(delete this.metadatas[t],void 0!==r){if((0,E.ny)(e))this._emit(r,e,t,!0);else if(Array.isArray(e))for(let i of e)(0,E.ny)(i)&&this._emit(r,i,t,!0);else if(null!=e&&"object"==typeof e){for(let i of Object.values(e))if((0,E.ny)(i))this._emit(r,i,t,!0);else if(Array.isArray(i))for(let e of i)(0,E.ny)(e)&&this._emit(r,e,t,!0)}}}handleChainError(e,t){delete this.metadatas[t]}}let ih=[400,401,402,403,404,405,406,407,409],id=e=>{if(e.message.startsWith("Cancel")||e.message.startsWith("AbortError")||"AbortError"===e.name||e?.code==="ECONNABORTED")return!1;let t=e?.response?.status??e?.status;return!(t&&ih.includes(+t))&&e?.error?.code!=="insufficient_quota"};async function ip(e,t,r,i){let n,s;let a=e.retry_policy??t,o=void 0!==a?a.initialInterval??500:0,l=0,{config:c}=e;for(r&&(c=r4(c,r));!i?.aborted;){e.writes.splice(0,e.writes.length),n=void 0;try{s=await e.proc.invoke(e.input,c);break}catch(i){var u;if((n=i).pregelTaskId=e.id,void 0!==(u=n)&&u.name===M.unminifiable_name){let t=c?.configurable?.checkpoint_ns,r=n.command;if(r.graph===t){for(let t of e.writers)await t.invoke(r,c);break}if(r.graph===rp.PARENT){let e=t.split("|").slice(0,-1).join("|");n.command=new rp({...n.command,graph:e})}}if(I(n)||void 0===a||(l+=1)>=(a.maxAttempts??3)||!(a.retryOn??id)(n))break;o=Math.min(a.maxInterval??128e3,o*(a.backoffFactor??2));let t=a.jitter?Math.floor(o+1e3*Math.random()):o;await new Promise(e=>setTimeout(e,t));let r=n.name??n.constructor.unminifiable_name??n.constructor.name;console.log(`Retrying task "${String(e.name)}" after ${o.toFixed(2)}ms (attempt ${l}) after ${r}: ${n}`),c=r4(c,{[t5]:!0})}finally{let e=c?.configurable?.checkpoint_ns;e&&B().delete(e)}}return{task:e,result:s,error:n}}class ig{constructor({loop:e,nodeFinished:t}){Object.defineProperty(this,"nodeFinished",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"loop",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.loop=e,this.nodeFinished=t}async tick(e={}){let t;let{timeout:r,signal:i,retryPolicy:n,onStepWrite:s}=e,a=Object.values(this.loop.tasks).filter(e=>0===e.writes.length);for await(let{task:e,error:s}of this._executeTasksWithRetry(a,{stepTimeout:r,signal:i,retryPolicy:n}))t=this._commit(e,s)??t;if(s?.(this.loop.step,Object.values(this.loop.tasks).map(e=>e.writes).flat()),t)throw t}async *_executeTasksWithRetry(e,t){let r,i,n;let{stepTimeout:s,retryPolicy:a}=t??{},o=t?.signal,l=Symbol.for("promiseAdded");i=new Promise(function e(t){r=()=>{i=new Promise(e),t(l)}});let c={},u=(e,t,{calls:i}={})=>{if(t.every(([e])=>e!==rl))return e.config?.configurable?.[tQ]?.(t)??[];let n=e.config?.configurable?.[t3],s={};for(let[o,l]of t.entries()){let[t]=l;if(t!==rl)continue;let d=i?.[o],p=n.callCounter;if(n.callCounter+=1,null==d)throw Error("BUG: No call found");let f=this.loop.acceptPush(e,p,d);if(!f)continue;let g=c[f.id];if(void 0!==g)s[o]=g;else if(f.writes.length>0){let e=f.writes.filter(([e])=>e===rr),t=f.writes.filter(([e])=>e===tZ);if(e.length>0){if(1===e.length)s[o]=Promise.resolve(e[0][1]);else throw Error(`BUG: multiple returns found for task ${f.name}__${f.id}`)}else if(t.length>0){if(1===t.length){let e=t[0][1],r=e instanceof Error?e:Error(String(e));s[o]=Promise.reject(r)}else throw Error(`BUG: multiple errors found for task ${f.name}__${f.id}`)}}else{let e=ip(f,a,{[tQ]:u.bind(this,f),[t0]:h.bind(this,f)});c[f.id]=e,r(),s[o]=e.then(({result:e,error:t})=>t?Promise.reject(t):e)}}return Object.values(s)},h=(e,t,r,i,n={})=>{let s=u(e,[[rl,null]],{calls:[new r1({func:t,name:r,input:i,retry:n.retry,callbacks:n.callbacks})]});return void 0!==s?1===s.length?s[0]:Promise.all(s):Promise.resolve()};if(s&&o?"any"in AbortSignal&&(o=AbortSignal.any([o,AbortSignal.timeout(s)])):s&&(o=AbortSignal.timeout(s)),o?.aborted)throw Error("Abort");Object.assign(c,Object.fromEntries(e.map(e=>[e.id,ip(e,a,{[tQ]:u?.bind(this,e),[t0]:h?.bind(this,e)}).catch(t=>({task:e,error:t}))])));let d=new Promise((e,t)=>{n=()=>t(Error("Abort")),o?.addEventListener("abort",n)}).finally(()=>o?.removeEventListener("abort",n));for(;Object.keys(c).length>0;){let e=await Promise.race([...Object.values(c),d,i]);e!==l&&(yield e,delete c[e.task.id])}}_commit(e,t){let r;if(void 0!==t){if(I(t)){if(this.loop.isNested)throw t;if(D(t)&&(r=t,t.interrupts.length)){let r=t.interrupts.map(e=>[t7,e]),i=e.writes.filter(e=>e[0]===re);i.length&&r.push(...i),this.loop.putWrites(e.id,r)}}else throw this.loop.putWrites(e.id,[[tZ,{message:t.message,name:t.name}]]),t}else this.nodeFinished&&(e.config?.tags==null||!e.config.tags.includes(rs))&&this.nodeFinished(String(e.name)),0===e.writes.length&&e.writes.push([rt,null]),this.loop.putWrites(e.id,e.writes);return r}}class ib{static subscribeTo(e,t){let r;let{key:i,tags:n}=t??{};if(Array.isArray(e)&&void 0!==i)throw Error("Can't specify a key when subscribing to multiple channels");return new rq({channels:"string"==typeof e?i?{[i]:e}:[e]:Object.fromEntries(e.map(e=>[e,e])),triggers:Array.isArray(e)?e:[e],tags:n})}static writeTo(e,t){let r=[];for(let t of e)r.push({channel:t,value:r$,skipNone:!1});for(let[e,i]of Object.entries(t??{}))rk.YN.isRunnable(i)||"function"==typeof i?r.push({channel:e,value:r$,skipNone:!0,mapper:(0,rk.Bp)(i)}):r.push({channel:e,value:i,skipNone:!1});return new rI(r)}}class im extends rk.YN{static lc_name(){return"LangGraph"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langgraph","pregel"]}),Object.defineProperty(this,"lg_is_pregel",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"nodes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"channels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputChannels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputChannels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoValidate",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"streamMode",{enumerable:!0,configurable:!0,writable:!0,value:["values"]}),Object.defineProperty(this,"streamChannels",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"interruptAfter",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"interruptBefore",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"stepTimeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"debug",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"checkpointer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"retryPolicy",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"store",{enumerable:!0,configurable:!0,writable:!0,value:void 0});let{streamMode:t}=e;null==t||Array.isArray(t)||(t=[t]),this.nodes=e.nodes,this.channels=e.channels,this.autoValidate=e.autoValidate??this.autoValidate,this.streamMode=t??this.streamMode,this.inputChannels=e.inputChannels,this.outputChannels=e.outputChannels,this.streamChannels=e.streamChannels??this.streamChannels,this.interruptAfter=e.interruptAfter,this.interruptBefore=e.interruptBefore,this.stepTimeout=e.stepTimeout??this.stepTimeout,this.debug=e.debug??this.debug,this.checkpointer=e.checkpointer,this.retryPolicy=e.retryPolicy,this.config=e.config,this.store=e.store,this.name=e.name,this.autoValidate&&this.validate()}withConfig(e){let t=(0,rk.SV)(this.config,e);return new this.constructor({...this,config:t})}validate(){return function({nodes:e,channels:t,inputChannels:r,outputChannels:i,streamChannels:n,interruptAfterNodes:s,interruptBeforeNodes:a}){if(!t)throw new rK("Channels not provided");let o=new Set,l=new Set;for(let[t,r]of Object.entries(e)){if(t===t7)throw new rK(`"Node name ${t7} is reserved"`);if(r.constructor===rq)r.triggers.forEach(e=>o.add(e));else throw new rK(`Invalid node type ${typeof r}, expected PregelNode`)}for(let e of o)if(!(e in t))throw new rK(`Subcribed channel '${String(e)}' not in channels`);if(Array.isArray(r)){if(r.every(e=>!o.has(e)))throw new rK(`None of the input channels ${r} are subscribed to by any node`)}else if(!o.has(r))throw new rK(`Input channel ${String(r)} is not subscribed to by any node`);for(let e of(Array.isArray(i)?i.forEach(e=>l.add(e)):l.add(i),n&&!Array.isArray(n)?l.add(n):Array.isArray(n)&&n.forEach(e=>l.add(e)),l))if(!(e in t))throw new rK(`Output channel '${String(e)}' not in channels`);if(s&&"*"!==s){for(let t of s)if(!(t in e))throw new rK(`Node ${String(t)} not in nodes`)}if(a&&"*"!==a){for(let t of a)if(!(t in e))throw new rK(`Node ${String(t)} not in nodes`)}}({nodes:this.nodes,channels:this.channels,outputChannels:this.outputChannels,inputChannels:this.inputChannels,streamChannels:this.streamChannels,interruptAfterNodes:this.interruptAfter,interruptBeforeNodes:this.interruptBefore}),this}get streamChannelsList(){return Array.isArray(this.streamChannels)?this.streamChannels:this.streamChannels?[this.streamChannels]:Object.keys(this.channels)}get streamChannelsAsIs(){return this.streamChannels?this.streamChannels:Object.keys(this.channels)}async getGraphAsync(e){return this.getGraph(e)}*getSubgraphs(e,t){for(let[r,i]of Object.entries(this.nodes))if(void 0===e||e.startsWith(r))for(let n of i.subgraphs?.length?i.subgraphs:[i.bound]){let i=rJ(n);if(void 0!==i){if(r===e){yield[r,i];return}if(void 0===e&&(yield[r,i]),t){let n=e;for(let[s,a]of(void 0!==e&&(n=e.slice(r.length+1)),i.getSubgraphs(n,t)))yield[`${r}|${s}`,a]}}}}async *getSubgraphsAsync(e,t){yield*this.getSubgraphs(e,t)}async _prepareStateSnapshot({config:e,saved:t,subgraphCheckpointer:r}){if(void 0===t)return{values:{},next:[],config:e,tasks:[]};let{managed:i}=await this.prepareSpecs(e,{skipManaged:!0}),n=tF(this.channels,t.checkpoint),s=Object.values(ir(t.checkpoint,t.pendingWrites,this.nodes,n,i,t.config,!1,{step:(t.metadata?.step??-1)+1})),a=await rC(this.getSubgraphsAsync()),o=t.config.configurable?.checkpoint_ns??"",l={};for(let e of s){let i=a.find(([t])=>t===e.name);if(!i)continue;let n=`${e.name}:${e.id}`;if(o&&(n=`${o}|${n}`),void 0===r){let r={configurable:{thread_id:t.config.configurable?.thread_id,checkpoint_ns:n}};l[e.id]=r}else{let s={configurable:{[t2]:r,thread_id:t.config.configurable?.thread_id,checkpoint_ns:n}};l[e.id]=await i[1].getState(s,{subgraphs:!0})}}let c=(t.pendingWrites??[]).filter(e=>e[0]===ru).map(e=>e.slice(1));return c.length>0&&it(t.checkpoint,n,[{name:tX,writes:c,triggers:[]}]),{values:rF(n,this.streamChannelsAsIs),next:s.map(e=>e.name),tasks:rQ(s,t?.pendingWrites??[],l),metadata:t.metadata,config:r8(t.config,t.metadata),createdAt:t.checkpoint.ts,parentConfig:t.parentConfig}}async getState(e,t){let r=e.configurable?.[t2]??this.checkpointer;if(!r)throw new T("No checkpointer set");let i=e.configurable?.checkpoint_ns??"";if(""!==i&&e.configurable?.[t2]===void 0){let n=i.split("|").map(e=>e.split(":")[0]).join("|");for await(let[i,s]of this.getSubgraphsAsync(n,!0))if(i===n)return await s.getState(rT(e,{[t2]:r}),{subgraphs:t?.subgraphs});throw Error(`Subgraph with namespace "${n}" not found.`)}let n=(0,rk.SV)(this.config,e),s=await r.getTuple(e);return await this._prepareStateSnapshot({config:n,saved:s,subgraphCheckpointer:t?.subgraphs?r:void 0})}async *getStateHistory(e,t){let r=e.configurable?.[t2]??this.checkpointer;if(!r)throw Error("No checkpointer set");let i=e.configurable?.checkpoint_ns??"";if(""!==i&&e.configurable?.[t2]===void 0){let n=i.split("|").map(e=>e.split(":")[0]).join("|");for await(let[i,s]of this.getSubgraphsAsync(n,!0))if(i===n){yield*s.getStateHistory(rT(e,{[t2]:r}),t);return}throw Error(`Subgraph with namespace "${n}" not found.`)}let n=(0,rk.SV)(this.config,e,{configurable:{checkpoint_ns:i}});for await(let e of r.list(n,t))yield this._prepareStateSnapshot({config:e.config,saved:e})}async updateState(e,t,r){let i=e.configurable?.[t2]??this.checkpointer;if(!i)throw new T("No checkpointer set");let n=e.configurable?.checkpoint_ns??"";if(""!==n&&e.configurable?.[t2]===void 0){let s=n.split("|").map(e=>e.split(":")[0]).join("|");for await(let[,n]of this.getSubgraphsAsync(s,!0))return await n.updateState(rT(e,{[t2]:i}),t,r);throw Error(`Subgraph "${s}" not found`)}let s=this.config?(0,rk.SV)(this.config,e):e,a=await i.getTuple(s),o=void 0!==a?t$(a.checkpoint):tT(),l={...a?.checkpoint.channel_versions},c=a?.metadata?.step??-1,u=rT(s,{checkpoint_ns:s.configurable?.checkpoint_ns??""}),h=s.metadata??{};if(a?.config.configurable&&(u=rT(s,a.config.configurable),h={...a.metadata,...h}),null==t&&void 0===r)return r8(await i.put(u,tU(o,void 0,c),{source:"update",step:c+1,writes:{},parents:a?.metadata?.parents??{}},{}),a?a.metadata:void 0);let d=tF(this.channels,o),{managed:p}=await this.prepareSpecs(s,{skipManaged:!0});if(null===t&&"__end__"===r){if(a){let e=ir(o,a.pendingWrites||[],this.nodes,d,p,a.config,!0,{step:(a.metadata?.step??-1)+1,checkpointer:this.checkpointer||void 0,store:this.store}),t=(a.pendingWrites||[]).filter(e=>e[0]===ru).map(e=>e.slice(1));for(let[r,i,n]of(t.length>0&&it(a.checkpoint,d,[{name:tX,writes:t,triggers:[]}]),a.pendingWrites||[]))![tZ,t7,er].includes(i)&&r in e&&e[r].writes.push([i,n]);it(o,d,Object.values(e))}return r8(await i.put(u,tU(o,void 0,c),{...h,source:"update",step:c+1,writes:{},parents:a?.metadata?.parents??{}},{}),a?a.metadata:void 0)}if(null==t&&"__copy__"===r)return r8(await i.put(a?.parentConfig??u,tU(o,void 0,c),{source:"fork",step:c+1,writes:{},parents:a?.metadata?.parents??{}},{}),a?a.metadata:void 0);if(s.configurable?.checkpoint_id===void 0&&a?.pendingWrites!==void 0&&a.pendingWrites.length>0){let e=ir(o,a.pendingWrites,this.nodes,d,p,a.config,!0,{store:this.store,checkpointer:this.checkpointer,step:(a.metadata?.step??-1)+1}),t=(a.pendingWrites??[]).filter(e=>e[0]===ru).map(e=>e.slice(1));for(let[r,i,n]of(t.length>0&&it(a.checkpoint,d,[{name:tX,writes:t,triggers:[]}]),a.pendingWrites))[tZ,t7,er].includes(i)||void 0===e[r]||e[r].writes.push([i,n]);let r=Object.values(e).filter(e=>e.writes.length>0);r.length>0&&it(o,d,r)}let f=Object.values(o.versions_seen).map(e=>Object.values(e)).flat().find(e=>!!e);if(void 0===r&&void 0===f)"string"==typeof this.inputChannels&&void 0!==this.nodes[this.inputChannels]&&(r=this.inputChannels);else if(void 0===r){let e=Object.entries(o.versions_seen).map(([e,t])=>Object.values(t).map(t=>[t,e])).flat().sort(([e],[t])=>tM(e,t));e&&(1===e.length?r=e[0][1]:e[e.length-1][0]!==e[e.length-2][0]&&(r=e[e.length-1][1]))}if(void 0===r)throw new V('Ambiguous update, specify "asNode"');if(void 0===this.nodes[r])throw new V(`Node "${r.toString()}" does not exist`);let g=this.nodes[r].getWriters();if(!g.length)throw new V(`No writers found for node "${r.toString()}"`);let b={name:r,input:t,proc:g.length>1?rk.zZ.from(g,{omitSequenceTags:!0}):g[0],writes:[],triggers:[t7],id:et(t7,o.id),writers:[]};await b.proc.invoke(b.input,(0,rk.tn)({...s,store:s?.store??this.store},{runName:s.runName??`${this.getName()}UpdateState`,configurable:{[tQ]:e=>b.writes.push(...e),[t1]:(e,t=!1)=>r9(c,o,d,p,b,e,t)}}));let[m,y]=[b.writes.filter(e=>e[0]!==rl),b.writes.filter(e=>e[0]===rl)];void 0!==a&&m.length>0&&await i.putWrites(u,m,b.id),it(o,d,[b],i.getNextVersion.bind(this.checkpointer));let w=r5(l,o.channel_versions),v=await i.put(u,tU(o,d,c+1),{source:"update",step:c+1,writes:{[r]:t},parents:a?.metadata?.parents??{}},w);return y.length>0&&await i.putWrites(v,y,b.id),r8(v,a?a.metadata:void 0)}_defaults(e){let t;let{debug:r,streamMode:i,inputKeys:n,outputKeys:s,interruptAfter:a,interruptBefore:o,...l}=e,c=!0,u=void 0!==r?r:this.debug,h=s;void 0===h?h=this.streamChannelsAsIs:rB(h,this.channels);let d=n;void 0===d?d=this.inputChannels:rB(d,this.channels);let p=o??this.interruptBefore??[],f=a??this.interruptAfter??[];return void 0!==i?(t=Array.isArray(i)?i:[i],c="string"==typeof i):(t=this.streamMode,c=!0),e.configurable?.[t4]!==void 0&&(t=["values"]),[u,t,d,h,l,p,f,!1===this.checkpointer?void 0:void 0!==e&&e.configurable?.[t2]!==void 0?e.configurable[t2]:this.checkpointer,e.store??this.store,c]}async stream(e,t){let r={recursionLimit:this.config?.recursionLimit,...t};return super.stream(e,r)}async prepareSpecs(e,t){let r={...e,store:this.store},i={},n={};for(let[e,r]of Object.entries(this.channels))tB(r)?i[e]=r:t?.skipManaged?n[e]={cls:ry,params:{config:{}}}:n[e]=r;return{channelSpecs:i,managed:new rb(await Object.entries(n).reduce(async(e,[t,i])=>{let n;let s=await e;return rm(i)?("key"in i.params&&"__channel_key_placeholder__"===i.params.key&&(i.params.key=t),n=await i.cls.initialize(r,i.params)):n=await i.initialize(r),void 0!==n&&s.push([t,n]),s},Promise.resolve([])))}}async *_streamIterator(e,t){let r,i;let n=t?.subgraphs,s=rS(this.config,t);if(void 0===s.recursionLimit||s.recursionLimit<1)throw Error('Passed "recursionLimit" must be at least 1.');if(void 0!==this.checkpointer&&!1!==this.checkpointer&&void 0===s.configurable)throw Error('Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"');let{runId:a,...o}=s,[l,c,,u,h,d,p,f,g,b]=this._defaults(o),m=new ia({modes:new Set(c)});if(c.includes("messages")){let e=new iu(e=>m.push(e)),{callbacks:t}=h;if(void 0===t)h.callbacks=[e];else if(Array.isArray(t))h.callbacks=t.concat(e);else{let r=t.copy();r.addHandler(e,!0),h.callbacks=r}}c.includes("custom")&&(h.writer=e=>m.push([[],"custom",e]));let y=await (0,rk.kJ)(h),w=await y?.handleChainStart(this.toJSON(),!e||Array.isArray(e)||e instanceof Date||"object"!=typeof e?{input:e}:e,a,void 0,void 0,void 0,h?.runName??this.getName()),{channelSpecs:v,managed:_}=await this.prepareSpecs(h),k=(async()=>{try{r=await ic.initialize({input:e,config:h,checkpointer:f,nodes:this.nodes,channelSpecs:v,managed:_,outputKeys:u,streamKeys:this.streamChannelsAsIs,store:g,stream:m,interruptAfter:p,interruptBefore:d,manager:w,debug:this.debug});let i=new ig({loop:r,nodeFinished:h.configurable?.nodeFinished});t?.subgraphs&&(r.config.configurable={...r.config.configurable,[t8]:r.stream}),await this._runLoop({loop:r,runner:i,debug:l,config:h})}catch(e){i=e}finally{try{r&&await r.store?.stop(),await Promise.all([...r?.checkpointerPromises??[],...Array.from(_.values()).map(e=>e.promises())])}catch(e){i=i??e}i?m.error(i):m.close()}})();try{for await(let e of m){if(void 0===e)throw Error("Data structure error.");let[t,r,i]=e;c.includes(r)&&(n&&!b?yield[t,r,i]:b?n?yield[t,i]:yield i:yield[r,i])}}catch(e){throw await w?.handleChainError(i),e}finally{await k}await w?.handleChainEnd(r?.output??{})}async invoke(e,t){let r=t?.streamMode??"values",i={...t,outputKeys:t?.outputKeys??this.outputChannels,streamMode:r},n=[];for await(let t of(await this.stream(e,i)))n.push(t);return"values"===r?n[n.length-1]:n}async _runLoop(e){let t;let{loop:r,runner:i,debug:n,config:s}=e;try{for(;await r.tick({inputKeys:this.inputChannels});){if(n){var a,o,l;a=r.checkpointMetadata.step,o=r.channels,l=this.streamChannelsList,console.log([`${rX(rY.blue,`[${a}:checkpoint]`)}`,`\x1b[1m State at the end of step ${a}:\x1b[0m
`,JSON.stringify(rF(o,l),null,2)].join(""))}n&&r0(r.step,Object.values(r.tasks)),await i.tick({timeout:this.stepTimeout,retryPolicy:this.retryPolicy,onStepWrite:(e,t)=>{n&&function(e,t,r){let i={};for(let[e,n]of t)r.includes(e)&&(i[e]||(i[e]=[]),i[e].push(n));console.log([`${rX(rY.blue,`[${e}:writes]`)}`,`\x1b[1m Finished step ${e} with writes to ${Object.keys(i).length} channel${1!==Object.keys(i).length?"s":""}:\x1b[0m
`,Object.entries(i).map(([e,t])=>`- ${rX(rY.yellow,e)} -> ${t.map(e=>JSON.stringify(e)).join(", ")}`).join("\n")].join(""))}(e,t,this.streamChannelsList)},signal:s.signal})}if("out_of_steps"===r.status)throw new x(`Recursion limit of ${s.recursionLimit} reached without hitting a stop condition. You can increase the limit by setting the "recursionLimit" config key.`,{lc_error_code:"GRAPH_RECURSION_LIMIT"})}catch(e){if(t=e,!await r.finishAndHandleError(t))throw e}finally{void 0===t&&await r.finishAndHandleError()}}}class iy extends tG{constructor(e=!0){super(),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"EphemeralValue"}),Object.defineProperty(this,"guard",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.guard=e}fromCheckpoint(e){let t=new iy(this.guard);return e&&(t.value=[e]),t}update(e){if(0===e.length){let e=this.value.length>0;return this.value=[],e}if(1!==e.length&&this.guard)throw new V("EphemeralValue can only receive one value per step.");return this.value=[e[e.length-1]],!0}get(){if(0===this.value.length)throw new W;return this.value[0]}checkpoint(){if(0===this.value.length)throw new W;return this.value[0]}}class iw{constructor(e){Object.defineProperty(this,"condition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"ends",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),rk.YN.isRunnable(e.path)?this.condition=e.path:this.condition=(0,rk.Bp)(e.path).withConfig({runName:"Branch"}),this.ends=Array.isArray(e.pathMap)?e.pathMap.reduce((e,t)=>(e[t]=t,e),{}):e.pathMap}run(e,t){return rI.registerWriter(new rA({trace:!1,func:async(r,i)=>{try{return await this._route(r,i,e,t)}catch(e){throw e.name===R.unminifiable_name&&console.warn("[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\nNodeInterrupt should only be thrown inside a node, not in edge conditions."),e}}}))}async _route(e,t,r,i){let n,s=await this.condition.invoke(i?i(t):e,t);if(Array.isArray(s)||(s=[s]),(n=this.ends?s.map(e=>rd(e)?e:this.ends[e]):s).some(e=>!e))throw Error("Branch condition returned unknown or null destination");if(n.filter(rd).some(e=>e.node===tY))throw new V("Cannot send a packet to the END node");return await r(n,t)??e}}class iv{constructor(){Object.defineProperty(this,"nodes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"edges",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"branches",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"entryPoint",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"compiled",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.nodes={},this.edges=new Set,this.branches={}}warnIfCompiled(e){this.compiled&&console.warn(e)}get allEdges(){return this.edges}addNode(e,t,r){for(let t of["|",":"])if(e.includes(t))throw Error(`"${t}" is a reserved character and is not allowed in node names.`);if(this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."),e in this.nodes)throw Error(`Node \`${e}\` already present.`);if(e===tY)throw Error(`Node \`${e}\` is reserved.`);let i=(0,rk.Bp)(t);return this.nodes[e]={runnable:i,metadata:r?.metadata,subgraphs:rz(i)?[i]:r?.subgraphs,ends:r?.ends},this}addEdge(e,t){if(this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."),e===tY)throw Error("END cannot be a start node");if(t===tJ)throw Error("START cannot be an end node");if(Array.from(this.edges).some(([t])=>t===e)&&!("channels"in this))throw Error(`Already found path for ${e}. For multiple edges, use StateGraph.`);return this.edges.add([e,t]),this}addConditionalEdges(e,t,r){let i="object"==typeof e?e:{source:e,path:t,pathMap:r};if(this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."),!rk.YN.isRunnable(i.path)){let e=Array.isArray(i.pathMap)?i.pathMap.join(","):Object.keys(i.pathMap??{}).join(",");i.path=(0,rk.Bp)(i.path).withConfig({runName:`Branch<${i.source}${""!==e?`,${e}`:""}>`.slice(0,63)})}let n="RunnableLambda"===i.path.getName()?"condition":i.path.getName();if(this.branches[i.source]&&this.branches[i.source][n])throw Error(`Condition \`${n}\` already present for node \`${e}\``);return this.branches[i.source]||(this.branches[i.source]={}),this.branches[i.source][n]=new iw(i),this}setEntryPoint(e){return this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph."),this.addEdge(tJ,e)}setFinishPoint(e){return this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph."),this.addEdge(e,tY)}compile({checkpointer:e,interruptBefore:t,interruptAfter:r,name:i}={}){this.validate([...Array.isArray(t)?t:[],...Array.isArray(r)?r:[]]);let n=new i_({builder:this,checkpointer:e,interruptAfter:r,interruptBefore:t,autoValidate:!1,nodes:{},channels:{[tJ]:new iy,[tY]:new iy},inputChannels:tJ,outputChannels:tY,streamChannels:[],streamMode:"values",name:i});for(let[e,t]of Object.entries(this.nodes))n.attachNode(e,t);for(let[e,t]of this.edges)n.attachEdge(e,t);for(let[e,t]of Object.entries(this.branches))for(let[r,i]of Object.entries(t))n.attachBranch(e,r,i);return n.validate()}validate(e){let t=new Set([...this.allEdges].map(([e,t])=>e));for(let[e]of Object.entries(this.branches))t.add(e);for(let e of t)if(e!==tJ&&!(e in this.nodes))throw Error(`Found edge starting at unknown node \`${e}\``);let r=new Set([...this.allEdges].map(([e,t])=>t));for(let[e,t]of Object.entries(this.branches))for(let i of Object.values(t))if(i.ends)for(let e of Object.values(i.ends))r.add(e);else for(let t of(r.add(tY),Object.keys(this.nodes)))t!==e&&r.add(t);for(let e of Object.values(this.nodes))for(let t of e.ends??[])r.add(t);for(let e of Object.keys(this.nodes))if(!r.has(e))throw new K(`Node \`${e}\` is not reachable.

If you are returning Command objects from your node,
make sure you are passing names of potential destination nodes as an "ends" array
into ".addNode(..., { ends: ["node1", "node2"] })".`,{lc_error_code:"UNREACHABLE_NODE"});for(let e of r)if(e!==tY&&!(e in this.nodes))throw Error(`Found edge ending at unknown node \`${e}\``);if(e){for(let t of e)if(!(t in this.nodes))throw Error(`Interrupt node \`${t}\` is not present`)}this.compiled=!0}}class i_ extends im{constructor({builder:e,...t}){super(t),Object.defineProperty(this,"builder",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.builder=e}attachNode(e,t){this.channels[e]=new iy,this.nodes[e]=new rq({channels:[],triggers:[],metadata:t.metadata,subgraphs:t.subgraphs,ends:t.ends}).pipe(t.runnable).pipe(new rI([{channel:e,value:r$}],[rs])),this.streamChannels.push(e)}attachEdge(e,t){if(t===tY){if(e===tJ)throw Error("Cannot have an edge from START to END");this.nodes[e].writers.push(new rI([{channel:tY,value:r$}],[rs]))}else this.nodes[t].triggers.push(e),this.nodes[t].channels.push(e)}attachBranch(e,t,r){for(let i of(e===tJ&&this.nodes[tJ]&&(this.nodes[tJ]=ib.subscribeTo(tJ,{tags:[rs]})),this.nodes[e].pipe(r.run(r=>new rI(r.map(r=>rd(r)?r:{channel:r===tY?tY:`branch:${e}:${t}:${r}`,value:r$}),[rs]))),r.ends?Object.values(r.ends):Object.keys(this.nodes)))if(i!==tY){let r=`branch:${e}:${t}:${i}`;this.channels[r]=new iy,this.nodes[i].triggers.push(r),this.nodes[i].channels.push(r)}}async getGraphAsync(e){let t=e?.xray,r=new rO.T,i={[tJ]:r.addNode({schema:rj.z.any()},tJ)},n={},s={};function a(e,t,s,o=!1){return t===tY&&void 0===n[tY]&&(n[tY]=r.addNode({schema:rj.z.any()},tY)),r.addEdge(i[e],n[t],s!==t?s:void 0,o)}for(let[a,l]of(t&&(s=Object.fromEntries((await rC(this.getSubgraphsAsync())).filter(e=>ik(e[1])))),Object.entries(this.builder.nodes))){let c=iO(a),u=l.runnable,h=l.metadata??{};if(this.interruptBefore?.includes(a)&&this.interruptAfter?.includes(a)?h.__interrupt="before,after":this.interruptBefore?.includes(a)?h.__interrupt="before":this.interruptAfter?.includes(a)&&(h.__interrupt="after"),t){let l="number"==typeof t?t-1:t,d=void 0!==s[a]?await s[a].getGraphAsync({...e,xray:l}):u.getGraph(e);if(d.trimFirstNode(),d.trimLastNode(),Object.keys(d.nodes).length>1){let[e,t]=r.extend(d,c);if(void 0===e)throw Error(`Could not extend subgraph "${a}" due to missing entrypoint.`);function o(e,t){if(void 0!==e&&!(0,J.A)(e))return e;if(!t||!t.lc_runnable)return t.name??"UnknownSchema";try{let e=t.getName();return e=e.startsWith("Runnable")?e.slice(8):e}catch(e){return t.getName()}}void 0!==t&&(i[c]={name:o(t.id,t.data),...t}),n[c]={name:o(e.id,e.data),...e}}else{let e=r.addNode(u,c,h);i[c]=e,n[c]=e}}else{let e=r.addNode(u,c,h);i[c]=e,n[c]=e}}for(let[e,t]of[...this.builder.allEdges].sort(([e],[t])=>e<t?-1:t>e?1:0))a(iO(e),iO(t));for(let[e,t]of Object.entries(this.builder.branches)){let r={...Object.fromEntries(Object.keys(this.builder.nodes).filter(t=>t!==e).map(e=>[iO(e),iO(e)])),[tY]:tY};for(let i of Object.values(t))for(let[t,n]of Object.entries(void 0!==i.ends?i.ends:r))a(iO(e),iO(n),t,!0)}for(let[e,t]of Object.entries(this.builder.nodes))if(void 0!==t.ends)for(let r of t.ends)a(iO(e),iO(r),void 0,!0);return r}getGraph(e){let t=e?.xray,r=new rO.T,i={[tJ]:r.addNode({schema:rj.z.any()},tJ)},n={},s={};function a(e,t,s,o=!1){return t===tY&&void 0===n[tY]&&(n[tY]=r.addNode({schema:rj.z.any()},tY)),r.addEdge(i[e],n[t],s!==t?s:void 0,o)}for(let[a,l]of(t&&(s=Object.fromEntries(rx(this.getSubgraphs()).filter(e=>ik(e[1])))),Object.entries(this.builder.nodes))){let c=iO(a),u=l.runnable,h=l.metadata??{};if(this.interruptBefore?.includes(a)&&this.interruptAfter?.includes(a)?h.__interrupt="before,after":this.interruptBefore?.includes(a)?h.__interrupt="before":this.interruptAfter?.includes(a)&&(h.__interrupt="after"),t){let l="number"==typeof t?t-1:t,d=void 0!==s[a]?s[a].getGraph({...e,xray:l}):u.getGraph(e);if(d.trimFirstNode(),d.trimLastNode(),Object.keys(d.nodes).length>1){let[e,t]=r.extend(d,c);if(void 0===e)throw Error(`Could not extend subgraph "${a}" due to missing entrypoint.`);function o(e,t){if(void 0!==e&&!(0,J.A)(e))return e;if(!t||!t.lc_runnable)return t.name??"UnknownSchema";try{let e=t.getName();return e=e.startsWith("Runnable")?e.slice(8):e}catch(e){return t.getName()}}void 0!==t&&(i[c]={name:o(t.id,t.data),...t}),n[c]={name:o(e.id,e.data),...e}}else{let e=r.addNode(u,c,h);i[c]=e,n[c]=e}}else{let e=r.addNode(u,c,h);i[c]=e,n[c]=e}}for(let[e,t]of[...this.builder.allEdges].sort(([e],[t])=>e<t?-1:t>e?1:0))a(iO(e),iO(t));for(let[e,t]of Object.entries(this.builder.branches)){let r={...Object.fromEntries(Object.keys(this.builder.nodes).filter(t=>t!==e).map(e=>[iO(e),iO(e)])),[tY]:tY};for(let i of Object.values(t))for(let[t,n]of Object.entries(void 0!==i.ends?i.ends:r))a(iO(e),iO(n),t,!0)}return r}}function ik(e){return"function"==typeof e.attachNode&&"function"==typeof e.attachEdge}function iO(e){return"subgraph"===e?`"${e}"`:e}let ij=(e,t)=>e.size===t.size&&[...e].every(e=>t.has(e));class iP extends tG{constructor(e){super(),Object.defineProperty(this,"lc_graph_name",{enumerable:!0,configurable:!0,writable:!0,value:"NamedBarrierValue"}),Object.defineProperty(this,"names",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"seen",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.names=e,this.seen=new Set}fromCheckpoint(e){let t=new iP(this.names);return e&&(t.seen=new Set(e)),t}update(e){let t=!1;for(let r of e)if(this.names.has(r))this.seen.has(r)||(this.seen.add(r),t=!0);else throw new V(`Value ${JSON.stringify(r)} not in names ${JSON.stringify(this.names)}`);return t}get(){if(!ij(this.names,this.seen))throw new W}checkpoint(){return[...this.seen]}consume(){return!!(this.seen&&this.names&&ij(this.seen,this.names))&&(this.seen=new Set,!0)}}let iE="__root__";class iS extends iv{constructor(e,t){if(super(),Object.defineProperty(this,"channels",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"waitingEdges",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"_schemaDefinition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_inputDefinition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_outputDefinition",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_schemaDefinitions",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"_configSchema",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),function(e){return"object"==typeof e&&null!==e&&void 0===e.stateSchema&&void 0!==e.input&&void 0!==e.output}(e))this._schemaDefinition=e.input.spec,this._inputDefinition=e.input.spec,this._outputDefinition=e.output.spec;else if(function(e){return"object"==typeof e&&null!==e&&void 0!==e.stateSchema}(e))this._schemaDefinition=e.stateSchema.spec,this._inputDefinition=e.input?.spec??this._schemaDefinition,this._outputDefinition=e.output?.spec??this._schemaDefinition;else if(function(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&Object.keys(e).length>0&&Object.values(e).every(e=>"function"==typeof e||tB(e))}(e)||iN(e)){let t=iN(e)?e.spec:e;this._schemaDefinition=t}else if(function(e){return"object"==typeof e&&null!==e&&void 0!==e.channels}(e)){let t=function(e){let t={};for(let[r,i]of Object.entries(e))t[r]=r_(i);return t}(e.channels);this._schemaDefinition=t}else throw Error("Invalid StateGraph input.");this._inputDefinition=this._inputDefinition??this._schemaDefinition,this._outputDefinition=this._outputDefinition??this._schemaDefinition,this._addSchema(this._schemaDefinition),this._addSchema(this._inputDefinition),this._addSchema(this._outputDefinition),this._configSchema=t?.spec}get allEdges(){return new Set([...this.edges,...Array.from(this.waitingEdges).flatMap(([e,t])=>e.map(e=>[e,t]))])}_addSchema(e){if(!this._schemaDefinitions.has(e))for(let[t,r]of(this._schemaDefinitions.set(e,e),Object.entries(e))){let e;if(e="function"==typeof r?r():r,void 0!==this.channels[t]){if(this.channels[t]!==e&&!rm(e)&&"LastValue"!==e.lc_graph_name)throw Error(`Channel "${t}" already exists with a different type.`)}else this.channels[t]=e}}addNode(e,t,r){let i;if(e in this.channels)throw Error(`${e} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);for(let t of["|",":"])if(e.includes(t))throw Error(`"${t}" is a reserved character and is not allowed in node names.`);if(this.warnIfCompiled("Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph."),e in this.nodes)throw Error(`Node \`${e}\` already present.`);if(e===tY||e===tJ)throw Error(`Node \`${e}\` is reserved.`);r?.input!==void 0&&this._addSchema(r.input.spec);let n={runnable:i=rk.YN.isRunnable(t)?t:"function"==typeof t?new rA({func:t,name:e,trace:!1}):(0,rk.Bp)(t),retryPolicy:r?.retryPolicy,metadata:r?.metadata,input:r?.input?.spec??this._schemaDefinition,subgraphs:rz(i)?[i]:r?.subgraphs,ends:r?.ends};return this.nodes[e]=n,this}addEdge(e,t){if("string"==typeof e)return super.addEdge(e,t);for(let t of(this.compiled&&console.warn("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph."),e)){if(t===tY)throw Error("END cannot be a start node");if(!Object.keys(this.nodes).some(e=>e===t))throw Error(`Need to add a node named "${t}" first`)}if(t===tY)throw Error("END cannot be an end node");if(!Object.keys(this.nodes).some(e=>e===t))throw Error(`Need to add a node named "${t}" first`);return this.waitingEdges.add([e,t]),this}compile({checkpointer:e,store:t,interruptBefore:r,interruptAfter:i,name:n}={}){this.validate([...Array.isArray(r)?r:[],...Array.isArray(i)?i:[]]);let s=Object.keys(this._schemaDefinitions.get(this._outputDefinition)),a=1===s.length&&s[0]===iE?iE:s,o=Object.keys(this.channels),l=1===o.length&&o[0]===iE?iE:o,c=new iA({builder:this,checkpointer:e,interruptAfter:i,interruptBefore:r,autoValidate:!1,nodes:{},channels:{...this.channels,[tJ]:new iy},inputChannels:tJ,outputChannels:a,streamChannels:l,streamMode:"updates",store:t,name:n});for(let[e,t]of(c.attachNode(tJ),Object.entries(this.nodes)))c.attachNode(e,t);for(let[e]of(c.attachBranch(tJ,ra,ix(),{withReader:!1}),Object.entries(this.nodes)))c.attachBranch(e,ra,ix(),{withReader:!1});for(let[e,t]of this.edges)c.attachEdge(e,t);for(let[e,t]of this.waitingEdges)c.attachEdge(e,t);for(let[e,t]of Object.entries(this.branches))for(let[r,i]of Object.entries(t))c.attachBranch(e,r,i);return c.validate()}}class iA extends i_{attachNode(e,t){let r;let i=[{value:r$,mapper:new rA({func:(r=e===tJ?Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition)).filter(([e,t])=>!rm(t)).map(([e])=>e):Object.keys(this.builder.channels)).length&&r[0]===iE?function(e){if(rf(e))return e.graph===rp.PARENT?null:e._updateAsTuples();if(Array.isArray(e)&&e.length>0&&e.some(e=>rf(e))){let t=[];for(let r of e)if(rf(r)){if(r.graph===rp.PARENT)continue;t.push(...r._updateAsTuples())}else t.push([iE,r]);return t}return null!=e?[[iE,e]]:null}:function t(i){if(!i)return null;if(rf(i))return i.graph===rp.PARENT?null:i._updateAsTuples();if(Array.isArray(i)&&i.length>0&&i.some(rf)){let e=[];for(let r of i)if(rf(r)){if(r.graph===rp.PARENT)continue;e.push(...r._updateAsTuples())}else{let i=t(r);i&&e.push(...i??[])}return e}{if("object"==typeof i&&!Array.isArray(i))return Object.entries(i).filter(([e])=>r.includes(e));let t=Array.isArray(i)?"array":typeof i;throw new V(`Expected node "${e.toString()}" to return an object or an array containing at least one Command object, received ${t}`,{lc_error_code:"INVALID_GRAPH_NODE_RETURN_VALUE"})}},trace:!1,recurse:!1})}];if(e===tJ)this.nodes[e]=new rq({tags:[rs],triggers:[tJ],channels:[tJ],writers:[new rI(i,[rs])]});else{let r=t?.input??this.builder._schemaDefinition,n=Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(r)).map(e=>[e,e])),s=1===Object.keys(n).length&&iE in n;this.channels[e]=new iy(!1),this.nodes[e]=new rq({triggers:[],channels:s?Object.keys(n):n,writers:[new rI(i.concat({channel:e,value:e}),[rs])],mapper:s?void 0:e=>Object.fromEntries(Object.entries(e).filter(([e])=>e in n)),bound:t?.runnable,metadata:t?.metadata,retryPolicy:t?.retryPolicy,subgraphs:t?.subgraphs,ends:t?.ends})}}attachEdge(e,t){if(t!==tY){if(Array.isArray(e)){let r=`join:${e.join("+")}:${t}`;for(let i of(this.channels[r]=new iP(new Set(e)),this.nodes[t].triggers.push(r),e))this.nodes[i].writers.push(new rI([{channel:r,value:i}],[rs]))}else if(e===tJ){let e=`${tJ}:${t}`;this.channels[e]=new iy,this.nodes[t].triggers.push(e),this.nodes[tJ].writers.push(new rI([{channel:e,value:tJ}],[rs]))}else this.nodes[t].triggers.push(e)}}attachBranch(e,t,r,i={withReader:!0}){let n=async(r,i)=>{let n=r.filter(e=>e!==tY);if(!n.length)return;let s=n.map(r=>rd(r)?r:{channel:`branch:${e}:${t}:${r}`,value:e});await rI.doWrite({...i,tags:(i.tags??[]).concat([rs])},s)};for(let s of(this.nodes[e].writers.push(r.run(n,i.withReader?e=>rW.doRead(e,this.streamChannels??this.outputChannels,!0):void 0)),r.ends?Object.values(r.ends):Object.keys(this.builder.nodes))){if(s===tY)continue;let r=`branch:${e}:${t}:${s}`;this.channels[r]=new iy(!1),this.nodes[s].triggers.push(r)}}}function iN(e){return"object"==typeof e&&null!==e&&"lc_graph_name"in e&&"AnnotationRoot"===e.lc_graph_name}function iC(e){if(rd(e))return[e];let t=[];if(rf(e))t.push(e);else{if(!(Array.isArray(e)&&e.every(rf)))return[];t.push(...e)}let r=[];for(let e of t){if(e.graph===rp.PARENT)throw new M(e);rd(e.goto)||"string"==typeof e.goto?r.push(e.goto):r.push(...e.goto)}return r}function ix(){return new iw({path:new rA({func:iC,tags:[rs],trace:!1,recurse:!1})})}var iT=r(94607);function i$(e,t){let r=Array.isArray(e)?e:[e],i=Array.isArray(t)?t:[t],n=r.map(E.K0),s=i.map(E.K0);for(let e of n)(null===e.id||void 0===e.id)&&(e.id=(0,iT.A)(),e.lc_kwargs.id=e.id);for(let e of s)(null===e.id||void 0===e.id)&&(e.id=(0,iT.A)(),e.lc_kwargs.id=e.id);let a=[...n],o=new Map(a.map((e,t)=>[e.id,t])),l=new Set;for(let e of s){let t=o.get(e.id);if(void 0!==t)"remove"===e._getType()?l.add(e.id):(l.delete(e.id),a[t]=e);else{if("remove"===e._getType())throw Error(`Attempting to delete a message with an ID that doesn't exist ('${e.id}')`);o.set(e.id,a.length),a.push(e)}}return a.filter(e=>!l.has(e.id))}rv.Root({messages:rv({reducer:i$,default:()=>[]})}),S.Nx.initializeGlobalInstance(new A.AsyncLocalStorage),r(88608);class iR extends rA{constructor(e,t){let{name:r,tags:i,handleToolErrors:n}=t??{};super({name:r,tags:i,func:(e,t)=>this.run(e,t)}),Object.defineProperty(this,"tools",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"handleToolErrors",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"trace",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.tools=e,this.handleToolErrors=n??this.handleToolErrors}async run(e,t){let r=Array.isArray(e)?e[e.length-1]:e.messages[e.messages.length-1];if(r?._getType()!=="ai")throw Error("ToolNode only accepts AIMessages as input.");let i=await Promise.all(r.tool_calls?.map(async e=>{let r=this.tools.find(t=>t.name===e.name);try{if(void 0===r)throw Error(`Tool "${e.name}" not found.`);let i=await r.invoke({...e,type:"tool_call"},t);if(E.ny(i)&&"tool"===i._getType()||rf(i))return i;return new E.uf({name:r.name,content:"string"==typeof i?i:JSON.stringify(i),tool_call_id:e.id})}catch(t){if(!this.handleToolErrors||D(t.name))throw t;return new E.uf({content:`Error: ${t.message}
 Please fix your mistakes.`,name:e.name,tool_call_id:e.id??""})}})??[]);return i.some(rf)?i.map(t=>rf(t)?t:Array.isArray(e)?[t]:{messages:[t]}):Array.isArray(e)?i:{messages:i}}}let iM="prompt";function iI(e){let t=e;if(rk.YN.isRunnable(e)&&"bound"in e&&(t=e.bound),!("invoke"in t&&"function"==typeof t.invoke&&"_modelType"in t))throw Error(`Expected \`llm\` to be a ChatModel or RunnableBinding (e.g. llm.bind_tools(...)) with invoke() and generate() methods, got ${t.constructor.name}`);return t}let iD=()=>rv.Root({messages:rv({reducer:i$,default:()=>[]}),structuredResponse:rv});var iL=r(56550),iW=r(23619);let iV=new P.Ny({temperature:.7,model:"claude-3-5-sonnet-latest",apiKey:process.env.ANTHROPIC_API_KEY}),iq=(new TextDecoder,e=>"human"===e._getType()?{content:e.content,role:"user"}:"ai"===e._getType()?{content:e.content,role:"assistant",tool_calls:e.tool_calls}:{content:e.content,role:e._getType()});async function iK(e){try{let t=new j.qc8({network:j.lgv.MAINNET}),r=new j.i5T(t),i=process.env.APTOS_PRIVATE_KEY;if(!i)throw Error("Missing APTOS_PRIVATE_KEY environment variable");let n=await r.deriveAccountFromPrivateKey({privateKey:new j.W_x(j.ZD$.formatPrivateKey(i,j.nVK.Ed25519))}),s=new iL.WX(n,j.lgv.MAINNET),a=new iL.WF(s,r,{PANORA_API_KEY:process.env.PANORA_API_KEY}),o=(0,iL.Xb)(a),l=new tW,c=function(e){let t,r;let{llm:i,tools:n,messageModifier:s,stateModifier:a,prompt:o,stateSchema:l,checkpointSaver:c,checkpointer:u,interruptBefore:h,interruptAfter:d,store:p,responseFormat:f,name:g}=e;if(function(e,t){if(!rk.YN.isRunnable(e)||!("kwargs"in e)||!e.kwargs||"object"!=typeof e.kwargs||!("tools"in e.kwargs))return!0;let r=e.kwargs.tools;if(t.length!==r.length)throw Error("Number of tools in the model.bindTools() and tools passed to createReactAgent must match");let i=new Set(t.map(e=>e.name)),n=new Set;for(let e of r){let t;if("type"in e&&"function"===e.type)t=e.function.name;else{if(!("name"in e))continue;t=e.name}n.add(t)}let s=[...i].filter(e=>!n.has(e));if(s.length>0)throw Error(`Missing tools '${s}' in the model.bindTools().Tools in the model.bindTools() must match the tools passed to createReactAgent.`);return!1}(i,t=Array.isArray(n)?n:n.tools)){if(!("bindTools"in i)||"function"!=typeof i.bindTools)throw Error(`llm ${i} must define bindTools method.`);r=i.bindTools(t)}else r=i;let b=(function(e,t,r){if([e,t,r].filter(e=>null!=e).length>1)throw Error("Expected only one of prompt, stateModifier, or messageModifier, got multiple values");let i=e;return null!=t?i=t:null!=r&&(i=function(e){if("string"==typeof e||(0,E.ny)(e)&&"system"===e._getType())return e;if("function"==typeof e)return async t=>e(t.messages);if(rk.YN.isRunnable(e))return rk.jY.from(e=>e.messages).pipe(e);throw Error(`Unexpected type for messageModifier: ${typeof e}`)}(r)),function(e){let t;if(null==e)t=rk.jY.from(e=>e.messages).withConfig({runName:iM});else if("string"==typeof e){let r=new E.tn(e);t=rk.jY.from(e=>[r,...e.messages??[]]).withConfig({runName:iM})}else if((0,E.ny)(e)&&"system"===e._getType())t=rk.jY.from(t=>[e,...t.messages]).withConfig({runName:iM});else if("function"==typeof e)t=rk.jY.from(e).withConfig({runName:iM});else if(rk.YN.isRunnable(e))t=e;else throw Error(`Got unexpected type for 'prompt': ${typeof e}`);return t}(i)})(o,a,s).pipe(r),m=new Set(t.filter(e=>"returnDirect"in e&&e.returnDirect).map(e=>e.name)),y=e=>{let{messages:t}=e,r=t[t.length-1];return(0,E.KX)(r)&&(!r.tool_calls||0===r.tool_calls.length)?null!=f?"generate_structured_response":tY:"continue"},w=async(e,t)=>{let r;if(null==f)throw Error("Attempted to generate structured output with no passed response schema. Please contact us for help.");let n=e.messages.slice(0,-1);if("object"==typeof f&&"prompt"in f&&"schema"in f){let{prompt:e,schema:t}=f;r=iI(i).withStructuredOutput(t),n.unshift(new E.tn({content:e}))}else r=iI(i).withStructuredOutput(f);return{structuredResponse:await r.invoke(n,t)}},v=async(e,t)=>({messages:[await b.invoke(e,t)]}),_=new iS(l??iD()).addNode("agent",v).addNode("tools",new iR(t)).addEdge(tJ,"agent");return void 0!==f?_.addNode("generate_structured_response",w).addEdge("generate_structured_response",tY).addConditionalEdges("agent",y,{continue:"tools",[tY]:tY,generate_structured_response:"generate_structured_response"}):_.addConditionalEdges("agent",y,{continue:"tools",[tY]:tY}),m.size>0?_.addConditionalEdges("tools",e=>{for(let t=e.messages.length-1;t>=0;t-=1){let r=e.messages[t];if(!(0,E.wk)(r))break;if(void 0!==r.name&&m.has(r.name))return tY}return"agent"},["agent",tY]):_.addEdge("tools","agent"),_.compile({checkpointer:u??c,interruptBefore:h,interruptAfter:d,store:p,name:g})}({llm:iV,tools:o,checkpointSaver:l,messageModifier:`
        You are a helpful agent that can interact onchain using the Aptos Agent Kit. You are
        empowered to interact onchain using your tools. If you ever need funds, you can request them from the
        faucet. If not, you can provide your wallet details and request funds from the user. If there is a 5XX
        (internal) HTTP error code, ask the user to try again later. If someone asks you to do something you
        can't do with your currently available tools, you must say so, and encourage them to implement it
        themselves using the Aptos Agent Kit, recommend they go to https://www.aptosagentkit.xyz for more information. Be
        concise and helpful with your responses. Refrain from restating your tools' descriptions unless it is explicitly requested.

		The response also contains token/token[] which contains the name and address of the token and the decimals.
		WHEN YOU RETURN ANY TOKEN AMOUNTS, RETURN THEM ACCORDING TO THE DECIMALS OF THE TOKEN.
      `}),u=await e.json(),h=u.messages??[];if(u.show_intermediate_steps){let e=await c.invoke({messages:h});return console.log("result",e),iW.NextResponse.json({messages:e.messages.map(iq)},{status:200})}{let e=await c.streamEvents({messages:h},{version:"v2",configurable:{thread_id:"Aptos Agent Kit!"}}),t=new TextEncoder,r=new ReadableStream({async start(r){for await(let{event:i,data:n}of e)if("on_chat_model_stream"===i&&n.chunk.content){if("string"==typeof n.chunk.content)r.enqueue(t.encode(n.chunk.content));else for(let e of n.chunk.content)r.enqueue(t.encode(e.text?e.text:""))}r.close()}});return new Response(r)}}catch(e){return console.error("Request error:",e),iW.NextResponse.json({error:e instanceof Error?e.message:"An error occurred",status:"error"},{status:500})}}let iB=new _.AppRouteRouteModule({definition:{kind:k.RouteKind.APP_ROUTE,page:"/api/hello/route",pathname:"/api/hello",filename:"route",bundlePath:"app/api/hello/route"},resolvedPagePath:"/Users/fujiawang/Desktop/chatbot/app/api/hello/route.ts",nextConfigOutput:"",userland:v}),{workAsyncStorage:iG,workUnitAsyncStorage:iF,serverHooks:iU}=iB;function iH(){return(0,O.patchFetch)({workAsyncStorage:iG,workUnitAsyncStorage:iF})}},32007:()=>{},45919:()=>{}};var t=require("../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),i=t.X(0,[686,180,265],()=>r(28204));module.exports=i})();